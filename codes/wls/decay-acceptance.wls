#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter::Closed:: *)
(*Decay acceptance definitions*)


(* ::Section::Closed:: *)
(*A kink in the trajectory due to magnetic field*)


(* ::Subsection:: *)
(*Parameters*)


(* ::Input:: *)
(*(*electric charge in SI units*)*)
(*qValSI=1.6*10^-19;*)
(*(*Magnetic field in SI units*)*)
(*BvalFCCee=1;*)
(*(*Electron mass in SI units*)*)
(*mekG=9.1*10^-31;*)
(*m\[Mu]kG=105/(0.5*10^-3) 9.1*10^-31;*)
(*hbar=6.58*10^-25;*)
(*cval=3*10^8;*)
(*(*1 kg in terms of GeV. Converted using the electron mass in GeV and in kg*)*)
(*kgToGeVval=(0.5*10^-3)/(9.1*10^-31);*)
(*GeVTokgVal=kgToGeVval^-1;*)


(* ::Subsection:: *)
(*Constant magnetic field*)


(* ::Subsubsection:: *)
(*Exact expressions*)


(* ::Input:: *)
(*(*Velocities in SI in terms of p, E in GeV, and speed of light*)*)
(*vxEnergy=c*pxGeV/EGeV;*)
(*vyEnergy=c*pyGeV/EGeV;*)
(*vzEnergy=c*pzGeV/EGeV;*)
(*\[Gamma]Energy=EGeV/mGeV;*)
(*(*EOMs \[Gamma] (dOverscript[v, _])/dt = q[Overscript[v, _]\[Times]Overscript[B, _]], where Overscript[B, _] is assumed to be located along the y axis in the positive direction. All the quantities entering the EOM are in SI units*)*)
(*EQsHelicalTrajectory=DSolve[{x''[t]==1/(m*\[Gamma]) q*Cross[{x'[t],y'[t],z'[t]},{0,B,0}][[1]],y''[t]==1/(m*\[Gamma]) q*Cross[{x'[t],y'[t],z'[t]},{0,B,0}][[2]],z''[t]==q/(m*\[Gamma])*Cross[{x'[t],y'[t],z'[t]},{0,B,0}][[3]],x[0]==x0,y[0]==y0,z[0]==z0,x'[0]==vx,y'[0]==vy,z'[0]==vz},{x,y,z},t][[1]];*)
(*Print["Helical trajectories - x, y, z. Here, \!\(\*SubscriptBox[\(p\), \(i\)]\) in the units of GeV:"]*)
(*{xHelicalTemp1[x0m_,pxGeV_,pzGeV_,EGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_],yHelicalTemp1[y0m_,pyGeV_,EGeV_,tsecond_],zHelicalTemp1[z0m_,pxGeV_,pzGeV_,EGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_]}={(x[t]/.EQsHelicalTrajectory),(y[t]/.EQsHelicalTrajectory),(z[t]/.EQsHelicalTrajectory)}/.{vx->vxEnergy,vy->vyEnergy,vz->vzEnergy,\[Gamma]->\[Gamma]Energy,m-> mGeV*GeVTokg,B->BTl,q->qCoulomb,x0->x0m,t->tsecond}*)
(*Print["Velocities dx/dt, dy/dt, dz/dt:"]*)
(*{vxHelicalTemp1[pxGeV_,pzGeV_,EGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_],vyHelicalTemp1[pyGeV_,EGeV_],vzHelicalTemp1[pxGeV_,pzGeV_,EGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_]}={D[xHelicalTemp1[x0m,pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg],tsecond],D[yHelicalTemp1[y0m,pyGeV,EGeV,tsecond],tsecond],D[zHelicalTemp1[z0m,pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg],tsecond]}//Simplify*)
(*Print["Momenta \!\(\*SubscriptBox[\(p\), \(i\)]\)(t) = E \!\(\*SubscriptBox[\(v\), \(i\)]\)(t)/\!\(\*SuperscriptBox[\(c\), \(2\)]\):"]*)
(*{pxHelicalTemp1[pxGeV_,pzGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_],pyHelicalTemp1[pyGeV_],pzHelicalTemp1[pxGeV_,pzGeV_,BTl_,qCoulomb_,tsecond_,GeVTokg_]}=EGeV/c {vxHelicalTemp1[pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg],vyHelicalTemp1[pyGeV,EGeV],vzHelicalTemp1[pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg]}//Simplify*)
(*Print["Cross-check: \!\(\*SuperscriptBox[OverscriptBox[\(v\), \(_\)], \(2\)]\)(t) = \!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(x\)]\)(t)+\!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(y\)]\)(t)+\!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(z\)]\)(t) is equal to \!\(\*SuperscriptBox[\(v\), \(2\)]\)(t = 0) = \!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(x, 0\)]\)+\!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(y, 0\)]\)+\!\(\*SubscriptBox[SuperscriptBox[\(v\), \(2\)], \(z, 0\)]\) = \!\(\*SuperscriptBox[\(c\), \(2\)]\)\!\(\*SuperscriptBox[OverscriptBox[\(p\), \(_\)], \(2\)]\)/\!\(\*SuperscriptBox[\(E\), \(2\)]\)"]*)
(*vxHelicalTemp1[pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg]^2+vyHelicalTemp1[pyGeV,EGeV]^2+vzHelicalTemp1[pxGeV,pzGeV,EGeV,BTl,qCoulomb,tsecond,GeVTokg]^2//Expand//Simplify*)
(*(*Therefore, after passing the domain with the magnetic field, the new Subscript[p', x],Subscript[p', z] are Subscript[p', x] = Subscript[p, x,0]\[Times](Subscript[v, x](Subscript[t, passing]))/Subscript[v, x,0], Subscript[p', z] = Subscript[p, z,0]\[Times](Subscript[v, z](Subscript[t, passing]))/Subscript[v, z,0]*)*)
(*(*Approximate value of the period of time for which the charged particle passes through the domain with magnetic field. It is estimated roughly assuming that the momentum Subscript[p, z] is left unchanged*)*)
(*tz0[zprojm_,z0m_,c_,pzGeV_,EGeV_]=(*t/.Solve[zHelicalTemp1[z0m,pxGeV,pzGeV,EGeV,BTl,qCoulomb,t,GeVTokg]\[Equal]zproj,t][[1]]/.{Subscript[\[ConstantC], 1]\[Rule]0}*)t/.Solve[z0m+vzEnergy*t==zprojm,t][[1]];*)
(*(*Helical trajectories x[Subscript[t, z = 0]], y[Subscript[t, z = 0]].*)*)
(*xHelicalTemp2[x0m_,z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=xHelicalTemp1[x0m,pxGeV,pzGeV,EGeV,BTl,qCoulomb,tz0[zprojm,z0m,c,pzGeV,EGeV],GeVTokg]/.{c->cval,qCoulomb-> qValSI*qsign,GeVTokg->GeVTokgVal};*)
(*yHelicalTemp2[y0m_,z0m_,pyGeV_,pzGeV_,zprojm_]=yHelicalTemp1[y0m,pyGeV,EGeV,tz0[zprojm,z0m,c,pzGeV,EGeV]]/.{m->mlkg,\[Gamma]->\[Gamma]Energy,vz->vzEnergy,vx->vxEnergy,vy->vyEnergy}/.{c->cval,qCoulomb-> qValSI*qsign,GeVTokg->GeVTokgVal};*)
(*zHelicalTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=zHelicalTemp1[z0m,pxGeV,pzGeV,EGeV,BTl,qCoulomb,tz0[zprojm,z0m,c,pzGeV,EGeV],GeVTokg]/.{c->3*10^8,qCoulomb-> qValSI*qsign,GeVTokg->GeVTokgVal};*)
(*{pxHelicalTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_],pyHelicalTemp2[pyGeV_],pzHelicalTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]}={pxHelicalTemp1[pxGeV,pzGeV,BTl,qCoulomb,tz0[zprojm,z0m,c,pzGeV,EGeV],GeVTokg],pyHelicalTemp1[pyGeV],pzHelicalTemp1[pxGeV,pzGeV,BTl,qCoulomb,tz0[zprojm,z0m,c,pzGeV,EGeV],GeVTokg]}/.{c->cval,qCoulomb-> qValSI*qsign,GeVTokg->GeVTokgVal}//Simplify;*)
(*Print["Larmor radius (in m):"]*)
(*LarmorRadius[EGeV_,BTl_]=cval*(EGeV*GeVTokgVal)/(qValSI*BTl)*)


(* ::Subsubsection:: *)
(*Approx expressions*)


(* ::Input:: *)
(*(*The minimal value of momentum at which the trigonometric functions may be replaced with their expansion*)*)
(*pzKickApprox[BTl_,zprojm_,z0m_]=pzGeV/.Solve[(BTl*qValSI)/EGeV*tz0[zprojm,z0m,cval,pzGeV,EGeV] 1/GeVTokgVal==0.2,pzGeV][[1]]//Simplify;*)
(*(*Expansions of the coordinate and momenta*)*)
(*xHelicalApproxTemp2[x0m_,z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=Normal@Series[xHelicalTemp1[x0m,pxGeV,pzGeV,EGeV,BTl,qValSI,tsecond,GeVTokgVal],{tsecond,0,2}]/.{c->cval}/.{tsecond-> tz0[zprojm,z0m,cval,pzGeV,EGeV]}//Simplify;*)
(*zHelicalApproxTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=Normal@Series[zHelicalTemp1[z0m,pxGeV,pzGeV,EGeV,BTl,qValSI*qsign,tsecond,GeVTokgVal],{tsecond,0,2}]/.{c->cval}/.{tsecond-> tz0[zprojm,z0m,cval,pzGeV,EGeV]}//Simplify;*)
(*pxHelicalApproxTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=(Normal@Series[pxHelicalTemp1[pxGeV,pzGeV,BTl,qValSI*qsign,tsecond,GeVTokgVal],{tsecond,0,1}])/.{tsecond-> tz0[zprojm,z0m,cval,pzGeV,EGeV]}//Simplify;*)
(*pzHelicalApproxTemp2[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=(Normal@Series[pzHelicalTemp1[pxGeV,pzGeV,BTl,qValSI*qsign,tsecond,GeVTokgVal],{tsecond,0,1}])/.{tsecond-> tz0[zprojm,z0m,cval,pzGeV,EGeV]}//Simplify;*)
(*pzHelicalApprox[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=If[pzGeV>pzKickApprox[BTl,zprojm,z0m],Evaluate[pzHelicalApproxTemp2[z0m,pxGeV,pzGeV,BTl,qsign,zprojm]],Evaluate[pzHelicalTemp2[z0m,pxGeV,pzGeV,BTl,qsign,zprojm]]];*)
(*pxHelicalApprox[z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=If[pzGeV>pzKickApprox[BTl,zprojm,z0m],Evaluate[pxHelicalApproxTemp2[z0m,pxGeV,pzGeV,BTl,qsign,zprojm]],Evaluate[pxHelicalTemp2[z0m,pxGeV,pzGeV,BTl,qsign,zprojm]]];*)
(*xHelicalApprox[x0m_,z0m_,pxGeV_,pzGeV_,BTl_,qsign_,zprojm_]=If[pzGeV>pzKickApprox[BTl,zprojm,z0m],Evaluate[xHelicalApproxTemp2[x0m,z0m,pxGeV,pzGeV,BTl,qsign,zprojm]],Evaluate[xHelicalTemp2[x0m,z0m,pxGeV,pzGeV,BTl,qsign,zprojm]]];*)


(* ::Section:: *)
(*Pre-definitions*)


(* ::Input:: *)
(*(*Consider the table Subscript[E, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP],Subscript[\[Epsilon], az],Subscript[\[Phi], LLP]. The compiled code below removes rows for which Subscript[E, LLP] < Subscript[m, LLP] or Subscript[\[Epsilon], azimuthal] = 0*)*)
(*TableLLPnonZeroCompiled=Hold@Compile[{{TableLLPgridWithELLP,_Real,2},{mLLP,_Real}},Select[TableLLPgridWithELLP,#[[indexELLP]]>mLLP(*&&#[[indexLLPazAcc]]\[NotEqual]0.*)&],CompilationTarget->"C",RuntimeOptions->"Speed"]/.OwnValues@indexELLP/.OwnValues@indexLLPazAcc//ReleaseHold;*)
(*TableLLPzeroCompiled=Hold@Compile[{{TableLLPgridWithELLP,_Real,2},{mLLP,_Real}},Select[TableLLPgridWithELLP,#[[indexELLP]]<=mLLP(*||#[[indexLLPazAcc]]\[Equal]0.*)& ],CompilationTarget->"C",RuntimeOptions->"Speed"]/.OwnValues@indexELLP/.OwnValues@indexLLPazAcc//ReleaseHold;*)
(*(*Consider a table of Subscript[\[Epsilon], decay], where each NofPhiVals values correspond to the same Subscript[E, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP] but to different Subscript[\[Phi], LLP]. The compiled code below averages over \[Phi]*)*)
(*\[Epsilon]DecayE\[Theta]zcompiled=Hold@Compile[{{DecayAcceptanceE\[Theta]z\[Phi],_Real,2},{NofPhiVals,_Integer}},(1/NofPhiVals)Table[{Sum[DecayAcceptanceE\[Theta]z\[Phi][[i]][[1]],{i,(i0-1)*NofPhiVals+1,i0*NofPhiVals}]},{i0,1,Length[DecayAcceptanceE\[Theta]z\[Phi]]/NofPhiVals,1}],CompilationTarget->"C",RuntimeOptions->"Speed"]//ReleaseHold;*)
(*(*This code averages the decay acceptance over the domains where the LLP points/does not point to the detector*)*)
(*\[Epsilon]dec1Compiled=  Compile[{{tabToDet,_Real,1},{tabNotToDet,_Real,1},{mLLP,_Real}},Module[{angles,energies,zs,\[Epsilon]azToDet,\[Epsilon]azNotToDet,\[Epsilon]DecToDet,\[Epsilon]DecNotToDet,\[Epsilon]DecAv},*)
(*angles=Compile`GetElement[tabToDet,1];*)
(*energies=Compile`GetElement[tabToDet,2];*)
(*zs=Compile`GetElement[tabToDet,3];*)
(*\[Epsilon]azToDet=Compile`GetElement[tabToDet,4];*)
(*\[Epsilon]azNotToDet=Compile`GetElement[tabNotToDet,4];*)
(*\[Epsilon]DecToDet=Compile`GetElement[tabToDet,5];*)
(*\[Epsilon]DecNotToDet=Compile`GetElement[tabNotToDet,5];*)
(*\[Epsilon]DecAv=(\[Epsilon]azToDet*\[Epsilon]DecToDet+\[Epsilon]azNotToDet*\[Epsilon]DecNotToDet)/(\[Epsilon]azToDet+\[Epsilon]azNotToDet+10^-90.)+10^-90.;*)
(*{mLLP,angles,energies,zs,\[Epsilon]azToDet+\[Epsilon]azNotToDet,\[Epsilon]DecAv}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}];*)
(*\[Epsilon]dec2Compiled=Compile[{{tabToDet,_Real,2},{mLLP,_Real}},Join[Table[{mLLP},{i,1,Length[tabToDet],1}],tabToDet,2],CompilationTarget->"C",RuntimeOptions->"Speed"];*)


(* ::Subsection:: *)
(*Kinematic variables used for imposing cuts*)


(* ::Input:: *)
(*(*IP cut*)*)
(*(*Consider two particles originating from the same point Subscript[r, prod]. Their trajectory is given by the formula below*)*)
(*TrajectoryProducts[xprod_,yprod_,zprod_,px1_,px2_,py1_,py2_,pz1_,pz2_,zproj_]={xprod+(zproj-zprod)*(px1+px2)/(pz1+pz2),yprod+(zproj-zprod)*(py1+py2)/(pz1+pz2),zproj};*)
(*(*Transverse impact parameter*)*)
(*IPproductsSquared[xprod_,yprod_,zprod_,px1_,px2_,py1_,py2_,pz1_,pz2_,zproj_]=(TrajectoryProducts[xprod,yprod,zprod,px1,px2,py1,py2,pz1,pz2,zproj][[1]]^2+TrajectoryProducts[xprod,yprod,zprod,px1,px2,py1,py2,pz1,pz2,zproj][[2]]^2//Expand//Simplify);*)
(*IPproductzTargetSquared[xprod_,yprod_,zprod_,px1_,px2_,py1_,py2_,pz1_,pz2_]=IPproductsSquared[xprod,yprod,zprod,px1,px2,py1,py2,pz1,pz2,0]^2//Simplify;*)
(*(*Spatial separation cut: for photons*)*)
(*TrajectoryDifferenceProducts[xprod_,yprod_,zprod_,px1_,px2_,py1_,py2_,pz1_,pz2_,CoordProj_]={(CoordProj-zprod)*px1/pz1-(CoordProj-zprod)*px2/pz2,(CoordProj-zprod)*py1/pz1-(CoordProj-zprod)*py2/pz2,0.};*)
(*(*For the experiments for which the decay volume is detector, the ECAL position is formally assumed to be at the end of the decay volume*)*)
(*ecalpos=If[DecayVolumeAsDetectorGivenExperiment=="False",ECALpositionGivenExperiment,xLongMaxDetectorGivenExperiment];*)
(*SSproductsSquaredOld[zprod_,px1_,px2_,py1_,py2_,pz1_,pz2_,CoordProj_]=(TrajectoryDifferenceProducts[xprod,yprod,zprod,px1,px2,py1,py2,pz1,pz2,CoordProj][[1]]^2+TrajectoryDifferenceProducts[xprod,yprod,zprod,px1,px2,py1,py2,pz1,pz2,CoordProj][[2]]^2//Expand//Simplify);*)
(*SSproductsSquared[xfin1_,xfin2_,yfin1_,yfin2_]=(xfin1-xfin2)^2+(yfin1-yfin2)^2;*)
(*minvProductsSquared[px1_,py1_,pz1_,E1_,px2_,py2_,pz2_,E2_]=(E1+E2)^2-(px1+px2)^2-(py1+py2)^2-(pz1+pz2)^2;*)
(*CosAngleProducts[px1_,px2_,py1_,py2_,pz1_,pz2_]=With[{p1={px1,py1,pz1},p2={px2,py2,pz2}},p1 . p2/(Norm[p1]Norm[p2])];*)


(* ::Section:: *)
(*Routine of calculating the decay acceptance*)


(* ::Subsection:: *)
(*Trajectory of the decay products*)


(* ::Subsubsection:: *)
(*No magnetic field*)


(* ::Input:: *)
(*FinalPlaneSign=Sign[xLongMaxDetectorGivenExperiment];*)
(*MomDirection[py_,pz_]=If[DetectorPlaneOrientationGivenExperiment=="Transverse",pz,py];*)
(*(*LLP's decay poing as a function of z,\[Theta],\[Phi]*)*)
(*(*LLPdecayVertex[zLLP_,\[Theta]LLP_,\[Phi]LLP_]={LLPdecVTXatGivenZx[zLLP,\[Theta]LLP,\[Phi]LLP],LLPdecVTXatGivenZy[zLLP,\[Theta]LLP,\[Phi]LLP],zLLP};*)*)
(*LLPdecayVertexX[zLLP_,\[Theta]LLP_,\[Phi]LLP_]=LLPdecVTXatGivenZx[zLLP,\[Theta]LLP,\[Phi]LLP]/. Cot[x_]:>1/Tan[x]/. Csc[x_]:>1/Sin[x]/.Sec[x_]:>1/Cos[x];*)
(*LLPdecayVertexY[zLLP_,\[Theta]LLP_,\[Phi]LLP_]=LLPdecVTXatGivenZy[zLLP,\[Theta]LLP,\[Phi]LLP]/. Cot[x_]:>1/Tan[x]/. Csc[x_]:>1/Sin[x]/.Sec[x_]:>1/Cos[x];*)
(*LLPdecayVertexZ[zLLP_,\[Theta]LLP_,\[Phi]LLP_]=zLLP;*)
(*If[GivenExperiment!="ANUBIS-ceiling",*)
(*(*Trajectory of the daughter's particles given the LLP decay position and the daughter's 3-momenta in the lab frame of the decaying LLP - at the position of the final plane of the detector*)*)
(*DaughterTrajectory[xLLPdecay_,yLLPdecay_,zLLPdecay_,XlongProj_,px_,py_,pz_]=If[DetectorPlaneOrientationGivenExperiment=="Transverse",{xLLPdecay+(XlongProj-zLLPdecay)(px/pz),yLLPdecay+(XlongProj-zLLPdecay)(py/pz),XlongProj},{xLLPdecay+(XlongProj-yLLPdecay)(px/py),XlongProj,zLLPdecay+(XlongProj-yLLPdecay)(pz/py)}],*)
(*(*___________________________________________*)*)
(*(*Projection of the decay products trajectory onto the detector final surface - for ANUBIS-ceiling*)*)
(*(*___________________________________________*)*)
(*xx[x0_,vx_,t_]=x0+vx*t;*)
(*yy[y0_,vy_,t_]=y0+vy*t;*)
(*zz[z0_,vz_,t_]=z0+vz*t;*)
(*(*The condition that the trajectory intersects the surface of the cavern. Here, xshift, yshift are just the shiftings of the beamline from the center of the cavern where ATLAS is located*)*)
(*rho2[x0_,y0_,vx_,vy_,t_,xshift_,yshift_]=(xx[x0,vx,t]+xshift)^2+(yy[y0,vy,t]+yshift)^2//Expand//Simplify;*)
(*(*The moment of time at which the trajectory intersects the surface of the cavern*)*)
(*tsol[x0_,y0_,vx_,vy_,\[Rho]det_,xshift_,yshift_]=t/.Solve[rho2[x0,y0,vx,vy,t,xshift,yshift]==\[Rho]det^2,t];*)
(*(*The values of the coordinates of the decay product at this moment of time*)*)
(*DaughterTrajectory[xLLPdecay_,yLLPdecay_,zLLPdecay_,XlongProj_,px_,py_,pz_]={xx[xLLPdecay,px,tsol[xLLPdecay,yLLPdecay,px,py,RouterDecayVolumeGivenExperiment[z],xshiftval,yshiftval][[2]]]//Expand//Simplify,yy[yLLPdecay,py,tsol[xLLPdecay,yLLPdecay,px,py,RouterDecayVolumeGivenExperiment[z],xshiftval,yshiftval][[2]]]//Expand//Simplify,zz[zLLPdecay,pz,tsol[xLLPdecay,yLLPdecay,px,py,RouterDecayVolumeGivenExperiment[z],xshiftval,yshiftval][[2]]]//Expand//Simplify};*)
(*]*)
(*DaughterTrajectoryCoord1[xLLPdecay_,yLLPdecay_,zLLPdecay_,XlongProj_,px_,py_,pz_]=If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[DaughterTrajectory[xLLPdecay,yLLPdecay,zLLPdecay,XlongProj,px,py,pz][[1]]],99999.];*)
(*DaughterTrajectoryCoord2[xLLPdecay_,yLLPdecay_,zLLPdecay_,XlongProj_,px_,py_,pz_]=If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[DaughterTrajectory[xLLPdecay,yLLPdecay,zLLPdecay,XlongProj,px,py,pz][[pointSecondCoordinate]]],99999.];*)


(* ::Subsubsection:: *)
(*With magnetic field*)


(* ::Input:: *)
(*(*The magnetic field is assumed to be parallel to the y axis*)*)
(*(*_______________________________________*)*)
(*(*Trajectory of the daughter's particle before being affected by the magnet at z = zProj. It is a function of the LLP decay vertex and the daughter's kinematics before the magnet - Subscript[p, x],Subscript[p, y],Subscript[p, z]*)*)
(*(*For the x coordinate, the value of zProj is taken to be the beginning of the magnet/the LLP's Subscript[z, decay] (here and below, it is always assumed that Subscript[z, decay] > Subscript[z, magnet,max])*)*)
(*(*For the y coordinate, the value is taken to be the end of the magnet. This is because it is assumed for simplicity that the evolution of the y coordinate up to the end of the magnet is the same as it would be without the magnet*)*)
(*LarmorRadiusGivenExperiment[EGeV_]=If[DipoleMagnetOptionGivenExperiment=="False",0,LarmorRadius[EGeV,Bval]];*)
(*xAtMagnetStart[xLLPdecay_,yLLPdecay_,zLLPdecay_,px_,py_,pz_]=If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[xLLPdecay+(Max[zMagnetMinGivenExperiment,zLLPdecay]-zLLPdecay)(px/pz)],99999.];*)
(*(*The coordinate 2 is assumed to be the same just after the magnet as if there would not be any magnetic field*)*)
(*yAtMagnetEnd[xLLPdecay_,yLLPdecay_,zLLPdecay_,px_,py_,pz_]=If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[yLLPdecay+(zMagnetMaxGivenExperiment-zLLPdecay)(py/pz)],99999.];*)
(*(*____________________________________________*)*)
(*(*Trajectory of the daughter's particle after passing the domain with magnetic field*)*)
(*(*____________________________________________*)*)
(*(*The x-coordinate, as well as the momenta Subscript[p, x],Subscript[p, z] get changed depending on the charge sign of the particle. This is taken into account by kinking of their values*)*)
(*xAtDetectorEndMagnetEffectTemp[zLLPdecay_,xprojBeforeMagnet_,pxaftermagnet_,py_,pzaftermagnet_,qval_]=If[DipoleMagnetOptionGivenExperiment=="True",xHelicalApprox[xprojBeforeMagnet,Max[zMagnetMinGivenExperiment,zLLPdecay],pxaftermagnet,pzaftermagnet,Bval,qval,zMagnetMaxGivenExperiment]//Expand//Simplify,999999.];*)
(*yAtDetectorEndMagnetEffectTemp[zLLPdecay_,yprojAfterMagnet_,py_,pzaftermagnet_]=If[DipoleMagnetOptionGivenExperiment=="True",yprojAfterMagnet+(xLongMaxDetectorGivenExperiment-zMagnetMaxGivenExperiment)(py/pzaftermagnet),99999.];*)
(*pxAfterMagnet[zLLPdecay_,px_,pz_,qval_]=If[DipoleMagnetOptionGivenExperiment=="True",pxHelicalApprox[Max[zLLPdecay,zMagnetMinGivenExperiment],px,pz,Bval,qval,zMagnetMaxGivenExperiment],100000.];*)
(*pzAfterMagnet[zLLPdecay_,px_,pz_,qval_]=If[DipoleMagnetOptionGivenExperiment=="True",pzHelicalApprox[Max[zLLPdecay,zMagnetMinGivenExperiment],px,pz,Bval,qval,zMagnetMaxGivenExperiment],0.00001];*)
(*xAtDetectorEndMagnetEffect[zLLPdecay_,xprojBeforeMagnet_,px_,py_,pz_,qval_]=If[DipoleMagnetOptionGivenExperiment=="True",If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[(xAtDetectorEndMagnetEffectTemp[zLLPdecay,xprojBeforeMagnet,pxAfterMagnet[zLLPdecay,px,pz,qval],py,pzAfterMagnet[zLLPdecay,px,pz,qval],qval]//Simplify)/. Cot[x_]:>1/Tan[x]/. Csc[x_]:>1/Sin[x]],99999.],999999.];*)
(*yAtDetectorEndMagnetEffect[zLLPdecay_,yprojAfterMagnet_,px_,py_,pz_,qval_]=If[DipoleMagnetOptionGivenExperiment=="True",If[FinalPlaneSign*MomDirection[py,pz]>0,Evaluate[yAtDetectorEndMagnetEffectTemp[zLLPdecay,yprojAfterMagnet,py,pzAfterMagnet[zLLPdecay,px,pz,qval]]/. Cot[x_]:>1/Tan[x]/. Csc[x_]:>1/Sin[x]//Simplify],99999.],999999.];*)


(* ::Subsection:: *)
(*Blocks computing various cuts*)


(* ::Subsubsection:: *)
(*Particular decay product - geometric part*)


(* ::Input:: *)
(*conditionDecayAcceptanceGeometric=Hold@Compile[{{charge1,_Real},{pdg1,_Real},{xdecayfip,_Real},{ydecayfip,_Real},{zfip,_Real},{px1lab,_Real},{py1lab,_Real},{pz1lab,_Real},{E1lab,_Real},{zmagnMzfip,_Real}},*)
(*Module[{cond=0.,FirstCoordinateProduct1,SecondCoordinateProduct1,xAtMagnetStartProduct1=0.,yAfterMagnetProduct1=0.,xFinalPlaneProduct1=0.,yFinalPlaneProduct1=0.,xLongProjVal=0.},*)
(*(*Depending on pdg id, the final plane required to be reached in order to be reconstructed*)*)
(*xLongProjVal=If[Abs[pdg1]==13.,xLongMuonPlaneGivenExperiment,xLongNonMuonPlaneGivenExperiment];*)
(*(*If product is uncharged OR there is no magnet OR the LLP decays after the region with the magnetic field, then the trajectory of the decay product is a straight line and the decay acceptance may be easily computed*)*)
(*If[Bval==0||charge1==0.||zmagnMzfip<0,*)
(*(*Coordinates of the decay products at the detector plane*)*)
(*xFinalPlaneProduct1=DaughterTrajectoryCoord1[xdecayfip,ydecayfip,zfip,xLongProjVal,px1lab,py1lab,pz1lab];*)
(*yFinalPlaneProduct1=DaughterTrajectoryCoord2[xdecayfip,ydecayfip,zfip,xLongProjVal,px1lab,py1lab,pz1lab];*)
(*(*Condition whether product1 intersects the detector*)*)
(*cond=DecayAcceptanceGeometry[xFinalPlaneProduct1,yFinalPlaneProduct1,xLongProjVal],*)
(*(*If the magnetic field and electric charge of the product are non-zero AND the LLP decays before the end of the magnet, then the trajectory is affected by the magnetic field. However, to be affected*)*)
(*(*If the product has large enough energy (== Larmor radius is smaller than the domain with the magnetic field), proceed to the acceptance routine calculation*)*)
(*If[LarmorRadiusGivenExperiment[E1lab]>zmagnMzfip,*)
(*(*x coordinate of the decay products just before the magnet (or at the LLP decay point if it is inside the magnet), and y coordinate at the end of the magnet. Due to the approximation, the mentioned y coordinate is unaffected by the magnet*)*)
(*xAtMagnetStartProduct1=xAtMagnetStart[xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab];*)
(*yAfterMagnetProduct1=yAtMagnetEnd[xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab];*)
(*(*These coordinates must be within the detector coverage. Here it is assumed that the transverse size of the magnet does not change from Subscript[z, magnet,min] to Subscript[z, magnet,max]*)*)
(*cond=DecayAcceptanceGeometry[xAtMagnetStartProduct1,yAfterMagnetProduct1,zMagnetMaxGivenExperiment];*)
(*(*If this is the case, then the routine below evaluates the change of the trajectory due to the magnetic field*)*)
(*If[cond==1,*)
(*(*Coordinates x,y at the final plane. Both of them are affected by magnet*)*)
(*(*The x coordinate gets affected by a kick in x,Subscript[p, x],Subscript[p, z] after the magnet*)*)
(*(*The y coordinate gets affected by a kick in Subscript[p, z] after the magnet*)*)
(*xFinalPlaneProduct1=xAtDetectorEndMagnetEffect[zfip,xAtMagnetStartProduct1,px1lab,py1lab,pz1lab,charge1];*)
(*yFinalPlaneProduct1=yAtDetectorEndMagnetEffect[zfip,yAfterMagnetProduct1,px1lab,py1lab,pz1lab,charge1];*)
(*(*Condition whether decay products intersect the detector and have large enough energy*)*)
(*(*The first condition corresponds to the requirement that x before the magnet and y after the magnet are within the detector*)*)
(*(*The second one requires that kicked x, y at Subscript[z, final ]are within the detector*)*)
(*cond=DecayAcceptanceGeometry[xFinalPlaneProduct1,yFinalPlaneProduct1,xLongProjVal]]*)
(*(*If the product has too low energy (== Larmor radius is smaller than the domain with the magnetic field), it would be trapped inside the magnetic field. In this case, acceptance = 0*)*)
(*,cond=0];*)
(*];*)
(*{cond,xFinalPlaneProduct1,yFinalPlaneProduct1}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{DaughterTrajectoryCoord1,DaughterTrajectoryCoord2,DecayAcceptanceGeometry,xAtDetectorEndMagnetEffect,yAtDetectorEndMagnetEffect,xAtMagnetStart,yAtMagnetEnd,LarmorRadiusGivenExperiment}]/.ruleOwn[{Bval,xLongMuonPlaneGivenExperiment,xLongNonMuonPlaneGivenExperiment,zMagnetMaxGivenExperiment}]//ReleaseHold;*)
(*(*<<CompiledFunctionTools`*)
(*CompilePrint@conditionDecayAcceptanceGeometric*)*)


(* ::Subsubsection::Closed:: *)
(*Decay products pair - Energy cut*)


(* ::Input:: *)
(*distff[\[Sigma]_]=ProbabilityDistribution[1/(Sqrt[2*Pi]\[Sigma]) Exp[-((x)^2/(2\[Sigma]^2))] ,{x,-Infinity,Infinity}];*)
(*InverseCDFffplus[\[Sigma]_,u_]=InverseCDF[distff[\[Sigma]],u][[1]][[2]];*)
(*enres[Eval_]=If[GivenExperiment=="SHiNESS",0.15/Sqrt[10^3 Eval]];*)
(*conditionEnergyCuts=With[{ecutLowerid=ecutLowerID,ecutUpperid=ecutUpperID,EtotCutLowerid=EtotCutLowerID,EtotCutUpperid=EtotCutUpperID},Hold@Compile[{{pdg1,_Real},{charge1,_Real},{pdg2,_Real},{E1lab,_Real},{E2lab,_Real}},Module[{ecutlow1,ecutlow2,ecutup1,ecutup2,ecuttotlow=eTotCutLowerZero,ecuttotupp=eTotCutUpperZero},*)
(*ecutlow1=ecutLowerid[pdg1,charge1];*)
(*ecutlow2=ecutLowerid[pdg2,charge1];*)
(*ecutup1=ecutUpperid[pdg1,charge1];*)
(*ecutup2=ecutUpperid[pdg2,charge1];*)
(*If[IfEtotLowercuts==1,*)
(*ecuttotlow=EtotCutLowerid[pdg1,charge1,pdg2]];*)
(*If[IfEtotUppercuts==1,*)
(*ecuttotupp=EtotCutUpperid[pdg1,charge1,pdg2]];*)
(*Boole[ecutlow1<=E1lab<=ecutup1&&ecutlow2<=E2lab<=ecutup2&&ecuttotlow<=E1lab+E2lab<=ecuttotupp]*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{eTotCutLowerZero,eTotCutUpperZero,IfEtotLowercuts,IfEtotUppercuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@conditionEnergyCuts;*)


(* ::Subsubsection::Closed:: *)
(*Decay products pair - Subscript[p, T] cut*)


(* ::Input:: *)
(*conditionpTcuts=With[{pTcutLowerid=pTcutLowerID,pTcutUpperid=pTcutUpperID},Hold@Compile[{{pdg1,_Real},{charge1,_Real},{pdg2,_Real},{px1lab,_Real},{py1lab,_Real},{px2lab,_Real},{py2lab,_Real}},Module[{pTsquaredCutLow1,pTsquaredCutLow2,pTsquaredCutUpp1,pTsquaredCutUpp2,pT1squaredlab,pT2squaredlab},*)
(*pTsquaredCutLow1=pTcutLowerid[pdg1,charge1]^2;*)
(*pTsquaredCutLow2=pTcutLowerid[pdg2,charge1]^2;*)
(*pTsquaredCutUpp1=pTcutUpperid[pdg1,charge1]^2;*)
(*pTsquaredCutUpp2=pTcutUpperid[pdg2,charge1]^2;*)
(*pT1squaredlab=px1lab^2+py1lab^2;*)
(*pT2squaredlab=px2lab^2+py2lab^2;*)
(*Boole[pTsquaredCutLow1<=pT1squaredlab<=pTsquaredCutUpp1&&pTsquaredCutLow2<=pT2squaredlab<=pTsquaredCutUpp2]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@conditionpTcuts;*)


(* ::Subsubsection::Closed:: *)
(*Decay products pair - Impact parameter cut*)


(* ::Input:: *)
(*conditionIPcuts=With[{IPcutid=IPcutID},Hold@Compile[{{pdg1,_Real},{pdg2,_Real},{xdecayfip,_Real},{ydecayfip,_Real},{zfip,_Real},{px1lab,_Real},{px2lab,_Real},{py1lab,_Real},{py2lab,_Real},{pz1lab,_Real},{pz2lab,_Real}},Module[{cond=1.,ipcut,ip12},*)
(*ipcut=IPcutid[pdg1,pdg2]^2;*)
(*If[ipcut!=IPcutZero^2,*)
(*ip12=IPproductzTargetSquared[xdecayfip,ydecayfip,zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab];*)
(*cond=Boole[ip12<ipcut]];*)
(*cond*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{IPproductzTargetSquared}]/.ruleOwn[{IPcutZero}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@conditionIPcuts;*)


(* ::Subsubsection:: *)
(*Decay products pair - angular cut *)


(* ::Input:: *)
(*angres=If[GivenExperiment=="SHiNESS",10*Pi/180.];*)
(*If[GivenExperiment!="SHiNESS",*)
(*conditionAngSepCuts=With[{AngSepCutid=AngSepCutID},Hold@Compile[{{pdg1,_Real},{pdg2,_Real},{zfip,_Real},{px1lab,_Real},{px2lab,_Real},{py1lab,_Real},{py2lab,_Real},{pz1lab,_Real},{pz2lab,_Real}},Module[{cond=1.,angsepcut,ss12},*)
(*(*Minimal separation in rad*)*)
(*angsepcut=AngSepCutid[pdg1,pdg2];*)
(*If[angsepcut!=AngSepCutZero,*)
(*(*cos(Subscript[\[Theta], between decay products])*)*)
(*ss12=CosAngleProducts[px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab];*)
(*(*Boolean condition*)*)
(*cond=Boole[ss12<Cos[angsepcut]]];*)
(*cond*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{AngSepCutID,CosAngleProducts}]/.ruleOwn[{AngSepCutZero}]//ReleaseHold];*)
(*,*)
(*conditionAngSepCuts=With[{AngSepCutid=AngSepCutID},Hold@Compile[{{pdg1,_Real},{pdg2,_Real},{zfip,_Real},{px1lab,_Real},{px2lab,_Real},{py1lab,_Real},{py2lab,_Real},{pz1lab,_Real},{pz2lab,_Real}},Module[{cond=1.,angsepcut,ss12,u1=0.,u2=0.,z=0.},*)
(*(*Minimal separation in rad*)*)
(*angsepcut=AngSepCutid[pdg1,pdg2];*)
(*If[angsepcut!=AngSepCutZero,*)
(*(*cos(Subscript[\[Theta], between decay products]), including the gaussian smearing from detector's resolution*)*)
(*u1=RandomReal[{0.,1.}];*)
(*u2=RandomReal[{0.,1.}];*)
(*z=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*ss12=ArcCos[Cos[ArcCos[CosAngleProducts[px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab]]+angres*z]];*)
(*(*Boolean condition*)*)
(*cond=Boole[ss12>angsepcut]];*)
(*cond*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{AngSepCutID,CosAngleProducts,InverseCDFffplus}]/.ruleOwn[{AngSepCutZero,angres}]//ReleaseHold];*)
(*]*)
(*<<CompiledFunctionTools`;*)
(*CompilePrint@conditionAngSepCuts;*)


(* ::Subsubsection:: *)
(*Decay products pair - spatial separation cut *)


(* ::Input:: *)
(*conditionSScutsOld=With[{SScutid=SScutID},Hold@Compile[{{pdg1,_Real},{pdg2,_Real},{zfip,_Real},{px1lab,_Real},{px2lab,_Real},{py1lab,_Real},{py2lab,_Real},{pz1lab,_Real},{pz2lab,_Real}},Module[{cond=1.,sscut,sssquared=0.,coordprojval=0.},*)
(*(*Minimal separation in rad*)*)
(*sscut=SScutID[pdg1,pdg2];*)
(*If[sscut!=SScutZero,*)
(*coordprojval=If[pdg1==22.||pdg1==130.,ECALpositionGivenExperiment,zMaxDecayVolumeGivenExperiment];*)
(*sssquared=SSproductsSquaredOld[zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab,coordprojval];*)
(*(*Boolean condition*)*)
(*cond=Boole[sssquared>sscut^2]];*)
(*cond*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True,CompilationOptions->{"InlineExternalDefinitions"->True,"InlineCompiledFunctions"->True}]/.ruleDown[{SScutID,SSproductsSquaredOld}]/.ruleOwn[{SScutZero,ECALpositionGivenExperiment,zMaxDecayVolumeGivenExperiment}]//ReleaseHold];*)
(*<<CompiledFunctionTools`;*)
(*CompilePrint@conditionSScutsOld;*)
(*conditionSScuts=With[{SScutid=SScutID},Hold@Compile[{{pdg1,_Real},{pdg2,_Real},{xfin1,_Real},{yfin1,_Real},{xfin2,_Real},{yfin2,_Real}},Module[{cond=1.,sscut,sssquared=0.,coordprojval=0.},*)
(*(*Minimal separation in rad*)*)
(*sscut=SScutID[pdg1,pdg2];*)
(*If[sscut!=SScutZero,*)
(*sssquared=SSproductsSquared[xfin1,xfin2,yfin1,yfin2];*)
(*(*Boolean condition*)*)
(*cond=Boole[sssquared>sscut^2]];*)
(*cond*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True,CompilationOptions->{"InlineExternalDefinitions"->True,"InlineCompiledFunctions"->True}]/.ruleDown[{SScutID,SSproductsSquared}]/.ruleOwn[{SScutZero}]//ReleaseHold];*)
(*<<CompiledFunctionTools`;*)
(*CompilePrint@conditionSScuts;*)


(* ::Subsubsection:: *)
(*Decay products pair - Invariant mass cut*)


(* ::Input:: *)
(*conditionminvCuts=With[{minvCutLowerid=minvCutLowerID,minvCutUpperid=minvCutUpperID},Hold@Compile[{{pdg1,_Real},{charge1,_Real},{pdg2,_Real},{px1lab,_Real},{py1lab,_Real},{pz1lab,_Real},{E1lab,_Real},{px2lab,_Real},{py2lab,_Real},{pz2lab,_Real},{E2lab,_Real}},Module[{cond=1.,minv2cutlow=minvCutLowerZero^2,minv2cutupp=minvCutUpperZero^2,minv2val},*)
(*(*Minimal spatial separation cut for the decay products*)*)
(*If[IfminvLowerCuts==1,minv2cutlow=minvCutLowerid[pdg1,charge1,pdg2]^2];*)
(*If[IfminvUpperCuts==1,minv2cutupp=minvCutUpperid[pdg1,charge1,pdg2]^2];*)
(*If[(minv2cutlow!=minvCutLowerZero^2||minv2cutupp!=minvCutUpperZero^2),*)
(*minv2val=minvProductsSquared[px1lab,py1lab,pz1lab,E1lab,px2lab,py2lab,pz2lab,E2lab];*)
(*cond=Boole[minv2cutlow<=minv2val<=minv2cutupp]];*)
(*cond*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{minvProductsSquared}]/.ruleOwn[{minvCutLowerZero,minvCutUpperZero,IfminvLowerCuts,IfminvUpperCuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@conditionminvCuts;*)


(* ::Subsection:: *)
(*Full routine calculating the decay products acceptance*)


(* ::Subsubsection:: *)
(*At least two particles pass the acceptance criteria*)


(* ::Input:: *)
(*DecayAcceptanceComp=With[{CondGeom=conditionDecayAcceptanceGeometric,CondMinv=conditionminvCuts,CondAS=conditionAngSepCuts,CondSS=conditionSScuts,CondIP=conditionIPcuts,CondPT=conditionpTcuts,CondE=conditionEnergyCuts},Hold@Compile[{{TableLLPgridWithELLP,_Real,1},{TablePhaseSpaceDecayProducts,_Real,2},{mLLP,_Real},{eventslengths,_Integer,2}},*)
(*Module[{cond,count,FirstCoordinateProduct1,SecondCoordinateProduct1,FirstCoordinateProduct2,SecondCoordinateProduct2,efip,zfip,\[Theta]fip,\[Phi]fip,px1rest=0.,py1rest=0.,pz1rest=0.,E1rest=0.,px2rest=0.,py2rest=0.,pz2rest=0.,E2rest=0.,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab,xdecayfip,ydecayfip,pdg1,pdg2,E1lab=0.,E2lab=0.,charge1,charge2,len=Length[eventslengths],nproducts=0,f1max=0,zmagnMzfip,in1=0,in2=0,min=0,pxfip,pyfip,pzfip,pfip,Coord1FinProd1=0.,Coord2FinProd1=0.,Coord1FinProd2=0.,Coord2FinProd2=0.,\[Epsilon]azfip=0.},*)
(*count= 0.;*)
(*(*Values of the LLP Subscript[\[Epsilon], az], E, \[Theta], \[Phi], Subscript[x, long]*)*)
(*efip=Compile`GetElement[TableLLPgridWithELLP,indexELLP];*)
(*zfip=Compile`GetElement[TableLLPgridWithELLP,indexzLLP];*)
(*\[Theta]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Theta]LLP];*)
(*\[Phi]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Phi]LLP];*)
(*\[Epsilon]azfip=Compile`GetElement[TableLLPgridWithELLP,indexLLPazAcc];*)
(*If[\[Epsilon]azfip!=0.,*)
(*pfip=Sqrt[efip^2-mLLP^2];*)
(*pxfip=pfip*Cos[\[Phi]fip]*Sin[\[Theta]fip];*)
(*pyfip=pxfip*Sin[\[Phi]fip]/Cos[\[Phi]fip];*)
(*pzfip=pfip*Cos[\[Theta]fip];*)
(*(*Distance between the end of the dipole magnet and the LLP decay point*)*)
(*zmagnMzfip=If[zfip<zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zfip];*)
(*xdecayfip=LLPdecayVertexX[zfip,\[Theta]fip,\[Phi]fip];*)
(*ydecayfip=LLPdecayVertexY[zfip,\[Theta]fip,\[Phi]fip];*)
(*(*Looping over simulated decays*)*)
(*Do[*)
(*cond=0.;*)
(*min=Compile`GetElement[eventslengths,j,1];*)
(*nproducts=Compile`GetElement[eventslengths,j,2];*)
(*f1max=nproducts-2;*)
(*(*Looping over product1*)*)
(*Do[*)
(*in1=min+f1;*)
(*(*Electric charge of the decay product*)*)
(*charge1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexcharge1];*)
(*(*Calculating the geometric part of the decay acceptance for the first decay product*)*)
(*pdg1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpdg1];*)
(*(*4-momentum of the decay product at LLP's rest frame*)*)
(*px1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpx1];*)
(*py1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpy1];*)
(*pz1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpz1];*)
(*E1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexE1];*)
(*(*4-momentum of the decay product at the LLP's lab frame*)*)
(*px1lab=pproductLab1Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*py1lab=pproductLab2Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*pz1lab=pproductLab3Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*E1lab=EproductLabCart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*{cond,Coord1FinProd1,Coord2FinProd1}=CondGeom[charge1,pdg1,xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab,E1lab,zmagnMzfip];*)
(*(*If geometric part of the decay acceptance for product1 is non-zero then proceeding to product2. If not, then go to the other product1*)*)
(*If[cond==1,*)
(*Do[*)
(*in2=in1+f2;*)
(*charge2=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexcharge1];*)
(*(*If the total electric charge of the pair is not zero, then the acceptance is automatically 0. If zero, the the routine below is launched*)*)
(*If[charge1!=-charge2, cond=0,*)
(*px2rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexpx1];*)
(*py2rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexpy1];*)
(*pz2rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexpz1];*)
(*E2rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexE1];*)
(*px2lab=pproductLab1Cart[pxfip,pyfip,pzfip,efip,mLLP,px2rest,py2rest,pz2rest,E2rest];*)
(*py2lab=pproductLab2Cart[pxfip,pyfip,pzfip,efip,mLLP,px2rest,py2rest,pz2rest,E2rest];*)
(*pz2lab=pproductLab3Cart[pxfip,pyfip,pzfip,efip,mLLP,px2rest,py2rest,pz2rest,E2rest];*)
(*E2lab=EproductLabCart[pxfip,pyfip,pzfip,efip,mLLP,px2rest,py2rest,pz2rest,E2rest];*)
(*(*If[Abs[px1rest+px2rest]>10^-5.,cond=0.;Break[];];*)*)
(*(*Calculating the geometric part of the decay acceptance for the second decay product*)*)
(*pdg2=Compile`GetElement[TablePhaseSpaceDecayProducts,in2,indexpdg1];*)
(*{cond,Coord1FinProd2,Coord2FinProd2}=CondGeom[charge2,pdg2,xdecayfip,ydecayfip,zfip,px2lab,py2lab,pz2lab,E2lab,zmagnMzfip];*)
(*(*If other cuts are required and the geometric condition for product2 is 1 then evaluate the acceptance for these cuts*)*)
(*If[cond==1.&&WhetherCuts==1,*)
(*(*PDG identifiers of the decay products*)*)
(*(*Values of the energy cuts for the decay products*)*)
(*If[IfEcuts==1&&cond==1.,cond=CondE[pdg1,charge1,pdg2,E1lab,E2lab]];*)
(*(*The Subscript[p, T] cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfpTcuts==1&&cond==1.,cond=CondPT[pdg1,charge1,pdg2,px1lab,py1lab,px2lab,py2lab]];*)
(*(*The IP cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfIPcuts==1&&cond==1.,cond=CondIP[pdg1,pdg2,xdecayfip,ydecayfip,zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab]];*)
(*(*The spatial separation cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfAngSepCuts==1&&cond==1.,cond=CondAS[pdg1,pdg2,zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab]];*)
(*(*The spatial separation cut*)*)
(*If[IfSScuts==1&&cond==1.,cond=CondSS[pdg1,pdg2,Coord1FinProd1,Coord2FinProd1,Coord1FinProd2,Coord2FinProd2]];*)
(*(*The invariant mass cut*)*)
(*If[IfminvCuts==1&&cond==1.,cond=CondMinv[pdg1,charge1,pdg2,px1lab,py1lab,pz1lab,E1lab,px2lab,py2lab,pz2lab,E2lab]];*)
(*];*)
(*];*)
(*(*If the acceptance after all cuts is 1, then add it to the counter and break the cycle*)*)
(*If[cond==1.,count+=cond;Break[]],{f2,1,nproducts-f1-1,1}]*)
(*];*)
(*(*If the acceptance is 1 then exit the cycle*)*)
(*If[cond==1.,Break[]],{f1,0,f1max,1}]*)
(*,{j,1,len}];*)
(*,*)
(*count=0.*)
(*];*)
(*(*Returns the decay acceptance*)*)
(*{count/len}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},CompilationOptions->{"InlineCompiledFunctions"->True},Parallelization->True]/.ruleDown[{LLPdecayVertexX,LLPdecayVertexY,pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpdg1,indexELLP,indexzLLP,index\[Theta]LLP,index\[Phi]LLP,indexLLPazAcc,indexpx1,indexpy1,indexpz1,indexE1,LengthDataProduct,WhetherCuts,indexcharge1,zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment,IfEcuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts,IfSScuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@DecayAcceptanceComp;*)


(* ::Subsubsection:: *)
(*At least n decay products pass the acceptance criteria*)


(* ::Input:: *)
(*DecayAcceptancenProductsComp=With[{CondGeom=conditionDecayAcceptanceGeometric,CondMinv=conditionminvCuts,CondSS=conditionAngSepCuts,CondIP=conditionIPcuts,CondPT=conditionpTcuts,CondE=conditionEnergyCuts},Hold@Compile[{{TableLLPgridWithELLP,_Real,1},{TablePhaseSpaceDecayProducts,_Real,2},{mLLP,_Real},{eventslengths,_Integer,2},{tracksmin,_Integer}},*)
(*Module[{cond=0.,count,efip,zfip,\[Theta]fip,\[Phi]fip,px1rest,py1rest,pz1rest,E1rest,px1lab,px2lab=0.,py1lab,py2lab=0.,pz1lab,pz2lab=0.,xdecayfip,ydecayfip,condprod1,condprod2,pdg1,pdg2=0.,E1lab,E2lab=0.,acc,acc2,charge1,charge2,len=Length[eventslengths],nproducts=0,f1max=0,zmagnMzfip,conde=0.,pfip,pxfip,pyfip,pzfip,in1=0,min=0,trackcounter=0,Coord1FinProd=0.,Coord2FinProd=0.,\[Epsilon]azfip=0.},*)
(*count= 0.;*)
(*(*Values of the LLP Subscript[\[Epsilon], az], E, \[Theta], \[Phi], Subscript[x, long]*)*)
(*efip=Compile`GetElement[TableLLPgridWithELLP,indexELLP];*)
(*zfip=Compile`GetElement[TableLLPgridWithELLP,indexzLLP];*)
(*\[Theta]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Theta]LLP];*)
(*\[Phi]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Phi]LLP];*)
(*\[Epsilon]azfip=Compile`GetElement[TableLLPgridWithELLP,indexLLPazAcc];*)
(*If[\[Epsilon]azfip!=0.,*)
(*pfip=Sqrt[efip^2-mLLP^2];*)
(*pxfip=pfip*Cos[\[Phi]fip]*Sin[\[Theta]fip];*)
(*pyfip=pxfip*Sin[\[Phi]fip]/Cos[\[Phi]fip];*)
(*pzfip=pfip*Cos[\[Theta]fip];*)
(*(*Distance between the end of the dipole magnet and the LLP decay point*)*)
(*zmagnMzfip=If[zfip<zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zfip];*)
(*xdecayfip=LLPdecayVertexX[zfip,\[Theta]fip,\[Phi]fip];*)
(*ydecayfip=LLPdecayVertexY[zfip,\[Theta]fip,\[Phi]fip];*)
(*(*Looping over simulated decays*)*)
(*Do[*)
(*trackcounter=0;*)
(*cond=conde=1.;*)
(*min=Compile`GetElement[eventslengths,j,1];*)
(*nproducts=Compile`GetElement[eventslengths,j,2];*)
(*f1max=nproducts-1;*)
(*(*Looping over product1*)*)
(*Do[*)
(*in1=min+f1;*)
(*(*Electric charge of the decay product*)*)
(*charge1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexcharge1];*)
(*(*Calculating the geometric part of the decay acceptance for the first decay product*)*)
(*pdg1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpdg1];*)
(*(*4-momentum of the decay product at LLP's rest frame*)*)
(*px1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpx1];*)
(*py1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpy1];*)
(*pz1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpz1];*)
(*E1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexE1];*)
(*(*Energy of the decay product at the LLP's lab frame*)*)
(*E1lab=EproductLabCart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*If[IfEcuts==1,conde=CondE[pdg1,charge1,pdg2,E1lab,E2lab]];*)
(*(*Calculating the geometric part of the decay acceptance for the decay product if the energy is sufficiently large*)*)
(*If[conde==1,*)
(*(*3-momentum of the decay product at the LLP's lab frame*)*)
(*px1lab=pproductLab1Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*py1lab=pproductLab2Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*pz1lab=pproductLab3Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*{cond,Coord1FinProd,Coord2FinProd}=CondGeom[charge1,pdg1,xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab,E1lab,zmagnMzfip];*)
(*(*If other cuts are required and the geometric condition for product2 is 1 then evaluate the acceptance for these cuts*)*)
(*If[cond==1.&&WhetherCuts==1,*)
(*(*PDG identifiers of the decay products*)*)
(*(*The Subscript[p, T] cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfpTcuts==1&&cond==1,cond=CondPT[pdg1,charge1,pdg2,px1lab,py1lab,px2lab,py2lab]];*)
(*];*)
(*(*If condition is 1, then increase the detected track counter*)*)
(*If[cond==1.,trackcounter+=1];*)
(*If[trackcounter>=tracksmin,Break[]];*)
(*];*)
(*,{f1,0,f1max,1}];*)
(*If[trackcounter>=tracksmin,count+=cond];*)
(*,{j,1,len}];*)
(*,*)
(*count=0.*)
(*];*)
(*(*Returns the decay acceptance*)*)
(*{count/len}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},CompilationOptions->{"InlineCompiledFunctions"->True},Parallelization->True]/.ruleDown[{LLPdecayVertexX,LLPdecayVertexY,pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpdg1,indexELLP,indexzLLP,index\[Theta]LLP,index\[Phi]LLP,indexLLPazAcc,indexpx1,indexpy1,indexpz1,indexE1,LengthDataProduct,WhetherCuts,indexcharge1,zMagnetMaxGivenExperiment,zMagnetMinGivenExperiment,IfEcuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@DecayAcceptanceAllProductsComp;*)


(* ::Subsubsection:: *)
(*All the target decay products pass the acceptance criteria*)


(* ::Input:: *)
(*DecayAcceptanceAllProductsComp=With[{CondGeom=conditionDecayAcceptanceGeometric,CondMinv=conditionminvCuts,CondSS=conditionAngSepCuts,CondIP=conditionIPcuts,CondPT=conditionpTcuts,CondE=conditionEnergyCuts},Hold@Compile[{{TableLLPgridWithELLP,_Real,1},{TablePhaseSpaceDecayProducts,_Real,2},{mLLP,_Real},{eventslengths,_Integer,2}},*)
(*Module[{cond=0.,count,efip,zfip,\[Theta]fip,\[Phi]fip,px1rest,py1rest,pz1rest,E1rest,px1lab,px2lab=0.,py1lab,py2lab=0.,pz1lab,pz2lab=0.,xdecayfip,ydecayfip,condprod1,condprod2,pdg1,pdg2=0.,E1lab,E2lab=0.,acc,acc2,charge1,charge2,len=Length[eventslengths],nproducts=0,f1max=0,zmagnMzfip,conde=0,pfip,pxfip,pyfip,pzfip,in1=0,min=0,trackcounter=0,Coord1FinProd=0.,Coord2FinProd=0.,\[Epsilon]azfip=0.},*)
(*count= 0.;*)
(*(*Values of the LLP Subscript[\[Epsilon], az], E, \[Theta], \[Phi], Subscript[x, long]*)*)
(*efip=Compile`GetElement[TableLLPgridWithELLP,indexELLP];*)
(*zfip=Compile`GetElement[TableLLPgridWithELLP,indexzLLP];*)
(*\[Theta]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Theta]LLP];*)
(*\[Phi]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Phi]LLP];*)
(*\[Epsilon]azfip=Compile`GetElement[TableLLPgridWithELLP,indexLLPazAcc];*)
(*If[\[Epsilon]azfip!=0.,*)
(*pfip=Sqrt[efip^2-mLLP^2];*)
(*pxfip=pfip*Cos[\[Phi]fip]*Sin[\[Theta]fip];*)
(*pyfip=pxfip*Sin[\[Phi]fip]/Cos[\[Phi]fip];*)
(*pzfip=pfip*Cos[\[Theta]fip];*)
(*(*Distance between the end of the dipole magnet and the LLP decay point*)*)
(*zmagnMzfip=If[zfip<zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zMagnetMinGivenExperiment,zMagnetMaxGivenExperiment-zfip];*)
(*xdecayfip=LLPdecayVertexX[zfip,\[Theta]fip,\[Phi]fip];*)
(*ydecayfip=LLPdecayVertexY[zfip,\[Theta]fip,\[Phi]fip];*)
(*(*Looping over simulated decays*)*)
(*Do[*)
(*trackcounter=0;*)
(*cond=1.;*)
(*min=Compile`GetElement[eventslengths,j,1];*)
(*nproducts=Compile`GetElement[eventslengths,j,2];*)
(*f1max=nproducts-1;*)
(*(*Looping over product1*)*)
(*Do[*)
(*in1=min+f1;*)
(*(*Electric charge of the decay product*)*)
(*charge1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexcharge1];*)
(*(*Calculating the geometric part of the decay acceptance for the first decay product*)*)
(*pdg1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpdg1];*)
(*(*4-momentum of the decay product at LLP's rest frame*)*)
(*px1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpx1];*)
(*py1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpy1];*)
(*pz1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpz1];*)
(*E1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexE1];*)
(*(*Energy of the decay product at the LLP's lab frame*)*)
(*E1lab=EproductLabCart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*If[IfEcuts==1,conde=CondE[pdg1,charge1,pdg2,E1lab,E2lab]];*)
(*(*Calculating the geometric part of the decay acceptance for the decay product if the energy is sufficiently large*)*)
(*If[conde==1,*)
(*(*3-momentum of the decay product at the LLP's lab frame*)*)
(*px1lab=pproductLab1Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*py1lab=pproductLab2Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*pz1lab=pproductLab3Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*{cond,Coord1FinProd,Coord2FinProd}=CondGeom[charge1,pdg1,xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab,E1lab,zmagnMzfip];*)
(*(*If other cuts are required and the geometric condition for product2 is 1 then evaluate the acceptance for these cuts*)*)
(*If[cond==1.&&WhetherCuts==1,*)
(*(*PDG identifiers of the decay products*)*)
(*(*The Subscript[p, T] cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfpTcuts==1&&cond==1,cond=CondPT[pdg1,charge1,pdg2,px1lab,py1lab,px2lab,py2lab]];*)
(*];*)
(*(*If the track has sufficiently large energy but did not reach the detector, then break. Otherwise, continue the iterations*)*)
(*If[cond==0&&conde==1,Break[]];*)
(*];*)
(*,{f1,0,f1max,1}];*)
(*count+=cond;*)
(*,{j,1,len}];*)
(*,*)
(*count=0.*)
(*];*)
(*(*Returns the decay acceptance*)*)
(*{count/len}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},CompilationOptions->{"InlineCompiledFunctions"->True},Parallelization->True]/.ruleDown[{LLPdecayVertexX,LLPdecayVertexY,pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpdg1,indexELLP,indexzLLP,index\[Theta]LLP,index\[Phi]LLP,indexLLPazAcc,indexpx1,indexpy1,indexpz1,indexE1,LengthDataProduct,WhetherCuts,indexcharge1,zMagnetMaxGivenExperiment,zMagnetMinGivenExperiment,IfEcuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@DecayAcceptanceAllProductsComp;*)


(* ::Subsubsection:: *)
(*One or two photons (and no other particles) pass the acceptance criteria (routine for photons search at CHARM)*)


(* ::Input:: *)
(*DecayAcceptanceCHARM\[Gamma]Comp=With[{CondGeom=conditionDecayAcceptanceGeometric,CondMinv=conditionminvCuts,CondSS=conditionAngSepCuts,CondIP=conditionIPcuts,CondPT=conditionpTcuts,CondE=conditionEnergyCuts},Hold@Compile[{{TableLLPgridWithELLP,_Real,1},{TablePhaseSpaceDecayProducts,_Real,2},{mLLP,_Real},{eventslengths,_Integer,2}},*)
(*Module[{cond,count,efip,zfip,\[Theta]fip,\[Phi]fip,px1rest,py1rest,pz1rest,E1rest,px2rest,py2rest,pz2rest,E2rest,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab,\[Epsilon]Azfip,xdecayfip,ydecayfip,pdg1,E1lab,charge1,len=0,nproducts=0,f1max=0,zmagnMzfip,condGood=0.,condBad=0.,condg1=0.,e1,e2,pfip,pxfip,pyfip,pzfip,min=0,in1=0,Coord1FinProd=0.,Coord2FinProd=0.,\[Epsilon]azfip=0.},*)
(*count= 0.;*)
(*(*Values of the LLP Subscript[\[Epsilon], az], E, \[Theta], \[Phi], Subscript[x, long]*)*)
(*efip=Compile`GetElement[TableLLPgridWithELLP,indexELLP];*)
(*zfip=Compile`GetElement[TableLLPgridWithELLP,indexzLLP];*)
(*\[Theta]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Theta]LLP];*)
(*\[Phi]fip=Compile`GetElement[TableLLPgridWithELLP,index\[Phi]LLP];*)
(*\[Epsilon]azfip=Compile`GetElement[TableLLPgridWithELLP,indexLLPazAcc];*)
(*If[\[Epsilon]azfip!=0.,*)
(*pfip=Sqrt[efip^2-mLLP^2];*)
(*pxfip=pfip*Cos[\[Phi]fip]*Sin[\[Theta]fip];*)
(*pyfip=pxfip*Sin[\[Phi]fip]/Cos[\[Phi]fip];*)
(*pzfip=pfip*Cos[\[Theta]fip];*)
(*(*Distance between the end of the dipole magnet and the LLP decay point*)*)
(*zmagnMzfip=zMagnetMaxGivenExperiment-zfip;*)
(*len=Length[TablePhaseSpaceDecayProducts];*)
(*nproducts=IntegerPart[Length[TablePhaseSpaceDecayProducts[[1]]]/LengthDataProduct];*)
(*f1max=IntegerPart[nproducts-1];*)
(*xdecayfip=LLPdecayVertexX[zfip,\[Theta]fip,\[Phi]fip];*)
(*ydecayfip=LLPdecayVertexY[zfip,\[Theta]fip,\[Phi]fip];*)
(*(*Looping over simulated decays*)*)
(*Do[*)
(*cond=1.;*)
(*min=Compile`GetElement[eventslengths,j,1];*)
(*nproducts=Compile`GetElement[eventslengths,j,2];*)
(*f1max=nproducts-1;*)
(*cond=0.;*)
(*condGood=0.;*)
(*condBad=0.;*)
(*e1=0.;*)
(*e2=0.;*)
(*(*Looping over product1*)*)
(*Do[*)
(*in1=min+f1;*)
(*(*Electric charge of the decay product*)*)
(*charge1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexcharge1];*)
(*(*Calculating the geometric part of the decay acceptance for the first decay product*)*)
(*pdg1=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpdg1];*)
(*(*4-momentum of the decay product at LLP's rest frame*)*)
(*px1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpx1];*)
(*py1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpy1];*)
(*pz1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexpz1];*)
(*E1rest=Compile`GetElement[TablePhaseSpaceDecayProducts,in1,indexE1];*)
(*(*4-momentum of the decay product at the LLP's lab frame*)*)
(*px1lab=pproductLab1Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*py1lab=pproductLab2Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*pz1lab=pproductLab3Cart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*E1lab=EproductLabCart[pxfip,pyfip,pzfip,efip,mLLP,px1rest,py1rest,pz1rest,E1rest];*)
(*(*Calculating the geometric part of the decay acceptance for the first decay product*)*)
(*{condg1,Coord1FinProd,Coord2FinProd}=CondGeom[charge1,pdg1,xdecayfip,ydecayfip,zfip,px1lab,py1lab,pz1lab,E1lab,zmagnMzfip];*)
(*If[pdg1==22.,condGood+=condg1,condBad+=condg1];*)
(*If[condBad>0.||condGood>2,cond=0.;Break[]];*)
(*If[condg1==1,If[condGood==1,e1=E1lab,If[condGood==2,e2=E1lab]]];*)
(*(*If other cuts are required and the geometric condition for product2 is 1 then evaluate the acceptance for these cuts*)*)
(*,{f1,0,f1max,1}];*)
(*If[condGood>0.&&WhetherCuts==1&&condBad==0.,*)
(*(*Values of the energy cuts for the decay products*)*)
(*If[IfEcuts==1,count+=CondE[22.,0.,22.,e1,e2]];*)
(*(*(*The Subscript[p, T] cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfpTcuts==1&&cond\[Equal]1,cond=CondPT[pdg1,pdg2,px1lab,py1lab,px2lab,py2lab]];*)
(*(*The IP cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfIPcuts==1&&cond\[Equal]1,cond=CondIP[pdg1,pdg2,xdecayfip,ydecayfip,zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab]];*)
(*(*The spatial separation cut. If it is present then evaluate the acceptance. If not then proceeding to the next cut*)*)
(*If[IfAngSepCuts==1&&cond\[Equal]1,cond=CondSS[pdg1,pdg2,zfip,px1lab,px2lab,py1lab,py2lab,pz1lab,pz2lab]];*)
(*(*The invariant mass cut*)*)
(*If[IfminvCuts==1&&cond\[Equal]1,cond=CondMinv[pdg1,pdg2,px1lab,py1lab,pz1lab,E1lab,px2lab,py2lab,pz2lab,E2lab]];*)*)
(*];*)
(*,{j,1,len}];*)
(*(*Returns the number of simulated acceptances divided by the number of simulated events. For the decays where more than one combination of decay products pair exists, this value may be > 1. It will be replaced with \[Equal] 1 in the next step*)*)
(*,*)
(*count=0.;*)
(*];*)
(*{count/len}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},CompilationOptions->{"InlineCompiledFunctions"->True},Parallelization->True]/.ruleDown[{LLPdecayVertexX,LLPdecayVertexY,pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpdg1,indexELLP,indexzLLP,index\[Theta]LLP,index\[Phi]LLP,indexLLPazAcc,indexpx1,indexpy1,indexpz1,indexE1,LengthDataProduct,WhetherCuts,indexcharge1,zMagnetMaxGivenExperiment,IfEcuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts}]//ReleaseHold];*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@DecayAcceptanceCHARM\[Gamma]Comp;*)


(* ::Subsection:: *)
(*Block computing the acceptance for the specific LLP and its decay channel*)


(* ::Input:: *)
(*PhaseSpacePerDecayChannel[LLP_,mLLP_,SpecificDecay_,isim_,HadronizationOption_]:=If[HadronizationOption=="True"&&JetsPresence[LLP,SpecificDecay]=="Yes",Take[RandomSample[PhaseSpaceDecaysRestJets[LLP,SpecificDecay,mLLP]],{1,isim}],PhaseSpaceDecaysRest[LLP,mLLP,SpecificDecay,isim]];*)
(*detectableproducts=Hold@Compile[{{pdglists,_Real,2}},Table[Select[pdglists[[i]],MemberQ[DetectablePDGsGivenExperiment,#]&]//Length,{i,1,Length[pdglists],1}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.OwnValues@DetectablePDGsGivenExperiment//ReleaseHold*)
(*CompilePrint@detectableproducts;*)
(*(*This block generates the phase space per LLP decay by averaging over various decay channels*)*)
(*PhaseSpacePerDecay[LLP_,mLLP_,proclist_,isimlist_,HadronizationOption_]:=Block[{},*)
(*pss0=Developer`ToPackedArray@PadRight[Join[##]&@@Table[PhaseSpacePerDecayChannel[LLP,mLLP,proclist[[i]],isimlist[[i]],HadronizationOption],{i,1,Length[proclist],1}],Automatic,-999.];*)
(*(*List of decay products pdg IDs per decay*)*)
(*pdglists=pss0[[All,-LengthDataProduct+indexpdg1+LengthDataProduct*Range[1,Length[pss0[[1]]]/8]]];*)
(*(*The amount of particles that may be detected per given experiment*)*)
(*numdetectableproducts=detectableproducts[pdglists];*)
(*(*pss=Map[Flatten[SortBy[Partition[#,LengthDataProduct],-#[[indexE1]]&]]&,pss];*)*)
(*(*The phase space sorted in descending order by the number of detectable products*)*)
(*pss=pss0[[Ordering[numdetectableproducts,All,Greater]]];*)
(*pss*)
(*]*)
(*(*This block takes the phase space generated by the previous block and converts it in the form or rows decay product data,decay product data. To distinguish various decays, eventlengths is used*)*)
(*PhaseSpacePerDecayReshaped[LLP_,mLLP_,proclist_,isimlist_,HadronizationOption_]:=Block[{},*)
(*ps=PhaseSpacePerDecay[LLP,mLLP,proclist,isimlist,HadronizationOption];*)
(*ps1=ArrayReshape[Flatten[ps],{Length[ps] Length[ps[[1]]]/LengthDataProduct,LengthDataProduct}]//Developer`ToPackedArray;*)
(*ps1=Select[ps1,MemberQ[DetectablePDGsGivenExperiment,#[[indexpdg1]]]==True&]//Developer`ToPackedArray;*)
(*(*eventlengths=nprodscomp[ps];*)
(*eventlengths={Drop[Accumulate[Prepend[eventlengths,0]]+1,-1],eventlengths}//Transpose;*)*)
(*eventlengths=SortBy[numdetectableproducts,-#&];*)
(*eventlengths={Drop[Accumulate[Prepend[eventlengths,0]]+1,-1],eventlengths}//Transpose;*)
(*(*eventlengths={Range[1,isimlist//Total],SortBy[numdetectableproducts,-#&]}//Transpose;*)*)
(*{ps1,eventlengths}*)
(*]*)
(*(*Block computing decay acceptance*)*)
(*DecayAcceptanceELLP\[Theta]LLPzLLPoverall[LLP_,mLLP_,proclist_,isimlist_,gridNonZero_,HadronizationOption_,AllProductsWithinAcceptance_,ntracksmin_]:=Module[{(*PhaseSpaceGiven,*)},*)
(*(*Phase space of LLP decays at rest - up to stable decay products: charged pions, charged kaons, Subscript[K, L], and photons*)*)
(*{PhaseSpaceGiven,eventslengths}=PhaseSpacePerDecayReshaped[LLP,mLLP,proclist,isimlist,HadronizationOption];*)
(*(*Averaging over distinct decay products set for the given phase space*)*)
(*(*Computing the decay products acceptance: at this step, no averaging over \[Phi]*)*)
(*ifcharm=MemberQ[{"CHARM-photon"},GivenExperiment];*)
(*isimvv=isimlist//Total;*)
(*If[ifcharm==True,\[Epsilon]Decay\[Phi]Unaveraged=DecayAcceptanceCHARM\[Gamma]Comp[gridNonZero,PhaseSpaceGiven,mLLP,eventslengths]];*)
(*If[AllProductsWithinAcceptance==">=2"&&ifcharm==False,\[Epsilon]Decay\[Phi]Unaveraged=DecayAcceptanceComp[gridNonZero,PhaseSpaceGiven,mLLP,eventslengths]];*)
(*If[AllProductsWithinAcceptance==">=n"&&ifcharm==False,\[Epsilon]Decay\[Phi]Unaveraged=DecayAcceptancenProductsComp[gridNonZero,PhaseSpaceGiven,mLLP,eventslengths,ntracksmin]];*)
(*If[AllProductsWithinAcceptance=="All detectable"&&ifcharm==False,\[Epsilon]Decay\[Phi]Unaveraged=DecayAcceptanceAllProductsComp[gridNonZero,PhaseSpaceGiven,mLLP,eventslengths]];*)
(*(*And then averaging over \[Phi]*)*)
(*\[Epsilon]av=If[\[Epsilon]Decay\[Phi]Unaveraged!={},\[Epsilon]DecayE\[Theta]zcompiled[\[Epsilon]Decay\[Phi]Unaveraged,NofPhiVals],{}]*)
(*]*)


(* ::Subsection:: *)
(*If the LLP, its mass, and the grid Subscript[E, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP] are fixed (uses the routine for the fixed phase space of decay products from the previous section)*)


(* ::Input:: *)
(*(*Block that takes the table {Subscript[E, LLP],Subscript[z, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP],Subscript[\[Epsilon], az,LLP],Subscript[\[Phi], LLP]} and computes {Subscript[E, LLP],Subscript[z, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP],Subscript[\[Epsilon], az,LLP],\!\(\(<\)*)
(*\*SubscriptBox[\(\[Epsilon]\), \(decay, LLP\)]*)
(*\*SubscriptBox[\(>\), *)
(*SubscriptBox[\(\[Phi]\), \(LLP\)]]\)} for the given LLP and mass. It averages over dominant LLP's decays.*)*)
(*DecayAcceptanceBlock[LLP_,mLLP_,proclist_,grid_,gridreduced_,isim_,HadronizationOption_,AllProductsWithinAcceptance_,ntracksmin_]:=Block[{},*)
(*(*List of processes for the given LLP*)*)
(*ProcessesListGivenComputation=proclist;*)
(*(*Br ratios associated with the given processes*)*)
(*ListBrRatiosGivenComputation=ListBrRatios[LLP,mLLP,#]&/@ProcessesListGivenComputation;*)
(*If[Total[ListBrRatiosGivenComputation]!=0,*)
(*(*Number of decays simulated for each particular channel, joined with the channel identifiers*)*)
(*isimulvalPerDecayChannelTemp=Join[Partition[NeventsSplitted[isim,ListBrRatiosGivenComputation],1],Partition[ProcessesListGivenComputation,1],2];*)
(*(*Selecting only those channels for which the number of simulated decays is > 10^-2Subscript[N, ev]*)*)
(*isimulvalPerDecayChannel=Select[isimulvalPerDecayChannelTemp,#[[1]]>IntegerPart[0.01*isim]&];*)
(*(*Removing rows for which Subscript[E, LLP] < Subscript[m, LLP] or Subscript[\[Epsilon], azimuthal] = 0*)*)
(*gridNonZero=TableLLPnonZeroCompiled[grid,mLLP];*)
(*(*The same table as gridNonZero but with removed column Subscript[\[Phi], LLP] (equivalent to DeleteDuplicatesBy[gridNonZero,{#[[1]],#[[2]],#[[[3]]}&][[All,{1,2,3,4}]])*)*)
(*gridReducedNonZero=TableLLPnonZeroCompiled[gridreduced,mLLP];*)
(*(*The table with the remaining grid for which Subscript[\[Epsilon], az] = 0*)*)
(*gridReducedZero=TableLLPzeroCompiled[gridreduced,mLLP];*)
(*If[Length[gridReducedNonZero]!=0,*)
(*(*__________________________________________*)*)
(*(*Evaluating decay acceptances per each channel and averaging over simulated decays. At this step, some values may be > 1 if the number of combinations of pairs of the decay products is > 1*)*)
(*(*__________________________________________*)*)
(*proclistgiven=isimulvalPerDecayChannel[[All,2]];*)
(*isimlistgiven=isimulvalPerDecayChannel[[All,1]];*)
(*DecayAcceptancesList=DecayAcceptanceELLP\[Theta]LLPzLLPoverall[LLP,mLLP,proclistgiven,isimlistgiven,gridNonZero,HadronizationOption,AllProductsWithinAcceptance,ntracksmin];*)
(*(*This code replaces the values > 1 with 1.*)*)
(*(*Table Subscript[E, LLP],Subscript[\[Theta], LLP],Subscript[z, LLP],Subscript[\[Epsilon], az,LLP],Subscript[\[Epsilon], decay], where the decay acceptance is averaged over channels*)*)
(*t1=Join[gridReducedNonZero,DecayAcceptancesList,2];*)
(*If[Length[gridReducedZero]!=0,*)
(*(*Merging the table computed above with tables with zero acceptance*)*)
(*t2=Join[gridReducedZero,Table[{0.},Length[gridReducedZero]],2];*)
(*(*Final output*)*)
(*finaldata=SortBy[Join[t1,t2],{#[[1]],#[[2]],#[[3]]}&],finaldata=SortBy[t1,{#[[1]],#[[2]],#[[3]]}&]],finaldata=Join[gridreduced,Table[{0.},Length[gridreduced]],2]]*)
(*];*)
(*finaldata*)
(*]*)


(* ::Input:: *)
(*(*fff=DecayAcceptanceBlock["HNL-mixing-e",20.,ProcessesListRefined["HNL-mixing-e","False"],gridLLPtoDet,gridReducedLLPtoDet,100,"True",">=2",4];*)
(*fff[[All,-1]]//MinMax*)*)


(* ::Subsection:: *)
(*If the LLP and mass only is fixed*)


(* ::Input:: *)
(*FinalBlockMass[LLP_,mLLP_,proclist_,isim_,HadronizationOption_,AllProductsWithinAcceptance_,ntracksmin_]:=*)
(*Module[{},*)
(*(*Block computing the decay acceptance for LLPs that point or not point to the detector*)*)
(*{tabAccToDet,tabAccNotToDet}=If[DecayVolumeAsDetectorGivenExperiment=="False"&&!(GivenExperiment=="ANUBIS-ceiling"),{DecayAcceptanceBlock[LLP,mLLP,proclist,gridLLPtoDet,gridReducedLLPtoDet,isim,HadronizationOption,AllProductsWithinAcceptance,ntracksmin],DecayAcceptanceBlock[LLP,mLLP,proclist,gridLLPnotToDet,gridReducedLLPnotToDet,isim,HadronizationOption,AllProductsWithinAcceptance,ntracksmin]},{DecayAcceptanceBlock[LLP,mLLP,proclist,gridLLPtoDet,gridReducedLLPtoDet,isim,HadronizationOption,AllProductsWithinAcceptance,ntracksmin],0}];*)
(*(*Table Subscript[m, LLP], Subscript[E, LLP], Subscript[\[Theta], LLP], Subscript[z, LLP], \!\(\(<\)*)
(*\*SubscriptBox[\(\[Epsilon]\), \(decay\)]*)
(*\*SubscriptBox[\(>\), \(\[Phi], \ to\ det\  + \ not\ to\ det\)]\), \!\(\(<\)\( *)
(*\*SubscriptBox[\(\[Epsilon]\), \(decay\)]**)
(*\*SubscriptBox[\(\[Epsilon]\), \(other\ cuts\)]\)*)
(*\*SubscriptBox[\(>\), \(\[Phi], \ to\ det\  + \ not\ to\ det\)]\)*) *)
(*(*\!\(\(By\)\(\ \)*)
(*\*SubscriptBox[\(<>\), \(\[Phi], \ to\ det\  + \ not\ to\ det\)]\), one averages over the LLP directions pointing to the end of detector and directions that do not point to it, with the weights being the azimuthal acceptance*)*)
(*If[Length[tabAccToDet]!=0,*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False"&&!(GivenExperiment=="ANUBIS-ceiling"),\[Epsilon]dec1Compiled[tabAccToDet,tabAccNotToDet,mLLP],\[Epsilon]dec2Compiled[tabAccToDet,mLLP]]*)
(*]*)
(*]*)
