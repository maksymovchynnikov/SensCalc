#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title::Closed:: *)
(*Launch this section to run the notebook*)


(* ::Input:: *)
(*ClearAll["Global`*"]*)
(*ParallelEvaluate[ClearAll["Global`*"]];*)
(*CloseKernels[];*)
(*LaunchKernels[];*)
(*FrontEndTokenExecute["SelectAll"]*)
(*FrontEndTokenExecute["SelectionCloseAllGroups"]*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,"Evaluation",All,CellTags];*)
(*SelectionEvaluate[nb]*)


(* ::Title::Closed:: *)
(*Preliminary code: various definitions*)


(* ::Chapter::Closed:: *)
(*Creating relevant directories and critical definitions*)


(* ::Input:: *)
(*SetAttributes[ruleDown,HoldAll];*)
(*ruleDown[list_]:=Flatten[DownValues/@(Unevaluated@list)]*)
(*SetAttributes[ruleOwn,HoldAll];*)
(*ruleOwn[list_]:=Flatten[OwnValues/@(Unevaluated@list)]*)
(*<<FeynCalc`*)


(* ::Chapter::Closed:: *)
(*Parameters*)


(* ::Section::Closed:: *)
(*Various constants, cross-sections*)


(* ::Input:: *)
(*(*SetDirectory["/Users/miksi/AppData/Roaming/Mathematica/Applications/FeynCalc"];*)*)
(*<<FeynCalc`*)
(*{mSM["Bplus"],mSM["B0"],mSM["Bs"],mSM["Bc"]}={5.279,5.279,5.366,6.3};*)
(*{mSM["e"],mSM["mu"],mSM["tau"],mSM["neutrino"],mSM["photon"]}={0.5*10^-3,0.105,1.77,0.,0.};*)
(*{mSM["h"],mSM["W"],mSM["Z"]}={125.,80.,91.};*)
(*{mSM["Pi0"],mSM["Eta"],mSM["EtaPr"]}={0.135,0.547,0.958};*)
(*{mSM["PiCharged"],mSM["Kplus"],mSM["K0"]}={0.139,0.495,0.495};*)
(*{mSM["Rho0"],mSM["Omega"],mSM["Phi"],mSM["JPsi"],mSM["Upsilon"]}={0.775,0.775,1.02,3.1,9.46};*)
(*{mSM["D0"],mSM["Ds"],mSM["Dstar"],mSM["Dplus"]}={1.87,1.97,2.,1.87};*)
(*{mSM["p"]}={0.938};*)
(*SMparticles=Keys[DownValues@mSM][[All,1,1]];*)
(*(*Conversions to the definitions of the module 1*)*)
(*LLPdistr=True;*)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/Generic.nb"}]]];*)
(*Clear[LLPdistr];*)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/SensCalc/SM particles.nb"}]]];*)
(*(*Conversion between the symbolic particles names used in Mathematica notebooks and standard text*)*)
(*MapThread[(ConversionParticle[#1]=#2)&,{{"Bplus","Bc","B0","Bs"},{"\!\(\*SuperscriptBox[\(B\), \(+\)]\)","\!\(\*SubscriptBox[\(B\), \(c\)]\)","\!\(\*SuperscriptBox[\(B\), \(0\)]\)","\!\(\*SubscriptBox[\(B\), \(s\)]\)"}}];*)
(*MapThread[(ConversionParticle[#1]=#2)&,{{"e","mu","tau","neutrino","photon"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Tau]\), \(+\)]\)","\[Nu]","\[Gamma]"}}];*)
(*MapThread[(ConversionParticle[#1]=#2)&,{{"Pi0","Eta","EtaPr","PiCharged","Kplus","K0","KS","KL"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Eta]","\[Eta]'","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","\!\(\*SuperscriptBox[\(K\), \(+\)]\)","\!\(\*SubscriptBox[\(K\), \(L\)]\)","\!\(\*SubscriptBox[\(K\), \(S\)]\)","\!\(\*SubscriptBox[\(K\), \(L\)]\)"}}];*)
(*MapThread[(ConversionParticle[#1]=#2)&,{{"Rho0","Omega","Phi","JPsi","Upsilon","RhoCh"},{"\!\(\*SuperscriptBox[\(\[Rho]\), \(0\)]\)","\[Omega]","\[Phi]","J/\[Psi]","\[CapitalUpsilon]","\!\(\*SuperscriptBox[\(\[Rho]\), \(+\)]\)"}}];*)
(*MapThread[(ConversionParticle[#1]=#2)&,{{"D0","Ds","Dstar","Dplus"},{"\!\(\*SuperscriptBox[\(D\), \(0\)]\)","\!\(\*SubscriptBox[\(D\), \(s\)]\)","\!\(\*SuperscriptBox[\(D\), \(*\)]\)","\!\(\*SuperscriptBox[\(D\), \(+\)]\)"}}];*)
(*(*Whether the given SM particle may be produced at the fiven facility*)*)
(*Do[*)
(*(*How many particles are produced per direct production process; the lowest possible number is considered*)*)
(*nSMperProd[particle]=If[StringContainsQ[particle,"B"]||StringContainsQ[particle,"D"]||StringContainsQ[particle,"K"],2,1];*)
(*Do[*)
(*IfSMatFacility[particle,Facility]=If[nSMperProd[particle]*mSM[particle]>EcmFacility[Facility],0,1];*)
(*,{Facility,FacilitiesList}]*)
(*,{particle,SMparticles}]*)
(*Do[If[fbtobc[Facility]==0.,IfSMatFacility["Bc",Facility]=0],{Facility,FacilitiesList}]*)
(*Print["List of facilities:"]*)
(*Join[{{"Facility","Sqrt[s], GeV"}},{#,EmaxFacility[#]}&/@FacilitiesList]*)
(**)


(* ::Section::Closed:: *)
(*Loading kinematics*)


(* ::Input:: *)
(*Inactivate[Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/kinematics.nb"}]]],Print];*)


(* ::Title::Closed:: *)
(*Preliminary code: mother particles sampling*)


(* ::Chapter::Closed:: *)
(*Importing tabulated mother particles distributions*)


(* ::Input:: *)
(*(*List all files matching the distribution name pattern*)*)
(*files=FileNames["DoubleDistr_*_*.txt",FileNameJoin[{NotebookDirectory[],"spectra/SM particles"}],Infinity];*)
(*(*Extracting the information about the facility and particle from the filename*)*)
(*extractData[filename_]:=StringCases[FileNameTake[filename],"DoubleDistr_"~~facility:(Shortest[___])~~"_"~~particle:(ShortestMatch[___])~~".txt":>{facility,particle}][[1]]*)
(*(*Extract<Particle>, <Facility>pairs and remove duplicates*)*)
(*dataPairs=extractData[#]&/@files;*)
(*(*Sort the pairs by Facility*)*)
(*sortedDataPairs=SortBy[dataPairs,{#[[1]],#[[2]]}&];*)
(*(*Importing all the distributions*)*)
(*MotherImportingBlock[Facility_,Particle_]:=Block[{},*)
(*filenameimport=ToString@StringForm["DoubleDistr_``_``.txt",Sequence@@{Facility,Particle}];*)
(*dataimport=Import[FileNameJoin[{NotebookDirectory[],"spectra/SM particles",filenameimport}],"Table"]*)
(*]*)
(*Do[DataDistr[sortedDataPairs[[i]][[1]],sortedDataPairs[[i]][[2]]]=MotherImportingBlock[sortedDataPairs[[i]][[1]],sortedDataPairs[[i]][[2]]],{i,1,Length[sortedDataPairs]}]//AbsoluteTiming*)
(*sortedDataPairs=SortBy[Join[sortedDataPairs,Table[{Facility,"p"},{Facility,FacilitiesList}],{{"ESS","PiCharged"},{"ESS","mu"}}],{#[[1]],#[[2]]}&];*)
(*(*In case some of the distributions are absent, the notebook will replace them with the distribution of the "similar" particle*)*)
(*SimilarParticle["FCC-hh","Bc"]=SimilarParticle["LHC","Bc"]=SimilarParticle["SPS","Bc"]=SimilarParticle["FermilabBD","Bc"]="Bplus";*)
(*SimilarParticle["FCC-hh","B0"]=SimilarParticle["LHC","B0"]=SimilarParticle["SPS","B0"]=SimilarParticle["FermilabBD","B0"]="Bplus";*)
(*SimilarParticle["FCC-hh","Bs"]=SimilarParticle["LHC","Bs"]=SimilarParticle["SPS","Bs"]=SimilarParticle["FermilabBD","Bs"]="Bplus";*)
(*SimilarParticle["FCC-hh","tau"]=SimilarParticle["LHC","tau"]=SimilarParticle["SPS","tau"]=SimilarParticle["FermilabBD","tau"]="Ds";*)
(*SimilarParticle["FCC-hh","D0"]=SimilarParticle["FCC-hh","Ds"]="Dplus";*)


(* ::Chapter::Closed:: *)
(*Sampling 4-momenta of mother particles from tabulated distribution*)


(* ::Section::Closed:: *)
(*Preliminary definitions*)


(* ::Subsection::Closed:: *)
(*Quick mapping the data {x,y,f[x,y]} ->{x',y',f[x',y']} for some structured grids {x,y} and {x', y'}*)


(* ::Input:: *)
(*nd=2;*)
(*cf2=Module[{xgvars=Unique["xg"]&/@slist@@Range@nd,igvars=Unique["ig"]&/@slist@@Range@nd,tgvars=Unique["tg"]&/@slist@@Range@nd,ivars=Unique["i"]&/@slist@@Range@nd,svars=Unique["s"]&/@slist@@Range@nd,tvars=Unique["t"]&/@slist@@Range@nd,jvars=Unique["j"]&/@slist@@Range@nd},Inactivate[Compile[{seq@{xgvars,_Real,1},{y,_Real,nd}},Module[{seq@igvars,seq@tgvars,seq@ivars,seq@svars,seq@tvars},seq[igvars=Floor[xgvars]-UnitStep[xgvars-indexed@Dimensions@y]];*)
(*seq[tgvars=xgvars-igvars];*)
(*Table[seq[tvars=Compile`GetElement[tgvars,jvars]];*)
(*seq[ivars=Compile`GetElement[igvars,jvars]];*)
(*seq[svars=1.-tvars];*)
(*eval@Total[Times@@#[[All,1]] Compile`GetElement[y,Sequence@@#[[All,2]]]&/@Tuples@Transpose[{{svars,ivars},{tvars,ivars+1}},{2,3,1}]],seq@{jvars,Length@igvars}]],CompilationTarget->"C",RuntimeAttributes->{Listable},Parallelization->True,RuntimeOptions->"Speed"],Except[seq|eval|indexed]]/.seq[expr_]:>RuleCondition@(Sequence@@Table[Inactivate[expr,Except[slist|indexed]]/.{l_slist:>l[[i]],indexed[l_]:>Inactive[Compile`GetElement][l,i]},{i,nd}])/.eval@expr_:>RuleCondition[Activate[expr/.slist->List]]]//Activate;*)


(* ::Subsection::Closed:: *)
(*Compiled linear interpolations - for mapping from {x,y,f[x,y]} to {Subscript[x, random],Subscript[y, random],f[Subscript[x, random],Subscript[y, random]]}*)


(* ::Input:: *)
(*(*Random Log[\[Theta]] points, random Log[E] points, *)*)
(*linint2=Compile[{{rand\[Theta]log,_Real},{randElog,_Real},{grid\[Theta]log,_Real,1},{gridElog,_Real,1},{index\[Theta],_Integer},{indexE,_Integer},{distrlog,_Real,2}},Module[{\[Theta]el,Eel,x1,x2,y1,y2,z11,z21,z12,z22,\[CapitalDelta],indexlarger\[Theta],indexlargerE,lenE},*)
(*(*Finding the index of the grids with the elements larged than the given random point*)*)
(*\[Theta]el=Compile`GetElement[grid\[Theta]log,index\[Theta]];*)
(*indexlarger\[Theta]=index\[Theta]+UnitStep[rand\[Theta]log-\[Theta]el];*)
(*Eel=Compile`GetElement[gridElog,indexE];*)
(*indexlargerE=indexE+UnitStep[randElog-Eel];*)
(*(*The two points x1, x2 with x1 < x < x2*)*)
(*x1=Compile`GetElement[grid\[Theta]log,indexlarger\[Theta]-1];*)
(*x2=Compile`GetElement[grid\[Theta]log,indexlarger\[Theta]];*)
(*y1=Compile`GetElement[gridElog,indexlargerE-1];*)
(*y2=Compile`GetElement[gridElog,indexlargerE];*)
(*(*Corresponding values of the function*)*)
(*lenE=Length[gridElog];*)
(*z11=Compile`GetElement[distrlog,(indexlarger\[Theta]-2)*lenE+indexlargerE-1,3];*)
(*z21=Compile`GetElement[distrlog,(indexlarger\[Theta]-1)*lenE+indexlargerE-1,3];*)
(*z12=Compile`GetElement[distrlog,(indexlarger\[Theta]-2)*lenE+indexlargerE,3];*)
(*z22=Compile`GetElement[distrlog,(indexlarger\[Theta]-1)*lenE+indexlargerE,3];*)
(*\[CapitalDelta]=(x2-x1)(y2-y1);*)
(*Exp[(*{rand\[Theta]log,x1,x2,randElog,y1,y2,z11,z21,z12,z22,*)((x2-rand\[Theta]log)*(y2-randElog))/\[CapitalDelta]*z11+((rand\[Theta]log-x1)*(y2-randElog))/\[CapitalDelta] z21+((x2-rand\[Theta]log)(randElog-y1))/\[CapitalDelta]*z12+((rand\[Theta]log-x1)(randElog-y1))/((x2-x1)(y2-y1)) z22(*}*)]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@linint2;*)
(*linint1=Compile[{{rand\[Theta]log,_Real},{grid\[Theta]log,_Real,1},{index\[Theta],_Integer},{distrlog,_Real,2}},Module[{\[Theta]el,x1,x2,z1,z2,\[CapitalDelta],indexlarger\[Theta]},*)
(*(*Finding the index of the grids with the elements larged than the given random point*)*)
(*\[Theta]el=Compile`GetElement[grid\[Theta]log,index\[Theta]];*)
(*indexlarger\[Theta]=index\[Theta]+UnitStep[rand\[Theta]log-\[Theta]el];*)
(*(*The two points x1, x2 with x1 < x < x2*)*)
(*x1=Compile`GetElement[grid\[Theta]log,indexlarger\[Theta]-1];*)
(*x2=Compile`GetElement[grid\[Theta]log,indexlarger\[Theta]];*)
(*(*Corresponding values of the function*)*)
(*z1=Compile`GetElement[distrlog,indexlarger\[Theta],2];*)
(*z2=Compile`GetElement[distrlog,indexlarger\[Theta]-1,2];*)
(*\[CapitalDelta]=(x2-x1);*)
(*(*{rand\[Theta]log,x1,x2,z1,z2,*)*)
(*z1+(rand\[Theta]log-x1)*(z2-z1)/\[CapitalDelta](*}*)*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@linint1;*)


(* ::Subsection::Closed:: *)
(*Finding Subscript[E, max](\[Theta]) - for efficient energy sampling for the given \[Theta]*)


(* ::Input:: *)
(*(*Function to process the table*)*)
(*FindingMaxEnergy[tab_,order_]:=Module[{Egrouped,tot},*)
(*(*Group by y values*)*)
(*Egrouped=GatherBy[tab,#[[2]]&];*)
(*(*Sum z values for each y and create new table*)*)
(*\[Theta]summed=Table[{Egrouped[[i,1,2]],Total[Egrouped[[i,All,3]]]},{i,1,Length[Egrouped]}];*)
(*If[Max[\[Theta]summed[[All,2]]]>10^-30.,*)
(*tot=\[Theta]summed[[All,2]]//Total;*)
(*accum=(tot-Accumulate[\[Theta]summed[[All,2]]])/tot;*)
(*sel=Select[accum,#>=10^-order&];*)
(*If[Length[sel]!=0.,*)
(*emaxpos=Min[Position[accum,sel[[-1]]][[1]][[1]]+1,Length[accum]];*)
(*emaxval=\[Theta]summed[[emaxpos]][[1]],*)
(*emaxval=\[Theta]summed[[1]][[1]]]];*)
(*emaxval*)
(*]*)
(*DataLogarithmiedComp=Compile[{{data,_Real,1}},{Log[Compile`GetElement[data,1]],Log[Compile`GetElement[data,2]],If[Compile`GetElement[data,3]==0,Log[10^-90.],Log[Compile`GetElement[data,3]]]},CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}];*)
(*Do[*)
(*\[Theta]gridForEmax[fac]={10^-5.,10^-4.,0.001,0.005,0.008,0.01,0.02,0.03,0.04,0.06,0.08,0.1,0.11,0.12,0.13,0.15,0.17,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.,1.2,1.3,Pi/2}//N;*)
(*If[fac=="LHC",\[Theta]gridForEmax[fac]=Join[\[Theta]gridForEmax[fac],{3*10^-4.,6*10^-4.,2*10^-3,3*10^-3,4*10^-3,6*10^-3,7*10^-3,9*10^-3.,0.011,0.013,0.016,0.018,0.022,0.024,0.027,0.033,0.036,0.045,0.05,0.07,0.09}//N]//Sort//DeleteDuplicates];*)
(*If[fac=="FCC-hh",\[Theta]gridForEmax[fac]=Join[\[Theta]gridForEmax[fac],{5*10^-5.,2*10^-4.,4*10^-4.,6*10^-4.,8*10^-4.,2*10^-3,3*10^-3,4*10^-3.}//N]//Sort//DeleteDuplicates];*)
(*,{fac,FacilitiesList}];*)
(*FindingEmax\[Theta][data_,Facility_,order_]:=Module[{(*\[Theta]minmax,eminmax,GridIn,distrv,GridOut,xigDistr,distrvals,mappeddistr,\[Theta]emax,emax,\[Theta]ranges,distrdatalog*)},*)
(*IfCollider=MemberQ[{"LHC","FCC-hh"},Facility];*)
(*distrdatalog=DataLogarithmiedComp[data];*)
(*GridIn=(DeleteDuplicates[distrdatalog[[All,#]]]&/@{1,2})//N;*)
(*distrv=ArrayReshape[distrdatalog[[All,3]],{Length[GridIn[[1]]],Length[GridIn[[2]]]}];*)
(*{\[Theta]minmax,eminmax}=MinMax[data[[All,#]]]&/@{1,2};*)
(*\[Theta]ranges=If[IfCollider,Select[\[Theta]gridForEmax[Facility],\[Theta]minmax[[1]]<=#&],Select[Flatten[Join[{#,Pi-#}&/@Join[\[Theta]gridForEmax[Facility],{\[Theta]minmax[[2]]}]]]//N//Sort//DeleteDuplicates,\[Theta]minmax[[1]]<=#<=\[Theta]minmax[[2]]&]]//N;*)
(*\[Theta]emax={{}};*)
(*Do[*)
(*nintervals=If[\[Theta]ranges[[i+1]]-\[Theta]ranges[[i]]>10^-3,10,3];*)
(*GridOut={Table[th,{th,\[Theta]ranges[[i]],\[Theta]ranges[[i+1]],(\[Theta]ranges[[i+1]]-\[Theta]ranges[[i]])/nintervals}],Join[Table[Exp[e],{e,Log[eminmax[[1]]],Log[eminmax[[2]]],Max[0.1,(Log[eminmax[[2]]]-Log[eminmax[[1]]])/100]}],{eminmax[[2]]}]//DeleteDuplicates}//Log;*)
(*xigDistr=MapThread[Interpolation[Transpose@{#,Range@Length@#},InterpolationOrder->1][#2]&,{GridIn,GridOut}];*)
(*distrvals=Flatten@cf2[Sequence@@xigDistr,distrv];*)
(*mappeddistr=Exp[Join[Tuples[GridOut],Partition[distrvals,1],2]];*)
(*emax=FindingMaxEnergy[mappeddistr,order];*)
(*\[Theta]emax=Join[\[Theta]emax,{{(\[Theta]ranges[[i]]+\[Theta]ranges[[i+1]])/2,emax}}];*)
(*,{i,1,Length[\[Theta]ranges]-1,1}];*)
(*\[Theta]emax=Drop[\[Theta]emax,1];*)
(*\[Theta]emax=Log[If[IfCollider,Flatten[Join[{#,{Pi-#[[1]],#[[2]]}&/@#}&/@{Join[{{\[Theta]minmax[[1]],\[Theta]emax[[1]][[2]]}},\[Theta]emax]}][[1]],1],Join[{{\[Theta]minmax[[1]],\[Theta]emax[[1]][[2]]}},\[Theta]emax,{{\[Theta]minmax[[2]],\[Theta]emax[[-1]][[2]]}}]]//Sort//DeleteDuplicates//N]*)
(*]*)


(* ::Section::Closed:: *)
(*Sampling points*)


(* ::Input:: *)
(*erandcomp=Compile[{{eminv,_Real},{emaxv,_Real},{Nev,_Integer}},Log[RandomReal[{Exp[eminv],Exp[emaxv]}]],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]//ReleaseHold;*)
(*MotherDataCompiled=Compile[{{Events,_Real,1},{m,_Real}},Module[{thv,ev,\[Phi]v,pv},*)
(*thv=Compile`GetElement[Events,1];*)
(*ev=Compile`GetElement[Events,2];*)
(*\[Phi]v=RandomReal[{-Pi,Pi}];*)
(*pv=Sqrt[ev^2-m^2];*)
(*{pv*Cos[\[Phi]v]*Sin[thv],pv*Sin[\[Phi]v]*Sin[thv],pv*Cos[thv],ev,m}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]*)
(*BlockPointsFromSmoothDistribution1[data_,m_,Nevents_,order_,Facility_]:=Module[{Emaxlist,\[Theta]minmax,Data\[Phi],Nev,eminmax,NevSampl},*)
(*IfCollider=MemberQ[{"LHC","FCC-hh"},Facility];*)
(*distrdatalog=DataLogarithmiedComp[data];*)
(*GridIn=(DeleteDuplicates[distrdatalog[[All,#]]]&/@{1,2})//N;*)
(*\[Theta]minmax=({Min[#],If[IfCollider,Pi/2.,Max[#]]}&/@{data[[All,1]]})[[1]];*)
(*emin=Log[Min[data[[All,2]]]];*)
(*(*Computing table Subscript[E, max](\[Theta])*)*)
(*Nev=If[!IfCollider,Nevents,IntegerPart[Nevents/2]];*)
(*NevSampl=Max[3*Nev,10^6];*)
(*\[Theta]emaxdata=FindingEmax\[Theta][data,Facility,order];*)
(*(*__________________________________*)*)
(*(*Generating the grid of Subscript[\[Theta], rand],Subscript[E, rand]*)*)
(*(*__________________________________*)*)
(*(*Generating random \[Theta]*)*)
(*\[Theta]rand=Log[RandomReal[\[Theta]minmax,NevSampl]];*)
(*(*For each \[Theta], generaring random E\[Element]{Subscript[E, min],Subscript[E, max](\[Theta])}*)*)
(*nf\[Theta]Emaxlog=Nearest[\[Theta]emaxdata[[All,1]]->"Index"];*)
(*index\[Theta]Emaxlog=nf\[Theta]Emaxlog[\[Theta]rand]//Flatten;*)
(*emaxrand=linint1[\[Theta]rand,\[Theta]emaxdata[[All,1]],index\[Theta]Emaxlog,\[Theta]emaxdata];*)
(*erand=erandcomp[emin,emaxrand,NevSampl];*)
(*(*Now, calculating the weights for the generated Subscript[\[Theta], rand],Subscript[E, rand]*)*)
(*nf\[Theta]log=Nearest[GridIn[[1]]->"Index"];*)
(*nfElog=Nearest[GridIn[[2]]->"Index"];*)
(*{index\[Theta]rand,indexerand}={nf\[Theta]log[\[Theta]rand]//Flatten,nfElog[erand]//Flatten};*)
(*weights=(Exp[emaxrand]-Exp[emin])*linint2[\[Theta]rand,erand,GridIn[[1]],GridIn[[2]],index\[Theta]rand,indexerand,distrdatalog];*)
(*(*Generating "True" \[Theta],E based on the weights*)*)
(*PTS=RandomChoice[weights->Transpose[Exp[{\[Theta]rand,erand}]],Nev];*)
(*motherdata=MotherDataCompiled[PTS,m];*)
(*If[IfCollider,*)
(*motherdataExtended=motherdata;*)
(*motherdataExtended[[All,3]]=-motherdataExtended[[All,3]];*)
(*motherdata=Join[motherdata,motherdataExtended]];*)
(*If[Length[motherdata]!=Nevents,motherdata=Join[motherdata,{motherdata[[-1]]}]]//Developer`ToPackedArray;*)
(*motherdata*)
(*]*)
(*DataConverted=Compile[{{data,_Real,1},{m,_Real}},Module[{px,py,pz,e},*)
(*px=Compile`GetElement[data,1];*)
(*py=Compile`GetElement[data,2];*)
(*pz=Compile`GetElement[data,3];*)
(*e=Sqrt[px^2+py^2+pz^2+m^2];*)
(*{px,py,pz,e,m}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]*)


(* ::Chapter::Closed:: *)
(*Interpolation and phase space sampling*)


(* ::Section::Closed:: *)
(*Phase space sampling*)


(* ::Input:: *)
(*MotherInterpolation[Facility_,Particle_]:=Module[{data,datalog},*)
(*data=DataDistr[Facility,Particle];*)
(*datalog=DataLogarithmiedComp[data];*)
(*\[Theta]MinMax[Facility,Particle]=MinMax[data[[All,1]]];*)
(*Emax[\[Theta]X_,Facility,Particle]=Interpolation[FindingEmax\[Theta][DataDistr[Facility,Particle],Facility,7],InterpolationOrder->1][Log[\[Theta]X]]//Exp;*)
(*DoubleDistrMotherInt[\[Theta]X_,EX_,Facility,Particle]=If[mSM[Particle]<=EX<=Emax[\[Theta]X,Facility,Particle]&&\[Theta]MinMax[Facility,Particle][[1]]<=\[Theta]X<=\[Theta]MinMax[Facility,Particle][[2]],Evaluate[Exp[Interpolation[datalog,InterpolationOrder->1][Log[\[Theta]X],Log[EX]]]],0.];*)
(*]*)
(*MotherInterpolation["LHC","Upsilon"];*)
(*IfMotherInterpolated[Facility_,Mother_]:=MemberQ[{Keys[DownValues@DoubleDistrMotherInt][[All,1,-2]],Keys[DownValues@DoubleDistrMotherInt][[All,1,-1]]}//Transpose,{Facility,Mother}]*)
(*{IfMotherInterpolated["LHC","Upsilon"],IfMotherInterpolated["SPS","Kplus"]}*)
(*PointsSampler[Facility_,Particle_,Nevents_,IfTwo_]:=Module[{data,Nev,IfPresent,particle,motherpoints,datafin},*)
(*(*For the moment, for some distributions that are absent, they will be approximated by the distributions of similar particles*)*)
(*If[Facility=="ESS"&&MemberQ[{"PiCharged","mu"},Particle],*)
(*datafin=ConstantArray[{0.,0.,0.,mSM[Particle],mSM[Particle]},Nevents]*)
(*,*)
(*IfPresent=If[Length[DataDistr[Facility,Particle]]==2,"False","True"];*)
(*particle=If[IfPresent=="True",Particle,SimilarParticle[Facility,Particle]];*)
(*data=DataDistr[Facility,particle];*)
(*(*Option IfTwo: if "True", then the mother particle is supposed to decay into two LLPs. If "False", then it will produce only one LLP*)*)
(*(*If "True", then Subscript[N, events]/2 mother particles will be sampled, and then the data will be doubled*)*)
(*Nev=If[IfTwo=="True",Nevents/2,Nevents];*)
(*datafin=BlockPointsFromSmoothDistribution1[data,mSM[particle],Nev,9,Facility];*)
(*If[IfTwo=="True",datafin=Riffle[datafin,datafin]];*)
(*If[particle!=Particle,datafin=DataConverted[datafin,mSM[Particle]],datafin];*)
(*];*)
(*datafin*)
(*]*)


(* ::Section::Closed:: *)
(*Test*)


(* ::Input:: *)
(*(*factest="Serpukhov";*)
(*ptest="EtaPr";*)
(*If[Length[DataDistr[factest,ptest]]!=2,*)
(*pts=PointsSampler[factest,ptest,10^6,"False"];*)
(*MotherInterpolation[factest,ptest];*)
(*angdistrIntDat=With[{thmin=\[Theta]MinMax[factest,ptest][[1]],thmax=\[Theta]MinMax[factest,ptest][[2]]},ParallelTable[{10^x,Quiet[NIntegrate[DoubleDistrMotherInt[10^x,Exp[e],factest,ptest]Exp[e],{e,Log[pts[[All,4]]//Min],Log[pts[[All,4]]//Max]},Method->"InterpolationPointsSubdivision"]]},{x,Log10[thmin],Log10[thmax],(Log10[thmax]-Log10[thmin])/100}]];*)
(*angdistrInt[\[Theta]X_]=Interpolation[angdistrIntDat,InterpolationOrder->1][\[Theta]X];*)
(*norm1=NIntegrate[angdistrInt[Exp[x]]Exp[x],{x,Log[Min[PTS[[All,1]]]],Log[Max[PTS[[All,1]]]]},Method->"InterpolationPointsSubdivision"];*)
(*thvs=\[Theta]Nlist[factest];*)
(*angles=PTS[[All,1]];*)
(*bns=BinCounts[angles,{thvs}];*)
(*tabpdf=Table[{Log[(thvs[[i]]+thvs[[i+1]])/2],Log[Max[10^-90.,bns[[i]]/(thvs[[i+1]]-thvs[[i]])]]},{i,1,Length[thvs]-1,1}];*)
(*pdfint[x_]=If[Min[PTS[[All,1]]]<=x<=Max[PTS[[All,1]]],Evaluate[Exp[Interpolation[tabpdf,InterpolationOrder->1][Log[x]]]],0.];*)
(*norm2=Quiet[NIntegrate[pdfint[Exp[x]]Exp[x],{x,Log[Min[PTS[[All,1]]]],Log[Max[PTS[[All,1]]]]},Method->"InterpolationPointsSubdivision"]];*)
(*]//AbsoluteTiming*)
(*Quiet[{NIntegrate[pdfint[x]x,{x,10^-5,Pi/2}]/NIntegrate[pdfint[x],{x,10^-5,Pi/2}],NIntegrate[angdistrInt[Exp[x]]Exp[2x],{x,Log[Min[PTS[[All,1]]]],Min[Pi/2,Log[Max[PTS[[All,1]]]]]}]/NIntegrate[angdistrInt[Exp[x]],{x,Log[Min[PTS[[All,1]]]],Min[Pi/2,Log[Max[PTS[[All,1]]]]]}]}]*)
(*Quiet[LogLogPlot[{1/norm1angdistrInt[x]/x,1/norm2pdfint[x]/x},{x,10^-5.,Pi/2}]]*)*)


(* ::Title::Closed:: *)
(*Preliminary code: LLP production phenomenology*)


(* ::Chapter::Closed:: *)
(*Preliminary definitions*)


(* ::Section::Closed:: *)
(*Kinematics of 3-body decays in terms of energies Subscript[E, 1],Subscript[E, 3]*)


(* ::Input:: *)
(*(*Kinematics of 3-body decays*)*)
(*pPar[En_,mn_]=\[Sqrt](En^2-mn^2);*)
(*E2valEnergies[m_,E1_,E3_]=m-E1-E3;*)
(*(*cos between particles 1,2 and 1,3 at rest frame of decaying particle 0 \[Rule] 1+2+3 parametrized in terms of Subscript[E, 1],Subscript[E, 3]*)*)
(*(*For example, cos(Subscript[\[Theta], 12]) = ((Subscript[Overscript[p, _], 1]*Subscript[Overscript[p, _], 2])/(|Subscript[p, 1]||Subscript[p, 2]|)). We have Subscript[Overscript[p, _], 1]+Subscript[Overscript[p, _], 2]+Subscript[Overscript[p, _], 3] = 0, or Subscript[Overscript[p, _]^2, 1]+Subscript[Overscript[p, _]^2, 2]+2Subscript[Overscript[p, _], 1]*Subscript[Overscript[p, _], 2] = Subscript[Overscript[p, _]^2, 3] = Subscript[E^2, 3]-Subscript[m^2, 3]*)*)
(*cos\[Theta]12[E1_,E3_,m_,m1_,m2_,m3_]=(pPar[E3,m3]^2-pPar[E1,m1]^2-pPar[E2valEnergies[m,E1,E3],m2]^2)/(2pPar[E1,m1]*pPar[E2valEnergies[m,E1,E3],m2]);*)
(*cos\[Theta]13[E1_,E3_,m_,m1_,m2_,m3_]=(pPar[E2valEnergies[m,E1,E3],m2]^2-pPar[E1,m1]^2-pPar[E3,m3]^2)/(2pPar[E1,m1]*pPar[E3,m3]);*)
(*\[Theta]12[E1_,E3_,m_,m1_,m2_,m3_]=ArcCos[cos\[Theta]12[E1,E3,m,m1,m2,m3]];*)
(*\[Theta]13[E1_,E3_,m_,m1_,m2_,m3_]=ArcCos[cos\[Theta]13[E1,E3,m,m1,m2,m3]];*)
(*(*Domain of definition of Subscript[E, 1] and Subscript[E, 3] in decay 0\[Rule]1+2+3 at rest frame of 0*)*)
(*E3domain[E1_,m_,m1_,m2_,m3_]=E3/.Simplify[Solve[cos\[Theta]12[E1,E3,m,m1,m2,m3]==1,E3]]*)
(*E3domain1[E1_,m_,m1_,m2_,m3_]=E3domain[E1,m,m1,m2,m3][[1]];*)
(*E3domain2[E1_,m_,m1_,m2_,m3_]=E3domain[E1,m,m1,m2,m3][[2]];*)
(*\[CapitalDelta]E3[E1_,m_,m1_,m2_,m3_]=E3domain2[E1,m,m1,m2,m3]-E3domain1[E1,m,m1,m2,m3]//Simplify*)
(*{E1domainMin[m_,m1_,m2_,m3_],E1domainMax[m_,m1_,m2_,m3_]}=E1domain[m_,m1_,m2_,m3_]={E1/.Solve[\[CapitalDelta]E3[E1,m,m1,m2,m3]==0,E1][[2]],E1/.Solve[\[CapitalDelta]E3[E1,m,m1,m2,m3]==0,E1][[3]]}//Simplify*)
(*(*Domain of definition of Subscript[E, 1] and Subscript[E, 3] in decay 0\[Rule]1+2+3 at rest frame of 0 - Subscript[E, 3] is main function*)*)
(*E1domain1[E3_,m_,m1_,m2_,m3_]=E1/.Simplify[Solve[cos\[Theta]12[E1,E3,m,m1,m2,m3]==1,E1]]//Simplify*)
(*E3domain1[m_,m1_,m2_,m3_]={E3/.Solve[E1domain1[E3,m,m1,m2,m3][[1]]-E1domain1[E3,m,m1,m2,m3][[2]]==0,E3][[2]],E3/.Solve[E1domain1[E3,m,m1,m2,m3][[1]]-E1domain1[E3,m,m1,m2,m3][[2]]==0,E3][[3]]}//Simplify*)
(*(*Mandelstam invariants Subscript[m, ij] = (Subscript[p, i]+Subscript[p, j])^2 in terms of Subscript[E, 1],Subscript[E, 3]*)*)
(*M13[E1_,E3_]=(E1+E3)^2-(pPar[E1,m1]^2+pPar[E3,m3]^2+2*pPar[E1,m1]*pPar[E3,m3]*cos\[Theta]13[E1,E3,m,m1,m2,m3])//Expand//Simplify*)
(*M12[E1_,E3_]=(E1+E2valEnergies[m,E1,E3])^2-(pPar[E1,m1]^2+pPar[E2valEnergies[m,E1,E3],m2]^2+2*pPar[E1,m1]*pPar[E2valEnergies[m,E1,E3],m2]*cos\[Theta]12[E1,E3,m,m1,m2,m3])//Expand//Simplify*)
(*Q2[E1_,E3_,m_,m2_]=(m^2+m2^2-2*m*E2valEnergies[m,E1,E3]);*)


(* ::Subsection::Closed:: *)
(*Scalar products for 3-body decays at rest*)


(* ::Input:: *)
(*ProductKK=m^2;*)
(*ProductK2K2=m2^2;*)
(*ProductK3K3=m3^2;*)
(*ProductK1K1=m1^2;*)
(*ProductKK2energy=m*E2valEnergies[m,E1,E3];*)
(*ProductKK1energy=m*E1;*)
(*ProductKK3energy=m*E3;*)
(*ProductK1K3energy=(M13[E1,E3]-m1^2-m3^2)/2;*)
(*ProductK1K2energy=(M12[E1,E3]-m1^2-m2^2)/2;*)
(*ProductK2K3energy=(m^2+m1^2-2*m*E1-m2^2-m3^2)/2;*)


(* ::Section::Closed:: *)
(*Coherent EM processes (WW approximation)*)


(* ::Subsection::Closed:: *)
(*EM elastic form-factors*)


(* ::Input:: *)
(*(*Helm*)*)
(*svalfm=0.9;*)
(*fmtoGeVm1=5;*)
(*(*Effective radius of the nucleus*)*)
(*R1[Anucleus_]=fmtoGeVm1 Sqrt[(1.23*Anucleus^(1/3)-0.6)^2+7/3 Pi^2*0.52^2-5*svalfm^2];*)
(*FHelm[q2_,Anucleus_,Znucleus_]=3*Znucleus*(*SphericalBesselJ[1,Sqrt[q2]*R1[Anucleus]]*)(Sin[x]/x^2-Cos[x]/x/.{x->Sqrt[q2]*R1[Anucleus]})/(Sqrt[q2]*R1[Anucleus]) Exp[-((q2*(svalfm*fmtoGeVm1)^2)/2)];*)
(*FHelm1[q2_,Rnucl_,Znucleus_]=3*Znucleus*(*SphericalBesselJ[1,Sqrt[q2]*R1[Anucleus]]*)(Sin[x]/x^2-Cos[x]/x/.{x->Sqrt[q2]*Rnucl})/(Sqrt[q2]*Rnucl) Exp[-((q2*(svalfm*fmtoGeVm1)^2)/2)]*)
(*(*Proton*)*)
(*GE[q2_]=1/(1+q2/0.843^2)^2;*)
(*GM[q2_]=Sqrt[7.78]/(1+q2/0.843^2)^2;*)
(*F1[q2_]=(4*mp^2*GE[q2]+q2*GM[q2])/(4*mSM["p"]^2+q2);*)
(*F2[q2_]=(GM[q2]-GE[q2])/(4*mSM["p"]^2+q2);*)
(*Dval[q2_]=(4*mSM["p"]^2*GE[q2]^2+q2*GM[q2]^2)/(4*mSM["p"]^2+q2);*)
(**)


(* ::Subsection::Closed:: *)
(*Equivalent photon distribution functions*)


(* ::Input:: *)
(*(*Magnitude of the momentum transfer between particle and photon*)*)
(*q2pTxVal[x_,pT_,m_]=(pT^2+x^2*m^2)/(1-x);*)
(*fEPAp[pT_,x_,\[Alpha]EM_]=\[Alpha]EM/(2*Pi) (1+(1-x)^2)/x (pT^2/(pT^2+x^2*mSM["p"]^2)^2 Dval[q2pTxVal[x,pT,mSM["p"]]]+x^2/2 GM[q2pTxVal[x,pT,mSM["p"]]]^2);*)
(*fEPAnucleus[pT_,x_,\[Alpha]EM_,mNucleus_,Anucleus_,Znucleus_]=\[Alpha]EM/(2*Pi) (1+(1-x)^2)/x (pT^2/(pT^2+x^2*mNucleus^2)^2 FHelm[q2pTxVal[x,pT,mNucleus],Anucleus,Znucleus]^2)//Simplify;*)
(*fEPAnucleus1[pT_,x_,\[Alpha]EM_,mNucleus_,Rnucl_,Znucleus_]=\[Alpha]EM/(2*Pi) (1+(1-x)^2)/x (pT^2/(pT^2+x^2*mNucleus^2)^2 FHelm1[q2pTxVal[x,pT,mNucleus],Rnucl,Znucleus]^2)//Simplify;*)
(**)


(* ::Chapter::Closed:: *)
(*HNL*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*ListHNLs={"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"};*)
(*(*__________________________________*)*)
(*(*HNLs with e mixing*)*)
(*(*__________________________________*)*)
(*(*List of processes*)*)
(*LLPname=ListHNLs[[1]];*)
(*ProcessesListAll[LLPname]={"B-3-body","B-2-body","Bc","D-3-body","D-2-body","K","W","mu","PiCharged"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],Table["Decay",Length[ProcessesListAll[LLPname]]]}];*)
(*ProductionType[LLPname,"B"]=ProductionType[LLPname,"D"]=ProductionType[LLPname,"K"]="Decay";*)
(*(*Particle content: mother particle, decay products*)*)
(*(*For 3-body decays of B, one reference decay process is used: B -> N + D^* + l, which dominates the production*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","Dstar","e",LLPname},{"Bplus","e",LLPname},{"Bc","e",LLPname},{"Dplus","K0","e",LLPname},{"Ds","e",LLPname},{"Kplus","e",LLPname},{"W","e",LLPname},{"mu","e","neutrino",LLPname},{"PiCharged","e",LLPname}}}];*)
(*(*__________________________________*)*)
(*(*HNLs with \[Mu] mixing*)*)
(*(*__________________________________*)*)
(*LLPname=ListHNLs[[2]];*)
(*ProcessesListAll[LLPname]={"B-3-body","B-2-body","Bc","D-3-body","D-2-body","K","W","mu","PiCharged"};*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],Table["Decay",Length[ProcessesListAll[LLPname]]]}];*)
(*ProductionType[LLPname,"B"]=ProductionType[LLPname,"D"]=ProductionType[LLPname,"K"]="Decay";*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","Dstar","mu",LLPname},{"Bplus","mu",LLPname},{"Bc","mu",LLPname},{"Dplus","K0","mu",LLPname},{"Ds","mu",LLPname},{"Kplus","mu",LLPname},{"W","mu",LLPname},{"mu","e","neutrino",LLPname},{"PiCharged","mu",LLPname}}}];*)
(*(*__________________________________*)*)
(*(*HNLs with \[Tau] mixing*)*)
(*(*__________________________________*)*)
(*LLPname=ListHNLs[[3]];*)
(*ProcessesListAll[LLPname]={"B-3-body","B-2-body","Bc","D-2-body","\[Tau]-3-body","\[Tau]-2-body","W"};*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],Table["Decay",Length[ProcessesListAll[LLPname]]]}];*)
(*ProductionType[LLPname,"B"]=ProductionType[LLPname,"D"]=ProductionType[LLPname,"K"]="Decay";*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","Dstar","tau",LLPname},{"Bplus","tau",LLPname},{"Bc","tau",LLPname},{"Ds","tau",LLPname},{"tau","neutrino","e",LLPname},{"tau","PiCharged",LLPname},{"W","tau",LLPname}}}];*)
(*LLPname//Clear*)


(* ::Section::Closed:: *)
(*Weights for the different processes of D/B decays*)


(* ::Subsection::Closed:: *)
(*From B*)


(* ::Input:: *)
(*brint[mN_,file_]:= Interpolation[Import[FileNameJoin[{NotebookDirectory[],"phenomenology/HNL/Production probabilities",file}]],InterpolationOrder->1][mN];*)
(*brsum[proclist_]:=Sum[brint[mN,proc],{proc,proclist}];*)
(*Do[*)
(*(*Dominant decays of Subscript[B, c]*)*)
(*MapThread[(\[Omega]HNL[#1,Facility,"Bc",mN_]=#2)&,{ListHNLs,fbtobc[Facility]*brint[mN,#]&/@{"bc-eN.m","bc-muN.m","bc-tauN.m"}}];*)
(*(*2-body decays of B^+*)*)
(*MapThread[(\[Omega]HNL[#1,Facility,"B-2-body",mN_]=#2)&,{ListHNLs,(fbtobplus[Facility]+fbtob0[Facility])brint[mN,#]&/@{"bplus-eN.m","bplus-muN.m","bplus-tauN.m"}}];*)
(*(*3-body decays of B. br ratios for other 3-body processes are included here as well*)*)
(*{mMax[ListHNLs[[1]],"B-3-body"],mMax[ListHNLs[[2]],"B-3-body"],mMax[ListHNLs[[3]],"B-3-body"]}={mSM["Bplus"]-mSM["Dstar"]-mSM["e"],mSM["Bplus"]-mSM["Dstar"]-mSM["mu"],mSM["Bplus"]-mSM["Dstar"]-mSM["tau"]};*)
(*MapThread[(\[Omega]HNL[#1,Facility,"B-3-body",mN_]=#2)&,{ListHNLs,*)
(*(fbtobplus[Facility]+fbtob0[Facility]){UnitStep[mMax[ListHNLs[[1]],"B-3-body"]-mN]*brsum[{"bplus-D0bareN.m","bplus-D0starbareN.m","b0-DeN.m","b0-DminusstareN.m"}],UnitStep[mMax[ListHNLs[[2]],"B-3-body"]-mN]*brsum[{"bplus-D0barmuN.m","bplus-D0starbarmuN.m","b0-DmuN.m","b0-DminusstarmuN.m"}],UnitStep[mMax[ListHNLs[[3]],"B-3-body"]-mN]*brsum[{"bplus-D0bartauN.m","bplus-D0starbartauN.m","b0-DtauN.m","b0-DminusstartauN.m"}]}}];*)
(*,{Facility,FacilitiesList}]*)
(**)


(* ::Subsection::Closed:: *)
(*Decays of D/\[Tau]*)


(* ::Input:: *)
(*Do[*)
(*MapThread[(\[Omega]HNL[#1,Facility,"D-2-body",mN_]=#2)&,{ListHNLs,{fctods[Facility]*brint[mN,"ds-eN.m"]+fctodplus[Facility]*brint[mN,"dplus-eN.m"],fctods[Facility]*brint[mN,"ds-muN.m"]+fctodplus[Facility]*brint[mN,"dplus-muN.m"],fctods[Facility]*brint[mN,"ds-tauN.m"]+fctodplus[Facility]*brint[mN,"dplus-tauN.m"]}}];*)
(*MapThread[(\[Omega]HNL[#1,Facility,"D-3-body",mN_]=#2)&,{ListHNLs,{fctodplus[Facility]*brsum[{"dplus-K0eN.m","dplus-K0stareN.m"}]+fctod0[Facility]*brsum[{"d0-KplusstareN.m","d0-KpluseN.m"}],fctodplus[Facility]*brsum[{"dplus-K0muN.m","dplus-K0starmuN.m"}]+fctod0[Facility]*brsum[{"d0-KplusstarmuN.m","d0-KplusmuN.m"}],0.}}];*)
(*\[Omega]HNL[ListHNLs[[3]],Facility,"\[Tau]-3-body",mN_]=fctods[Facility]*fdstau*brint[mN,"tau-lbarnuN.m"];*)
(*\[Omega]HNL[ListHNLs[[3]],Facility,"\[Tau]-2-body",mN_]=fctods[Facility]*fdstau*brsum[{"tau-piN.m","tau-KN.m"}];*)
(*,{Facility,FacilitiesList}]*)
(*(*Given Subscript[N, events], for the given processes list it is splitted into fractions corresponding to the weights*)*)
(*NeventsSplitterHNL[HNL_,Facility_,proclist_,mN_,Nevents_]:=Block[{},*)
(*proclistsel=Select[proclist,MemberQ[ProcessesListAll[HNL],#]==True&];*)
(*\[Omega]list={proclistsel,\[Omega]HNL[HNL,Facility,#,mN]&/@proclistsel}//Transpose;*)
(*Nevlist=SortBy[{#[[1]],IntegerPart[(Nevents #[[2]])/(\[Omega]list[[All,2]]//Total)]}&/@\[Omega]list,-#[[2]]&];*)
(*Nevlist[[1]][[2]]=Nevlist[[1]][[2]]+Nevents-(Nevlist[[All,2]]//Total);*)
(*Select[Nevlist,#[[2]]>0&]*)
(*]*)
(*NeventsSplitterHNL[ListHNLs[[3]],"SPS",{"D-2-body","D-3-body","\[Tau]-2-body","\[Tau]-3-body"},0.9,20]*)
(*NeventsSplitterHNL[ListHNLs[[3]],"LHC",{"B-2-body","B-3-body","Bc"},2.9,20]*)


(* ::Section::Closed:: *)
(*Squared matrix elements for 3-body processes (Figs. 4,5 + Appendix A.2 from https://arxiv.org/pdf/1805.08567.pdf)*)


(* ::Subsection::Closed:: *)
(*Definitions*)


(* ::Input:: *)
(*MV=Association[{Kplus->0.892 ,Dplus->2.01,D0->2.01,Ds->2.11,Bplus->5.32,B0->5.32,Bs->5.415,Bc->6.33}];*)
(*fH=Association[{piplus-> 0.13,Kplus-> 0.156,Dplus-> 0.212,Ds-> 0.249,Bplus-> 0.187,Bs-> 0.227,B0-> 0.191,Bc-> 0.48}];*)
(*MH=Association[{piplus-> 0.1396,pi0->0.135 ,Kplus-> 0.494,K0->0.498,eta-> 0.548,rho0->0.775,rhoplus->0.775,Dplus-> 1.87,D0-> 1.865,Ds-> 1.97,Dsstar-> 2.11,etac->2.98 ,Bplus-> 5.279,B0->5.279 ,Bs-> 5.37,Bc->6.28,Dplusstar->2.01,D0star->2.007, Kplusstar->0.892,K0star->0.892}];*)
(*MV=Association[{Kplus->0.892 ,Dplus->2.01,D0->2.01,Ds->2.11,Bplus->5.32,B0->5.32,Bs->5.415,Bc->6.33}];*)
(*MS=Association[{Kplus-> 1.43,Dplus->2.4,D0->2.4,Ds->2.32,Bplus->5.68,B0->5.68,Bs->5.68,Bc->6.42}];*)


(* ::Subsection::Closed:: *)
(*B->SuperStar[D]+N+l*)


(* ::Input:: *)
(*(*Form-factors*)*)
(*ParsDtoK = {1.03,0.76,0.66,0.49, 0.27,0.17,0.30,0.67,0,0,0.20, 0.16,1.969,2.112};*)
(*ParsBtoD = {0.76,0.69,0.66,0.62,0.57,0.59,0.78,1.40,0,0,0,0.41,6.275,6.331};*)
(*ParsBto\[Rho] = {0.295,0.231,0.269,0.282,0.875,0.796,0.54,1.34,0,0.055,0,-0.21,5.279,5.325};*)
(*ParsBstoDs = {0.95,0.67,0.70,0.75,0.372,0.350,0.463,1.04,0.561,0.600,0.510,0.070,6.275,6.331};*)
(*ParsBstoK = {0.291,0.289,0.287,0.286,-0.516,-0.383,0,1.05,2.10,1.58,1.06,-0.074,5.367,5.415};*)
(*ParsHtoV[H_,V_]:=Association[{{Dplus,K0star}-> ParsDtoK,{D0,Kplusstar}-> ParsDtoK,{Bplus,D0star}->ParsBtoD,{B0,Dplusstar}->ParsBtoD,{Bplus,rho0}->ParsBto\[Rho],{B0,rhoplus}->ParsBto\[Rho],{Bs,Dsstar}->ParsBstoDs,{Bs,Kplusstar}->ParsBstoK}][{H,V}]*)
(*DipoleForm[a_, b_, mhv_, q2_]:=1/(1-a q2/ (mhv^2)-b q2^2/ (mhv^4));*)
(*gVHtoV[H_, V_,q2_]:=ParsHtoV[H,V][[1]]/((1 - q2/ParsHtoV[H,V][[14]]^2)(MH[H]+ MH[V] )) DipoleForm[ParsHtoV[H,V][[5]], ParsHtoV[H,V][[9]],ParsHtoV[H,V][[14]], q2];*)
(*fVHtoV[H_, V_, q2_]:=(MH[H]+ MH[V] ) ParsHtoV[H,V][[3]]*DipoleForm[ParsHtoV[H,V][[7]], ParsHtoV[H,V][[11]],ParsHtoV[H,V][[14]],q2];*)
(*aplHtoV[H_, V_, q2_]:= -1/(MH[H]+ MH[V] ) ParsHtoV[H,V][[4]]*DipoleForm[ParsHtoV[H,V][[8]], ParsHtoV[H,V][[12]],ParsHtoV[H,V][[14]],q2];*)
(*aminHtoV[H_, V_, q2_]:= 1/q2 (2  MH[V] ParsHtoV[H,V][[2]]/(1 - q2/ParsHtoV[H,V][[13]]^2) DipoleForm[ParsHtoV[H,V][[6]],ParsHtoV[H,V][[10]],ParsHtoV[H,V][[14]], q2]- fVHtoV[H,V,q2]- (MH[H]^2- MH[V] ^2)aplHtoV[H,V,q2]);*)
(*(*Squared matrix elements*)*)
(*HadronicCurrentVectorPart=I*g*LeviCivita[\[Mu],\[Nu],\[Sigma],\[Rho]]*PolarizationVector[k1,\[Nu]]*FV[k+k1,\[Sigma]]*FV[k-k1,\[Rho]]//Contract;*)
(*HadronicCurrentAxialPart=f*PolarizationVector[k1,\[Mu]]+aplus*PolarizationVector[k1,\[Kappa]]*FV[k,\[Kappa]]*FV[k+k1,\[Mu]]+aminus*PolarizationVector[k1,\[Kappa]]*FV[k,\[Kappa]]*FV[k-k1,\[Mu]]//Contract;*)
(*MBdecay3Body=SpinorVBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorU[k3,m3](HadronicCurrentVectorPart-HadronicCurrentAxialPart)//Contract;*)
(*MBdecay3BodyStar=MBdecay3Body//ComplexConjugate;*)
(*MBdecay3BodySquaredTemp=((Simplify[Expand[DoPolarizationSums[FermionSpinSum[MBdecay3Body*MBdecay3BodyStar]/.DiracTrace->TR//Contract//Simplify,k1]]]/.{aminus->aminHtoV[Bplus, D0star, ScalarProduct[k-k1,k-k1]//ExpandScalarProduct],aplus->aplHtoV[Bplus, D0star, ScalarProduct[k-k1,k-k1]//ExpandScalarProduct],g->gVHtoV[Bplus, D0star, ScalarProduct[k-k1,k-k1]//ExpandScalarProduct],f->fVHtoV[Bplus, D0star, ScalarProduct[k-k1,k-k1]//ExpandScalarProduct] }//Contract)/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[ListHNLs[[1]],"B-3-body",mLLP_,E1_,E3_]=MBdecay3BodySquaredTemp/.{m->mSM["Bplus"],m1-> mSM["Dstar"],m2->mSM["e"],m3->mLLP}//Simplify;*)
(*Msquared3Body[ListHNLs[[2]],"B-3-body",mLLP_,E1_,E3_]=MBdecay3BodySquaredTemp/.{m->mSM["Bplus"],m1-> mSM["Dstar"],m2->mSM["mu"],m3->mLLP}//Simplify;*)
(*Msquared3Body[ListHNLs[[3]],"B-3-body",mLLP_,E1_,E3_]=MBdecay3BodySquaredTemp/.{m->mSM["Bplus"],m1-> mSM["Dstar"],m2->mSM["tau"],m3->mLLP}//Simplify;*)


(* ::Subsection::Closed:: *)
(*SuperPlus[D]->K^0+N+l*)


(* ::Input:: *)
(*(*Form-factors*)*)
(*fplus0[H_,H1_]:=Association[{*)
(*{Kplus,pi0}-> 0,*)
(*{Dplus,K0}-> 0.75,{D0,Kplus}-> 0.75,{Ds,eta}-> 0,*)
(*{Dplus,pi0}-> 0.61,{D0,piplus}-> 0.61,{Ds,K0}-> 0,*)
(*{Bplus,D0}-> 0.66,{B0,Dplus}-> 0.66,{Bs,Ds}-> 0.57,{Bc,etac}-> 0,*)
(*{Bplus,pi0}-> 0.27,{B0,piplus}-> 0.27,{Bs,Kplus}-> 0.323,{Bc,D0}-> 0, {Bc,B0}->-0.58,{Bc,Bs}->-0.61}][{H,H1}]*)
(*fplus[H_,H1_,q2_]:=fplus0[H,H1]/(1-q2/MV[H]^2);*)
(*fminus[H_,H1_,q2_]:=fplus0[H,H1] (((MH[H]^2-MH[H1]^2)(MV[H]^2-MS[H]^2))/((MS[H]^2-q2)(MV[H]^2-q2)));*)
(*(*Squared matrix elements*)*)
(*HadronicCurrentDvectorPart=fp*FV[k+k1,\[Mu]]+fm*FV[k-k1,\[Mu]];*)
(*MDdecay3Body=SpinorVBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorU[k3,m3]HadronicCurrentDvectorPart//Contract//ExpandScalarProduct;*)
(*MDdecay3BodyStar=MDdecay3Body//ComplexConjugate;*)
(*MDdecay3BodySquaredTemp=(Simplify[Expand[FermionSpinSum[MDdecay3Body*MDdecay3BodyStar]/.DiracTrace->TR//Contract//Simplify]/.{fp-> fplus[Dplus,K0,ScalarProduct[k-k1,k-k1]//ExpandScalarProduct],fm-> fminus[Dplus,K0,ScalarProduct[k-k1,k-k1]//ExpandScalarProduct]}]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[ListHNLs[[1]],"D-3-body",mLLP_,E1_,E3_]=MDdecay3BodySquaredTemp/.{m->mSM["Dplus"],m1-> mSM["K0"],m2->mSM["e"],m3->mLLP}//Simplify;*)
(*Msquared3Body[ListHNLs[[2]],"D-3-body",mLLP_,E1_,E3_]=MDdecay3BodySquaredTemp/.{m->mSM["Dplus"],m1-> mSM["K0"],m2->mSM["mu"],m3->mLLP}//Simplify;*)


(* ::Subsection::Closed:: *)
(*\[Tau] ->Subscript[\!\(\*OverscriptBox[\(\[Nu]\), \(_\)]\), l]+l+N*)


(* ::Input:: *)
(*M\[Tau]decay3Body=SpinorVBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorU[k1,m1]*SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]//Contract;*)
(*M\[Tau]decay3BodyStar=M\[Tau]decay3Body//ComplexConjugate;*)
(*M\[Tau]decay3BodySquaredTemp=(Simplify[Expand[1/2 FermionSpinSum[M\[Tau]decay3Body*M\[Tau]decay3BodyStar]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[ListHNLs[[3]],"\[Tau]-3-body",mLLP_,E1_,E3_]=M\[Tau]decay3BodySquaredTemp/.{m->mSM["tau"],m1->0,m2->mSM["e"],m3->mLLP}//Simplify;*)


(* ::Subsection::Closed:: *)
(*\[Mu] ->Subscript[\!\(\*OverscriptBox[\(\[Nu]\), \(_\)]\), e]+e+N/Subscript[\[Nu], \[Mu]]+e+N*)


(* ::Input:: *)
(*M\[Mu]decay3Body=SpinorVBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorU[k1,m1]*SpinorUBar[k3,m3] . GA[\[Mu]] . (1-GA5) . SpinorU[k,m]//Contract;*)
(*M\[Mu]decay3BodyStar=M\[Mu]decay3Body//ComplexConjugate;*)
(*M\[Mu]decay3BodySquaredTemp=(Simplify[Expand[1/2 FermionSpinSum[M\[Mu]decay3Body*M\[Mu]decay3BodyStar]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[ListHNLs[[2]],"mu",mLLP_,E1_,E3_]=M\[Mu]decay3BodySquaredTemp/.{m->mSM["mu"],m1->0,m2->mSM["e"],m3->mLLP}//Simplify;*)
(*M\[Mu]decay3Body=SpinorVBar[k2,m2] . GA[\[Mu]] . (1-GA5) . SpinorU[k3,m3]*SpinorVBar[k,m] . GA[\[Mu]] . (1-GA5) . SpinorV[k1,m1]//Contract;*)
(*(*M\[Mu]decay3Body=SpinorVBar[k3,m3].GA[\[Mu]].(1-GA5).SpinorU[k2,m2]*SpinorUBar[k1,m1].GA[\[Mu]].(1-GA5).SpinorU[k,m]//Contract;*)*)
(*M\[Mu]decay3BodyStar=M\[Mu]decay3Body//ComplexConjugate;*)
(*M\[Mu]decay3BodySquaredTemp=(Simplify[Expand[1/2 FermionSpinSum[M\[Mu]decay3Body*M\[Mu]decay3BodyStar]/.DiracTrace->TR//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[ListHNLs[[1]],"mu",mLLP_,E1_,E3_]=M\[Mu]decay3BodySquaredTemp/.{m->mSM["mu"],m1->0,m2->mSM["e"],m3->mLLP}//Simplify;*)


(* ::Section::Closed:: *)
(*Angle-energy distributions of LLPs if mother particle is at rest*)


(* ::Subsubsection::Closed:: *)
(*\[Mu] ->Subscript[\!\(\*OverscriptBox[\(\[Nu]\), \(_\)]\), e]+e+N/N+e+Subscript[\[Nu], \[Mu]]*)


(* ::Input:: *)
(*Do[EdistrTemp[HNL,"mu",mLLP_,E3_]=(Integrate[Msquared3Body[HNL,"mu",mLLP,E1,E3],E1]/.{E1->E1domain1[E3,mSM["mu"],0.,mSM["e"],mLLP][[2]]})-(Integrate[Msquared3Body[HNL,"mu",mLLP,E1,E3],E1]/.{E1->E1domain1[E3,mSM["mu"],0.,mSM["e"],mLLP][[1]]})//Simplify;*)
(*WidthNorm[HNL,"mu",mLLP_]=Interpolation[ParallelTable[With[{m=mLLP},{m,If[m==mSM["mu"],0.,Quiet[NIntegrate[EdistrTemp[HNL,"mu",m,E3],{E3,E3domain1[mSM["mu"],0,mSM["e"],m][[1]],E3domain1[mSM["mu"],0,mSM["e"],m][[2]]}]]]//Re}],{mLLP,0.,mSM["mu"],mSM["mu"]/300.}],InterpolationOrder->1][mLLP];*)
(*\[Theta]EdistrRest[HNL,"mu",mLLP_,\[Theta]LLP_,ELLP_]=If[mLLP<=ELLP<=E3domain1[mSM["mu"],0,mSM["e"],mLLP][[2]],Evaluate[Sin[\[Theta]LLP]/2 EdistrTemp[HNL,"mu",mLLP,ELLP]/WidthNorm[HNL,"mu",mLLP]],0];*)
(*,{HNL,Drop[ListHNLs,-1]}]*)


(* ::Subsection::Closed:: *)
(*\[Pi] -> N + l *)


(* ::Input:: *)
(*Do[*)
(*mlv=If[HNL=="HNL-mixing-e",0.5*10^-3,0.105];*)
(*\[CapitalDelta]Eapprox=10^-5.;*)
(*\[Theta]EdistrRest[HNL,"PiCharged",mLLP_,\[Theta]LLP_,ELLP_]=If[(mSM["PiCharged"]^2-mlv^2+mLLP^2)/(2mSM["PiCharged"])-\[CapitalDelta]Eapprox/2<=ELLP<=(mSM["PiCharged"]^2-mlv^2+mLLP^2)/(2mSM["PiCharged"])+\[CapitalDelta]Eapprox/2,Evaluate[1/\[CapitalDelta]Eapprox Sin[\[Theta]LLP]/2],0];*)
(*,{HNL,Drop[ListHNLs,-1]}]*)


(* ::Chapter::Closed:: *)
(*ALP-gluon*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*(*List of processes*)*)
(*LLPname="ALP-gluon";*)
(*(*There are production channels via mixing with neutral light mesons, ##-mixing. Drell-Yan is computed externally (MadGraph+pythia)*)*)
(*ProcessesListAll[LLPname]={"B","Mixing-Pi0-Old","Mixing-Eta-Old","Mixing-EtaPr-Old"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Mixing","Mixing","Mixing"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","PiCharged",LLPname},{"Pi0",LLPname},{"Eta",LLPname},{"EtaPr",LLPname}}}];*)
(*LLPname//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*ALP-photon*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*(*List of processes*)*)
(*LLPname="ALP-photon";*)
(*(*There are production channels via scattering of protons or photons, called "photon fusion" and "Primakov"*)*)
(*ProcessesListAll[LLPname]={"Pi0","Eta","Primakov","Photon-fusion"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Decay","Scattering","Scattering"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Pi0","photon","photon",LLPname},{"Eta","photon","photon",LLPname},{"photon",LLPname},{"p",LLPname}}}];*)
(*(*____________________________________*)*)
(*(*List of possible nuclei targets depending on the facility*)*)
(*(*____________________________________*)*)
(*NucleiList["SPS","Primakov"]=NucleiList["SPS","Photon-fusion"]={"Mo","Fe","C"};*)
(*NucleiList["FermilabBD","Primakov"]=NucleiList["FermilabBD","Photon-fusion"]={"Fe","C"};*)
(*NucleiList["Serpukhov","Primakov"]=NucleiList["Serpukhov","Photon-fusion"]={"Fe"};*)
(*(*For LHC: colliding of photons with TAX. Relevant only for FASER/FASER2*)*)
(*NucleiList["LHC","Primakov"]={"Fe"};*)
(*NucleiList["LHC","Photon-fusion"]=NucleiList["FCC-hh","Photon-fusion"]={"p"};*)


(* ::Section::Closed:: *)
(*Matrix elements of 3-body decays*)


(* ::Subsection::Closed:: *)
(*Decay of \[Pi]^0/\[Eta]*)


(* ::Input:: *)
(*LLPname="ALP-photon";*)
(*(*3-body decays \[Pi]^0/\[Eta] -> ALP+\[Gamma]+\[Gamma]*)*)
(*FileM2ALPprod=FileNameJoin[{NotebookDirectory[],"phenomenology/"<>LLPname<>"/Production-probabilities/M2Pi0Eta.mx"}];*)
(*If[!FileExistsQ[FileM2ALPprod],*)
(*FFvac[p_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=(-FV[p,\[Mu]]*FV[p,\[Alpha]]*MT[\[Nu],\[Beta]]-FV[p,\[Nu]]*FV[p,\[Beta]]*MT[\[Mu],\[Alpha]]+FV[p,\[Mu]]*FV[p,\[Beta]]*MT[\[Nu],\[Alpha]]+FV[p,\[Nu]]*FV[p,\[Alpha]]*MT[\[Mu],\[Beta]])/ScalarProduct[p,p]//ExpandScalarProduct;*)
(*FFfinal[p\[Gamma]1_,p\[Gamma]2_,\[Mu]_,\[Nu]_,\[Alpha]_,\[Beta]_]:=(FV[p\[Gamma]1,\[Mu]]*PolarizationVector[p\[Gamma]1,\[Nu]]-FV[p\[Gamma]1,\[Nu]]*PolarizationVector[p\[Gamma]1,\[Mu]])*(FV[p\[Gamma]2,\[Alpha]]*PolarizationVector[p\[Gamma]2,\[Beta]]-FV[p\[Gamma]2,\[Beta]]*PolarizationVector[p\[Gamma]2,\[Alpha]]);*)
(*ScalarProduct[p\[Gamma]2,p\[Gamma]2]=ScalarProduct[p\[Gamma]1,p\[Gamma]1]=0;*)
(*MdecayMesonToALPphoton=(1/4 ga\[Gamma]\[Gamma]*g\[Pi]\[Gamma]\[Gamma]*2*LeviCivita[\[Mu]1,\[Nu]1,\[Mu]2,\[Nu]2]*LeviCivita[\[Mu]3,\[Nu]3,\[Mu]4,\[Nu]4](FFvac[p\[Gamma]2+p3,\[Mu]1,\[Nu]1,\[Mu]2,\[Nu]2]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]3,\[Nu]3,\[Mu]4,\[Nu]4]+FFvac[p\[Gamma]2+p3,\[Mu]1,\[Nu]1,\[Mu]3,\[Nu]3]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]2,\[Nu]2,\[Mu]4,\[Nu]4]+FFvac[p\[Gamma]2+p3,\[Mu]1,\[Nu]1,\[Mu]4,\[Nu]4]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]3,\[Nu]3,\[Mu]2,\[Nu]2]+FFvac[p\[Gamma]2+p3,\[Mu]2,\[Nu]2,\[Mu]3,\[Nu]3]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]1,\[Nu]1,\[Mu]4,\[Nu]4]+FFvac[p\[Gamma]2+p3,\[Mu]3,\[Nu]3,\[Mu]4,\[Nu]4]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]1,\[Nu]1,\[Mu]2,\[Nu]2]+FFvac[p\[Gamma]2+p3,\[Mu]2,\[Nu]2,\[Mu]4,\[Nu]4]*FFfinal[p\[Gamma]1,p\[Gamma]2,\[Mu]1,\[Nu]1,\[Mu]3,\[Nu]3])//Contract//Simplify);*)
(*MdecayMesonToALPphotonSquared=(DoPolarizationSums[DoPolarizationSums[MdecayMesonToALPphoton*ComplexConjugate[MdecayMesonToALPphoton],p\[Gamma]1,0],p\[Gamma]2,0]//Contract//Simplify)/.{ScalarProduct[p3,p3]->ProductK3K3,ScalarProduct[p\[Gamma]2,p\[Gamma]2]->ProductK2K2,ScalarProduct[p\[Gamma]1,p\[Gamma]1]->ProductK1K1,ScalarProduct[p\[Gamma]2,p3]->ProductK2K3energy,ScalarProduct[p\[Gamma]1,p3]->ProductK1K3energy,ScalarProduct[p\[Gamma]1,p\[Gamma]2]-> ProductK1K2energy}/.{m1->0,m2->0,m3->ma,m->mmeson}//Simplify;*)
(*Msquared3Body[LLPname,"Pi0",mLLP_,E1_,E3_]=MdecayMesonToALPphotonSquared/.{mmeson->mSM["Pi0"],ma->mLLP,ga\[Gamma]\[Gamma]->1,g\[Pi]\[Gamma]\[Gamma]->1};*)
(*Msquared3Body[LLPname,"Eta",mLLP_,E1_,E3_]=MdecayMesonToALPphotonSquared/.{mmeson->mSM["Eta"],ma->mLLP,ga\[Gamma]\[Gamma]->1,g\[Pi]\[Gamma]\[Gamma]->1};*)
(*Export[FileM2ALPprod,{Msquared3Body[LLPname,"Pi0",mLLP,E1,E3],Msquared3Body[LLPname,"Eta",mLLP,E1,E3]},"MX"]*)
(*,*)
(*{Msquared3Body[LLPname,"Pi0",mLLP_,E1_,E3_],Msquared3Body[LLPname,"Eta",mLLP_,E1_,E3_]}=Import[FileM2ALPprod,"MX"];*)
(*]*)
(*LLPname//Clear*)


(* ::Section::Closed:: *)
(*Primakov cross-section*)


(* ::Subsection::Closed:: *)
(*Kinematics*)


(* ::Input:: *)
(*sinv[E\[Gamma]_,mt_]=2*mt*E\[Gamma]+mt^2;*)
(*tmin[ma_,E\[Gamma]_,mt_]=ma^4/(4*sinv[E\[Gamma],mt])-((sinv[E\[Gamma],mt]-mt^2)/(2*Sqrt[sinv[E\[Gamma],mt]])+Sqrt[(sinv[E\[Gamma],mt]+ma^2-mt^2)^2/(4*sinv[E\[Gamma],mt])-ma^2])^2;*)
(*tmaxTemp[ma_,E\[Gamma]_,mt_]=ma^4/(4*sinv[E\[Gamma],mt])-((sinv[E\[Gamma],mt]-mt^2)/(2*Sqrt[sinv[E\[Gamma],mt]])-Sqrt[(sinv[E\[Gamma],mt]+ma^2-mt^2)^2/(4*sinv[E\[Gamma],mt])-ma^2])^2;*)
(*tmaxLimit[ma_,E\[Gamma]_]=Assuming[E\[Gamma]>0&&mt>0,Simplify[Normal@Series[tmaxTemp[ma,E\[Gamma],mt],{ma,0,4}]]];*)
(*tmax[ma_,E\[Gamma]_,mt_]=If[ma/E\[Gamma]>0.01,Evaluate[tmaxTemp[ma,E\[Gamma],mt]],Evaluate[tmaxLimit[ma,E\[Gamma]]]];*)
(*Print["Expression for \!\(\*SubscriptBox[\(E\), \(a\)]\) in terms of \!\(\*SubscriptBox[\(E\), \(\[Gamma]\)]\),\!\(\*SubscriptBox[\(m\), \(T\)]\),\!\(\*SuperscriptBox[\(q\), \(2\)]\) = -t:"]*)
(*(*Expression for the squared momentum transfer evaluated via -q^2 = (Subscript[p, \[Nu]]-Subscript[p, N])^2. Depends on Subscript[E, \[Nu]],Subscript[E, N],cos(Subscript[\[Theta], \[Nu]N])*)*)
(*Q2p\[Nu]pN[E\[Gamma]_,Ea_,ma_,cos\[Theta]_]=-(ma^2-2*Ea*E\[Gamma]+2*\[Sqrt](Ea^2-ma^2)*E\[Gamma]*cos\[Theta]);*)
(*(*Expression for the squared momentum transfer evaluated via -q^2 = (Subscript[p, T']-Subscript[p, T])^2. Depends on Subscript[E, T] = Subscript[m, T], Subscript[E, T'] = Subscript[E, \[Gamma]]+Subscript[m, T]-Subscript[E, a]*)*)
(*Q2pTprimepT[E\[Gamma]_,Ea_,ma_,mT_]=-(2mT^2-2*mT(E\[Gamma]+mT-Ea));*)
(*(*cos\[Theta] expressed via q^2, Subscript[E, \[Nu]],Subscript[E, N]*)*)
(*cos\[Theta]\[Gamma]a[q2_,E\[Gamma]_,Ea_,ma_]=cos\[Theta]/.Solve[Q2p\[Nu]pN[E\[Gamma],Ea,ma,cos\[Theta]]==q2,cos\[Theta]][[1]];*)
(*(*Finally, expression for Subscript[E, N] in terms of Subscript[E, \[Nu]],Subscript[m, T],q^2*)*)
(*EavalE\[Gamma]q2[E\[Gamma]_,q2_,mT_]=Ea/.Solve[Q2p\[Nu]pN[E\[Gamma],Ea,ma,cos\[Theta]\[Gamma]a[q2,E\[Gamma],Ea,ma]]==Q2pTprimepT[E\[Gamma],Ea,ma,mT],Ea][[1]]*)
(*Print["Jacobian \!\(\*SuperscriptBox[\(Q\), \(2\)]\)\[Rule] \!\(\*SubscriptBox[\(E\), \(N\)]\):"]*)
(*JacobianQ2E\[Gamma]ToEaE\[Gamma][E\[Gamma]_,mT_,ma_]=-(D[Q2pTprimepT[E\[Gamma],Ea,ma,mT],Ea]*D[E\[Gamma],E\[Gamma]]-D[Q2pTprimepT[E\[Gamma],Ea,ma,mT],E\[Gamma]]*D[E\[Gamma],Ea])*)
(*Print["\!\(\*SubscriptBox[\(E\), \(N, min\)]\),\!\(\*SubscriptBox[\(E\), \(N, max\)]\) in terms of \!\(\*SubscriptBox[\(E\), \(\[Nu]\)]\): obtained as \!\(\*SubscriptBox[\(E\), \(N\)]\)(\!\(\*SuperscriptBox[\(q\), \(2\)]\) = (\!\(\*SuperscriptBox[\(q\), \(2\)]\)\!\(\*SubscriptBox[\()\), \(max\)]\)),\!\(\*SubscriptBox[\(E\), \(N\)]\)(\!\(\*SuperscriptBox[\(q\), \(2\)]\) = (\!\(\*SuperscriptBox[\(q\), \(2\)]\)\!\(\*SubscriptBox[\()\), \(min\)]\))"]*)
(*Eamin[E\[Gamma]_,mT_,ma_]=Assuming[E\[Gamma]>E\[Gamma]min[mT,ma]&&mT>0&&ma>0,Simplify[EavalE\[Gamma]q2[E\[Gamma],-tmin[ma,E\[Gamma],mT],mT]]]*)
(*Eamax[E\[Gamma]_,mT_,ma_]=EavalE\[Gamma]q2[E\[Gamma],-tmaxTemp[ma,E\[Gamma],mT],mT]//Simplify*)
(*EamaxLimit[E\[Gamma]_,mT_,ma_]=Assuming[E\[Gamma]>0&&mT>0,Simplify[Normal@Series[Eamax[E\[Gamma],mT,ma],{ma,0,4}]]];*)
(*EamaxNumeric[E\[Gamma]_,mT_,ma_]=If[ma/E\[Gamma]>10^-3,Eamax[E\[Gamma],mT,ma],EamaxLimit[E\[Gamma],mT,ma]];*)
(*E\[Gamma]min[ma_,mt_]=(ma^2+2*mt*ma)/(2*mt);*)


(* ::Subsection::Closed:: *)
(*Primakov cross-section*)


(* ::Input:: *)
(*(*Differential cross sections from https://arxiv.org/pdf/2010.15712.pdf+https://arxiv.org/pdf/1903.03586.pdf*)*)
(*d\[Sigma]PrimakovdtNucleus[ma_,t_,E\[Gamma]_,mNucleus_,Anucleus_,Znucleus_]=(2*\[Alpha]EM*FHelm[-t,Anucleus,Znucleus]^2*mNucleus^4/(t^2*(mNucleus^2-s)^2 (t-4*mNucleus^2)^2) (ma^2*t(mNucleus^2+s)-ma^4 mNucleus^2-t*((mNucleus^2-s)^2+s*t))/.{s->sinv[E\[Gamma],mNucleus]}//Simplify)/.{\[Alpha]EM->\[Alpha]EMval};*)
(*d\[Sigma]PrimakovdEaNucleus[ma_,Ea_,E\[Gamma]_,mNucleus_,Anucleus_,Znucleus_]=JacobianQ2E\[Gamma]ToEaE\[Gamma][E\[Gamma],mNucleus,ma]*d\[Sigma]PrimakovdtNucleus[ma,-Q2pTprimepT[E\[Gamma],Ea,ma,mNucleus],E\[Gamma],mNucleus,Anucleus,Znucleus];*)
(*d\[Sigma]PrimakovdtNucleons[ma_,t_,E\[Gamma]_,Znucleus_]=(Znucleus*\[Alpha]EM)/(32*mp^2*t^2 (mp^2-s)^2) (2*mp^2 (2*ma^2*t(mp^2+s+t)-ma^4*(2*mp^2+t)-t*(2*(mp^2-s)^2+2*s*t+t^2))*F1[-t]^2+F1[-t]*F2[-t]*t*(t*(mp^4-2*mp^2*(s+t)+s*(s+t))+t*ma^2*(3*mp^2-s)-ma^4 mp^2)+F2[-t]^2*4*mp^2*t (ma^2-t)^2)/.{s->sinv[E\[Gamma],mp]}/.{\[Alpha]EM->\[Alpha]EMval,mp->mSM["p"]};*)
(*q2maxEff[Anucleus_]=20(4.49/R1[Anucleus])^2;*)
(*(*\[Sigma]PrimakovNucleus1[ma_,E\[Gamma]_,mNucleus_,Anucleus_,Znucleus_]:=If[E\[Gamma]>E\[Gamma]min[ma,mNucleus], NIntegrate[d\[Sigma]PrimakovdtNucleus[ma,t,E\[Gamma],mNucleus,Anucleus,Znucleus],{t,Max[tmin[ma,E\[Gamma],mNucleus],-q2maxEff[Anucleus]],tmax[ma,E\[Gamma],mNucleus]}],0.]*)*)
(*\[Sigma]PrimakovNucleus[ma_,E\[Gamma]_,mNucleus_,Anucleus_,Znucleus_]:=If[E\[Gamma]>E\[Gamma]min[ma,mNucleus], NIntegrate[-Exp[u]*d\[Sigma]PrimakovdtNucleus[ma,-Exp[u],E\[Gamma],mNucleus,Anucleus,Znucleus],{u,Log[-tmin[ma,E\[Gamma],mNucleus]],Log[-tmax[ma,E\[Gamma],mNucleus]]}],0.]*)
(*(*EaminEffective[E\[Gamma]_,mT_,Anucleus_]=EavalE\[Gamma]q2[E\[Gamma],q2maxEff[Anucleus],mT];*)
(*EaminNumeric[E\[Gamma]_,mT_,ma_,Anucleus_]=If[ma/E\[Gamma]>0.05,Eamin[E\[Gamma],mT,ma],EaminEffective[E\[Gamma],mT,Anucleus]];*)
(*\[Sigma]PrimakovNucleusAlt[ma_,E\[Gamma]_,mNucleus_,Anucleus_,Znucleus_]:=If[E\[Gamma]>E\[Gamma]min[ma,mMo], NIntegrate[d\[Sigma]PrimakovdEaNucleus[ma,Ea,E\[Gamma],mNucleus,Anucleus,Znucleus],{Ea,EaminNumeric[E\[Gamma],mNucleus,ma,Anucleus],EamaxNumeric[E\[Gamma],mNucleus,ma]}],0.]*)*)
(*\[Sigma]PrimakovNucleons[ma_,E\[Gamma]_,Znucleus_]:=If[E\[Gamma]>E\[Gamma]min[ma,mSM["p"]],NIntegrate[d\[Sigma]PrimakovdtNucleons[ma,t,E\[Gamma],Znucleus],{t,tmin[ma,E\[Gamma],mSM["p"]],tmax[ma,E\[Gamma],mSM["p"]]}],0.]*)
(*(*Table[{E\[Gamma],\[Sigma]PrimakovNucleusAlt[1,E\[Gamma]],\[Sigma]PrimakovNucleus[1,E\[Gamma]]},{E\[Gamma],3,200,10}];*)*)


(* ::Section::Closed:: *)
(*Photon fusion (following Felix and https://arxiv.org/abs/1512.03069)*)


(* ::Subsection::Closed:: *)
(*Effective maximal and minimal energy fractions of equivalent photons *)


(* ::Input:: *)
(*(*Effective maximal Subscript[p, T] of photons from protons and nucleus*)*)
(*q2nucleusMax[Anucleus_]=(4.49/R1[Anucleus])^2;*)
(*q2pMax=1;*)
(*pTmaxEPA[x_,m_,q2max_]=Sqrt[pT2/.Assuming[0<x<1,Solve[q2pTxVal[x,Sqrt[pT2],m]==q2max,pT2]][[1]]];*)
(*pTminEPA[x_,m_,q2min_]=pTmaxEPA[x,m,q2min];*)
(*xminmaxEPA[m_,q2max_]=x/.Solve[pTmaxEPA[x,m,q2max]==0,x][[2]];*)
(*pTprotonMaxEPA[x_]=pTmaxEPA[x,mSM["p"],q2pMax];*)
(*pTnucleusMaxEPA[x_,mNucleus_,Anucleus_]=pTmaxEPA[x,mNucleus,q2nucleusMax[Anucleus]];*)
(*(*Minimal momentum transfer - for smaller transfers, the nucleus is screened by electrons*)*)
(*q2nucleusMin=(10^-5.)^2;*)
(*pTnucleusMinEPA[mNucleus_]=pTmaxEPA[x,mNucleus,q2nucleusMin]/.{x->0};*)
(*xminNucleusEPA[mNucleus_]=xminmaxEPA[mNucleus,q2nucleusMin];*)
(*\[Epsilon]Regularization=10^-9.;*)


(* ::Subsection::Closed:: *)
(*Differential cross-section - beam dumps*)


(* ::Input:: *)
(*(*CM kinematics of proton-target collisions at beam dump*)*)
(*vLabToCM[EpLab_,MP_,mNucleus_]=v/.Solve[Sqrt[EpLab^2-MP^2]-v*EpLab==mNucleus*v,v][[1]];*)
(*pCMprotonZ[EpLab_,MP_,mNucleus_]=Assuming[EpLab>0&&mNucleus>0,Simplify[(Sqrt[EpLab^2-MP^2]-vLabToCM[EpLab,MP,mNucleus]*EpLab)/Sqrt[1-vLabToCM[EpLab,MP,mNucleus]^2]]];*)
(*EpCMvalBD[EpLab_,mNucleus_]=Sqrt[pCMprotonZ[EpLab,mSM["p"],mNucleus]^2+mSM["p"]^2];*)
(*EnucleusCMvalBD[EpLab_,mNucleus_]=Sqrt[pCMprotonZ[EpLab,mSM["p"],mNucleus]^2+mNucleus^2];*)
(*(*Solutions for energy fractions Subscript[x, 1],Subscript[x, 2] carried by photons from protons and the nucleus Z in terms of the ALP mass and its transverse momentum*)*)
(*max1x2[x1_,x2_,EpCM_,EnucleusCM_]=2 Sqrt[x1*x2]*Sqrt[EpCM*EnucleusCM];*)
(*kzx1x2[x1_,x2_,EpCM_,EnucleusCM_]=x1*EpCM-x2*EnucleusCM;*)
(*sols[kzCM_,ma_,EpCM_,EnucleusCM_]=Assuming[ma>0&&kZ>0&&EpCM>0&&kzCM>0&&EnucleusCM>0,Simplify[Solve[{max1x2[x1,x2,EpCM,EnucleusCM]==ma&&kzx1x2[x1,x2,EpCM,EnucleusCM]==kzCM},{x1,x2}]]][[2]];*)
(*{xpkz[kzCM_,ma_,EpCM_],xNucleuskz[kzCM_,ma_,EnucleusCM_]}={x1/.sols[kzCM,ma,EpCM,EnucleusCM],x2/.sols[kzCM,ma,EpCM,EnucleusCM]};*)
(*(*differential cross section d\[Sigma]/Subscript[dk, T]Subscript[dk, Z]Subscript[dp, T,1]Subscript[dp, T,2]*)*)
(*IntegrandFusionBeamDumpCMframe[ma_,kzCM_,kT_,pT1_,pT2_,EpCM_,EnucleusCM_,mNucleus_,Anucleus_,Znucleus_]=2*kT*2*pT1*2*pT2*ma^2/(32*EpCM*EnucleusCM Sqrt[kzCM^2+ma^2]) ((fEPAp[pT1,xpkz[kzCM,ma,EpCM],\[Alpha]EMval]*fEPAnucleus[pT2,xNucleuskz[kzCM,ma,EnucleusCM],\[Alpha]EMval,mNucleus,Anucleus,Znucleus])/(Sqrt[2*kT^2 (pT1^2+pT2^2)-kT^4-(pT1^2-pT2^2)^2]));*)
(*(*Jacobian of transformation Subscript[k, z,CM],Subscript[k, T] \[Rule] Subscript[E, a],Subscript[\[Theta], a]*)*)
(*kTto\[Theta]a[ma_,\[Theta]a_,Ea_]=Sqrt[Ea^2-ma^2]*Sin[\[Theta]a];*)
(*kzCMtoEa[ma_,\[Theta]a_,Ea_,EpLab_,mNucleus_]=(Sqrt[Ea^2-ma^2-kTto\[Theta]a[ma,\[Theta]a,Ea]^2]-vLabToCM[EpLab,mSM["p"],mNucleus]*Ea)/Sqrt[1-vLabToCM[EpLab,mSM["p"],mNucleus]^2];*)
(*JacobiankzCMkTto\[Theta]aEa[ma_,\[Theta]a_,Ea_,EpLab_,mNucleus_]=(D[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],\[Theta]a]*D[kTto\[Theta]a[ma,\[Theta]a,Ea],Ea]-D[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],Ea]*D[kTto\[Theta]a[ma,\[Theta]a,Ea],\[Theta]a])//Simplify*)
(*(*Differential probability d^2P/Subscript[d\[Theta], a]Subscript[dE, a]*)*)
(*IntegrandFusionBeamDump[ma_,\[Theta]a_,Ea_,pT1_,pT2_,EpLab_,mNucleus_,Anucleus_,Znucleus_]=Abs[JacobiankzCMkTto\[Theta]aEa[ma,\[Theta]a,Ea,EpLab,mNucleus]]*IntegrandFusionBeamDumpCMframe[ma,kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],kTto\[Theta]a[ma,\[Theta]a,Ea],pT1,pT2,EpCMvalBD[EpLab,mNucleus],EnucleusCMvalBD[EpLab,mNucleus],mNucleus,Anucleus,Znucleus];*)


(* ::Subsubsection::Closed:: *)
(*Explicit form (with all parameters inserted)*)


(* ::Input:: *)
(*Do[*)
(*Module[{Z,Facility},*)
(*Z=z;*)
(*Facility=facility;*)
(*IntegrandFusionTemp[ma_,\[Theta]a_,Ea_,pT1_,pT2_,Facility,Z]=IntegrandFusionBeamDump[ma,\[Theta]a,Ea,pT1,pT2,EmaxFacility[Facility],mnucleus[Z],anucleus[Z],znucleus[Z]];*)
(*IntegrandFusion[ma_,\[Theta]a_,Ea_,pT1_,pT2_,Facility,Z]=If[Abs[pT1-pT2](1+\[Epsilon]Regularization)<kTto\[Theta]a[ma,\[Theta]a,Ea]<(pT1+pT2)(1-\[Epsilon]Regularization),Evaluate[IntegrandFusionTemp[ma,\[Theta]a,Ea,pT1,pT2,Facility,Z]],0.];*)
(*{xpkzExpl[ma_,\[Theta]a_,Ea_,Facility,Z],xNucleuskzExpl[ma_,\[Theta]a_,Ea_,Facility,Z],pTprotonMaxEPAexpl[ma_,\[Theta]a_,Ea_,Facility,Z],pTnucleusMaxEPAexpl[ma_,\[Theta]a_,Ea_,Facility,Z]}={xpkz[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],ma,EpCMvalBD[EpLab,mNucleus]],xNucleuskz[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],ma,EnucleusCMvalBD[EpLab,mNucleus]],pTprotonMaxEPA[xpkz[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],ma,EpCMvalBD[EpLab,mNucleus]]],pTnucleusMaxEPA[xNucleuskz[kzCMtoEa[ma,\[Theta]a,Ea,EpLab,mNucleus],ma,EnucleusCMvalBD[EpLab,mNucleus]],mNucleus,Anucleus]}/.{mNucleus->mnucleus[Z],EpLab->EmaxFacility[Facility],Anucleus->anucleus[Z]};*)
(*(*Converting the integrand to the variables m = (Subscript[p, T,1]+Subscript[p, T,2]),t=(Subscript[p, T,1]-Subscript[p, T,2])*)*)
(*tmax[ma_,\[Theta]a_,Ea_,Facility,Z]=Min[kTto\[Theta]a[ma,\[Theta]a,Ea],(pTprotonMaxEPAexpl[ma,\[Theta]a,Ea,Facility,Z]-pTnucleusMinEPA[mnucleus[Z]])];*)
(*tmin[ma_,\[Theta]a_,Ea_,Facility,Z]=-Min[pTnucleusMaxEPAexpl[ma,\[Theta]a,Ea,Facility,Z],kTto\[Theta]a[ma,\[Theta]a,Ea]];*)
(*mmax[ma_,\[Theta]a_,Ea_,Facility,Z]=(pTprotonMaxEPAexpl[ma,\[Theta]a,Ea,Facility,Z]+pTnucleusMaxEPAexpl[ma,\[Theta]a,Ea,Facility,Z]);*)
(*mmin[ma_,\[Theta]a_,Ea_,Facility,Z]=Max[pTnucleusMinEPA[mnucleus[Z]],kTto\[Theta]a[ma,\[Theta]a,Ea]];*)
(*IntegrandFusionConverted[ma_,\[Theta]a_,Ea_,m_,t_,Facility,Z]=1/2 IntegrandFusion[ma,\[Theta]a,Ea,(m+t)/2,(m-t)/2,Facility,Z][[2]];*)
(*\[Epsilon]v=10^-9;*)
(*(*d2\[Sigma]d\[Theta]adEaFusionFast[ma_,\[Theta]a_,Ea_,Facility,Z]:=With[{MMAX=mmax[ma,\[Theta]a,Ea,Facility,Z],MMIN=mmin[ma,\[Theta]a,Ea,Facility,Z]},GeVm2Topb*If[ma<Ea&&xpkzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mSM["p"],q2pMax]&&xminNucleusEPA[mnucleus[Z]]<*)
(*xNucleuskzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mnucleus[Z],q2nucleusMax[anucleus[Z]]]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted[ma,\[Theta]a,Ea,Exp[m],t,Facility,Z]Exp[m],{t,(1-\[Epsilon]Regularization)tmin[ma,\[Theta]a,Ea,Facility,Z],(1-\[Epsilon]Regularization)tmax[ma,\[Theta]a,Ea,Facility,Z]},{m,Log[(1+\[Epsilon]Regularization)MMIN],Log[MMAX]},Method->"AdaptiveMonteCarlo"],0.]];*)
(*d2\[Sigma]d\[Theta]adEaFusionSlow[ma_,\[Theta]a_,Ea_,Facility,Z]:=With[{MMAX=mmax[ma,\[Theta]a,Ea,Facility,Z],MMIN=mmin[ma,\[Theta]a,Ea,Facility,Z]},GeVm2Topb*If[ma<Ea&&xpkzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mSM["p"],q2pMax]&&xminNucleusEPA[mnucleus[Z]]<*)
(*xNucleuskzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mnucleus[Z],q2nucleusMax[anucleus[Z]]]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted[ma,\[Theta]a,Ea,Exp[m],t,Facility,Z]Exp[m],{t,(1-\[Epsilon]Regularization)tmin[ma,\[Theta]a,Ea,Facility,Z],(1-\[Epsilon]Regularization)tmax[ma,\[Theta]a,Ea,Facility,Z]},{m,Log[(1+\[Epsilon]Regularization)MMIN],Log[MMAX]}],0.]];*)*)
(*d2\[Sigma]d\[Theta]adEaFusion[ma_,\[Theta]a_,Ea_,Facility,Z]:=With[{MMAX=mmax[ma,\[Theta]a,Ea,Facility,Z],MMIN=mmin[ma,\[Theta]a,Ea,Facility,Z]},GeVm2Topb*If[ma<Ea&&xpkzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mSM["p"],q2pMax]&&xminNucleusEPA[mnucleus[Z]]<*)
(*xNucleuskzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mnucleus[Z],q2nucleusMax[anucleus[Z]]]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted[ma,\[Theta]a,Ea,Exp[m],t,Facility,Z]Exp[m],{t,(1-\[Epsilon]v)tmin[ma,\[Theta]a,Ea,Facility,Z],(1-\[Epsilon]v)tmax[ma,\[Theta]a,Ea,Facility,Z]},{m,Log[(1+\[Epsilon]v)MMIN],Log[MMAX]},Method->"DoubleExponential"],0.]];*)
(*d2\[Sigma]d\[Theta]adEaFusion1[ma_,\[Theta]a_,Ea_,Facility,Z]:=With[{MMAX=mmax[ma,\[Theta]a,Ea,Facility,Z],MMIN=mmin[ma,\[Theta]a,Ea,Facility,Z]},GeVm2Topb*If[ma<Ea&&xpkzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mSM["p"],q2pMax]&&xminNucleusEPA[mnucleus[Z]]<*)
(*xNucleuskzExpl[ma,\[Theta]a,Ea,Facility,Z]<xminmaxEPA[mnucleus[Z],q2nucleusMax[anucleus[Z]]]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted[ma,\[Theta]a,Ea,m,t,Facility,Z],{t,(1-\[Epsilon]v)tmin[ma,\[Theta]a,Ea,Facility,Z],(1-\[Epsilon]v)tmax[ma,\[Theta]a,Ea,Facility,Z]},{m,(1+\[Epsilon]v)MMIN,MMAX},Method->"DoubleExponential"],0.]];*)
(*(*Because of numeric inaccuracy, Mathematica will return some imaginary part. This is omitted by taking Re*)*)
(*d2Pd\[Theta]adEaFusion[ma_,\[Theta]a_,Ea_,Facility,Z]:=If[Ea>ma,Re[d2\[Sigma]d\[Theta]adEaFusion[ma,\[Theta]a,Ea,Facility,Z]/\[Sigma]pNucleus[Z]],0.];*)
(*d2Pd\[Theta]adEaFusion1[ma_,\[Theta]a_,Ea_,Facility,Z]:=If[Ea>ma,Re[d2\[Sigma]d\[Theta]adEaFusion1[ma,\[Theta]a,Ea,Facility,Z]/\[Sigma]pNucleus[Z]],0.];*)
(*(*d2Pd\[Theta]adEaFusionSlow[ma_,\[Theta]a_,Ea_,Facility,Z]:=If[Ea>ma,d2\[Sigma]d\[Theta]adEaFusionSlow[ma,\[Theta]a,Ea,Facility,Z]/\[Sigma]pNucleus[Z],0.];*)
(*d2Pd\[Theta]adEaFusionFast[ma_,\[Theta]a_,Ea_,Facility,Z]:=If[Ea>ma,d2\[Sigma]d\[Theta]adEaFusionFast[ma,\[Theta]a,Ea,Facility,Z]/\[Sigma]pNucleus[Z],0.];*)*)
(**)
(*];*)
(*,{z,{"Fe","Mo","C"}},{facility,{"SPS","FermilabBD","Serpukhov"}}]*)
(*Quiet[d2Pd\[Theta]adEaFusion[1,10^-4.,100,"SPS","Mo"]]//AbsoluteTiming*)
(*(*Quiet[d2Pd\[Theta]adEaFusionSlow[0.02,10^-4.,10,"SPS","Mo"]]//AbsoluteTiming*)
(*Quiet[d2Pd\[Theta]adEaFusionFast[0.02,10^-4.,10,"SPS","Mo"]]//AbsoluteTiming*)*)
(*(*{#,d2Pd\[Theta]adEaFusion[1.3,0.0005,#,"SPS","Mo"]}&/@Table[x,{x,1.31,400,5}]*)
(*d2Pd\[Theta]adEaFusion1[1.3,0.0005,45,"SPS","Mo"]//AbsoluteTiming*)*)


(* ::Subsubsection::Closed:: *)
(*Tests  (compare with Fig. 4 from https://arxiv.org/abs/1512.03069, results should be larger by the factor (Subscript[Z, mo]/Subscript[Z, copper])^2=2.1)*)


(* ::Item::Closed:: *)
(*Test 1*)


(* ::Input:: *)
(*(*gatest=10^-4;*)
(*\[Theta]atest=10^-2;*)
(*ZmoZcopper2=2.1;*)
(*tabb=Join[ParallelTable[{Ea,1/ZmoZcopper2Quiet[d2\[Sigma]d\[Theta]adEaFusion1[0.05,\[Theta]atest,Ea,"SPS","Mo"]/\[Theta]atest*gatest^2]},{Ea,Table[10^x,{x,Log10[0.08],2,0.1}]}]];//AbsoluteTiming*)
(*tabb2=Join[ParallelTable[{Ea,1/ZmoZcopper2Quiet[d2\[Sigma]d\[Theta]adEaFusion1[0.5,\[Theta]atest,Ea,"SPS","Mo"]/\[Theta]atest*gatest^2]},{Ea,Table[10^x,{x,Log10[0.7],2,0.1}]}]];//AbsoluteTiming*)
(*ListLogLogPlot[{tabb,tabb2},PlotRange\[Rule]{{1,100},{5,1100}},Joined\[Rule]True,ImageSize\[Rule]Large,Frame\[Rule]True,GridLines\[Rule]Automatic]*)*)


(* ::Item::Closed:: *)
(*Test 2*)


(* ::Input:: *)
(*(*Eatest=10;*)
(*gatest=10^-4;*)
(*tabb=Join[ParallelTable[{10^x,1/ZmoZcopper2Quiet[d2\[Sigma]d\[Theta]adEaFusion1[0.05,10^x,Eatest,"SPS","Mo"]/Sin[10^x]*gatest^2]},{x,-4,-1,0.2}]];//AbsoluteTiming*)
(*tabb2=Join[ParallelTable[{10^x,1/ZmoZcopper2Quiet[d2\[Sigma]d\[Theta]adEaFusion1[0.5,10^x,Eatest,"SPS","Mo"]/Sin[10^x]*gatest^2]},{x,-4,-1,0.2}]];//AbsoluteTiming*)
(*ListLogLogPlot[Evaluate[{tabb,tabb2}],Joined\[Rule]True,ImageSize\[Rule]Large,Frame\[Rule]True,PlotRange->{{10^-4.,0.1},{1,1000}},GridLines\[Rule]Automatic]*)*)
(**)


(* ::Subsection::Closed:: *)
(*Differential cross-section - colliders*)


(* ::Input:: *)
(*(*Solutions for energy fractions Subscript[x, 1],Subscript[x, 2] carried by photons from protons in terms of the ALP mass and its transverse momentum*)*)
(*max1x2Colliders[x1_,x2_,EpCM_]=2 Sqrt[x1*x2]*EpCM;*)
(*kzx1x2Colliders[x1_,x2_,EpCM_]=EpCM*(x1-x2);*)
(*solsColliders[kzCM_,ma_,EpCM_]=Assuming[ma>0&&kZ>0&&EpCM>0&&kzCM>0,Simplify[Solve[{max1x2Colliders[x1,x2,EpCM]==ma&&kzx1x2Colliders[x1,x2,EpCM]==kzCM},{x1,x2}]]][[2]];*)
(*{xp1kzColliders[kzCM_,ma_,EpCM_],xp2kzColliders[kzCM_,ma_,EpCM_]}={x1/.solsColliders[kzCM,ma,EpCM],x2/.solsColliders[kzCM,ma,EpCM]};*)
(*(*Diff. cross-section of the ALP production in terms of Subscript[k, T] and Subscript[k, z] of the ALP*)*)
(*IntegrandFusionCollidersTemp[ma_,kzCM_,kT_,pT1_,pT2_,EpCM_]=2*kT*2*pT1*2*pT2*ma^2/(32*EpCM*EpCM Sqrt[kzCM^2+ma^2]) (fEPAp[pT1,xp1kzColliders[kzCM,ma,EpCM],\[Alpha]EMval]*fEPAp[pT2,xp2kzColliders[kzCM,ma,EpCM],\[Alpha]EMval])/Sqrt[2*kT^2 (pT1^2+pT2^2)-kT^4-(pT1^2-pT2^2)^2]//Simplify;*)
(*kTto\[Theta]aCMEaCM[ma_,\[Theta]a_,Ea_]=Sqrt[Ea^2-ma^2]Sin[\[Theta]a];*)
(*kzCMto\[Theta]aCMEaCM[ma_,\[Theta]a_,Ea_]=Sqrt[Ea^2-ma^2]Cos[\[Theta]a];*)
(*JacobiankTkzCMto\[Theta]aCMEaCM[ma_,\[Theta]a_,Ea_]=D[kTto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],\[Theta]a]*D[kzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],Ea]-D[kTto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],Ea]*D[kzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],\[Theta]a]//Simplify;*)
(*(*Diff. cross-section of the ALP production in terms of Subscript[\[Theta], a] and Subscript[E, a] of the ALP*)*)
(*IntegrandFusionColliders[ma_,\[Theta]a_,Ea_,pT1_,pT2_,EpCM_]=JacobiankTkzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea]*IntegrandFusionCollidersTemp[ma,kzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],kTto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],pT1,pT2,EpCM];*)
(*xp1\[Theta]aEaColliders[ma_,\[Theta]a_,Ea_,EpCM_]=xp1kzColliders[kzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],ma,EpCM];*)
(*xp2\[Theta]aEaColliders[ma_,\[Theta]a_,Ea_,EpCM_]=xp2kzColliders[kzCMto\[Theta]aCMEaCM[ma,\[Theta]a,Ea],ma,EpCM];*)


(* ::Subsubsection::Closed:: *)
(*Explicit form (with all parameters inserted)*)


(* ::Input:: *)
(*Do[*)
(*Module[{Facility},*)
(*Facility=facility;*)
(*\[Epsilon]Regularization=(*10^-10.*)0.;*)
(*IntegrandFusionTemp1[ma_,\[Theta]a_,Ea_,pT1_,pT2_,Facility,"p"]=IntegrandFusionColliders[ma,\[Theta]a,Ea,pT1,pT2,EmaxFacility[Facility]];*)
(*IntegrandFusionTemp2[ma_,\[Theta]a_,Ea_,pT1_,pT2_,Facility,"p"]=If[Abs[pT1-pT2](1+\[Epsilon]Regularization)<kTto\[Theta]aCMEaCM[ma,\[Theta]a,Ea]<(pT1+pT2)(1-\[Epsilon]Regularization),Evaluate[IntegrandFusionTemp1[ma,\[Theta]a,Ea,pT1,pT2,Facility,"p"]],10^-90.];*)
(*{pTp1MaxEPA[ma_,\[Theta]a_,Ea_,Facility,"p"],pTp2MaxEPA[ma_,\[Theta]a_,Ea_,Facility,"p"]}={pTprotonMaxEPA[xp1\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]],*)
(*pTprotonMaxEPA[xp2\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]]};*)
(*(*Converting the integrand to the variables m = (Subscript[p, T,1]+Subscript[p, T,2]),t=(Subscript[p, T,1]-Subscript[p, T,2])*)*)
(*tmax[ma_,\[Theta]a_,Ea_,Facility,"p"]=Min[kTto\[Theta]a[ma,\[Theta]a,Ea],(pTp1MaxEPA[ma,\[Theta]a,Ea,Facility,"p"]-0.)];*)
(*tmin[ma_,\[Theta]a_,Ea_,Facility,"p"]=-Min[pTp2MaxEPA[ma,\[Theta]a,Ea,Facility,"p"],kTto\[Theta]a[ma,\[Theta]a,Ea]];*)
(*mmax[ma_,\[Theta]a_,Ea_,Facility,"p"]=(pTp1MaxEPA[ma,\[Theta]a,Ea,Facility,"p"]+pTp2MaxEPA[ma,\[Theta]a,Ea,Facility,"p"]);*)
(*mmin[ma_,\[Theta]a_,Ea_,Facility,"p"]=kTto\[Theta]a[ma,\[Theta]a,Ea];*)
(*IntegrandFusionConverted1[ma_,\[Theta]a_,Ea_,m_,t_,Facility,"p"]=1/2 IntegrandFusionTemp2[ma,\[Theta]a,Ea,(m+t)/2,(m-t)/2,Facility,"p"][[2]];*)
(*\[Epsilon]v=10^-9.;*)
(*(*d2\[Sigma]d\[Theta]adEaFusionSlow[ma_,\[Theta]a_,Ea_,Facility,"p"]:=With[{MMIN=mmin[ma,\[Theta]a,Ea,Facility,"p"],MMAX=mmax[ma,\[Theta]a,Ea,Facility,"p"],x2=xp2\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]},*)
(*Module[{\[Epsilon]},*)
(*\[Epsilon]=(*If[x2<10^-10,10^-7.,10^-7.]*)10^-7.;GeVm2Topb*If[ma<Ea&&xp1\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]<xminmaxEPA[mSM["p"],q2pMax]&&x2<xminmaxEPA[mSM["p"],q2pMax]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted1[ma,\[Theta]a,Ea,Exp[m],t,Facility,"p"]Exp[m],{m,Log[(1+\[Epsilon])MMIN],Log[MMAX]},{t,(1-\[Epsilon])tmin[ma,\[Theta]a,Ea,Facility,"p"],(1-\[Epsilon])tmax[ma,\[Theta]a,Ea,Facility,"p"]},Method->Automatic],0.]]//Re*)
(*];*)
(*d2\[Sigma]d\[Theta]adEaFusionFast[ma_,\[Theta]a_,Ea_,Facility,"p"]:=With[{MMIN=mmin[ma,\[Theta]a,Ea,Facility,"p"],MMAX=mmax[ma,\[Theta]a,Ea,Facility,"p"]},*)
(*GeVm2Topb*If[ma<Ea&&xp1\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]<xminmaxEPA[mSM["p"],q2pMax]&&xp2\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]<xminmaxEPA[mSM["p"],q2pMax]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted1[ma,\[Theta]a,Ea,Exp[m],t,Facility,"p"]Exp[m],{m,Log[(1+\[Epsilon]v)MMIN],Log[MMAX]},{t,(1-\[Epsilon]v)tmin[ma,\[Theta]a,Ea,Facility,"p"],(1-\[Epsilon]v)tmax[ma,\[Theta]a,Ea,Facility,"p"]},Method->"AdaptiveMonteCarlo"],0.]]//Re;*)*)
(*d2\[Sigma]d\[Theta]adEaFusion[ma_,\[Theta]a_,Ea_,Facility,"p"]:=With[{MMIN=mmin[ma,\[Theta]a,Ea,Facility,"p"],MMAX=mmax[ma,\[Theta]a,Ea,Facility,"p"]},*)
(*GeVm2Topb*If[ma<Ea&&xp1\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]<xminmaxEPA[mSM["p"],q2pMax]&&xp2\[Theta]aEaColliders[ma,\[Theta]a,Ea,EmaxFacility[Facility]]<xminmaxEPA[mSM["p"],q2pMax]&&MMIN<MMAX,NIntegrate[IntegrandFusionConverted1[ma,\[Theta]a,Ea,Exp[m],t,Facility,"p"]Exp[m],{m,Log[(1+\[Epsilon]v)MMIN],Log[MMAX]},{t,(1-\[Epsilon]v)tmin[ma,\[Theta]a,Ea,Facility,"p"],(1-\[Epsilon]v)tmax[ma,\[Theta]a,Ea,Facility,"p"]},Method->"DoubleExponential"],0.]]//Re;*)
(*d2Pd\[Theta]adEaFusion[ma_,\[Theta]a_,Ea_,Facility,"p"]:=1/\[Sigma]pp[Facility] If[Ea>ma,d2\[Sigma]d\[Theta]adEaFusion[ma,\[Theta]a,Ea,Facility,"p"],0.];*)
(*(*d2Pd\[Theta]adEaFusionFast[ma_,\[Theta]a_,Ea_,Facility,"p"]:=1/\[Sigma]pp[Facility]If[Ea>ma,d2\[Sigma]d\[Theta]adEaFusionFast[ma,\[Theta]a,Ea,Facility,"p"],0.];*)
(*d2Pd\[Theta]adEaFusionSlow[ma_,\[Theta]a_,Ea_,Facility,"p"]:=1/\[Sigma]pp[Facility]If[Ea>ma,d2\[Sigma]d\[Theta]adEaFusionSlow[ma,\[Theta]a,Ea,Facility,"p"],0.];*)*)
(*]*)
(*,{facility,{"LHC","FCC-hh"}}]*)
(*mf=0.3;*)
(*thf=10^-3.;*)
(*Ef=500;*)
(*xp2\[Theta]aEaColliders[mf,thf,Ef,EmaxFacility["LHC"]]*)
(*d2Pd\[Theta]adEaFusion[mf,thf,Ef,"LHC","p"]//AbsoluteTiming*)
(*(*d2Pd\[Theta]adEaFusionSlow[mf,thf,Ef,"LHC","p"]//AbsoluteTiming*)
(*d2Pd\[Theta]adEaFusionFast[mf,thf,Ef,"LHC","p"]//AbsoluteTiming*)*)
(*(*nsim=100;*)
(*thvals=10^RandomReal[{-5,Log10[Pi/2]},nsim]//N*)
(*fac="LHC";*)
(*mf=0.02;*)
(*evals=10^RandomReal[{Log10[mf],Log10[EmaxFacility[fac]]},nsim]//N*)
(*tabb=Select[ParallelTable[{thvals[[i]],evals[[i]],If[evals[[i]]>mf,xp1\[Theta]aEaColliders[mf,thvals[[i]],evals[[i]],EmaxFacility[fac]],0.],If[evals[[i]]>mf,xp2\[Theta]aEaColliders[mf,thvals[[i]],evals[[i]],EmaxFacility[fac]],0.],Quiet[d2Pd\[Theta]adEaFusion[mf,thvals[[i]],evals[[i]],fac,"p"]]//AbsoluteTiming,Table[Quiet[d2Pd\[Theta]adEaFusionFast[mf,thvals[[i]],evals[[i]],fac,"p"]],3]//Mean//AbsoluteTiming,Quiet[d2Pd\[Theta]adEaFusionSlow[mf,thvals[[i]],evals[[i]],fac,"p"]]//AbsoluteTiming,{mmin[mf,thvals[[i]],evals[[i]],fac,"p"],mmax[mf,thvals[[i]],evals[[i]],fac,"p"]},{tmin[mf,thvals[[i]],evals[[i]],fac,"p"],tmax[mf,thvals[[i]],evals[[i]],fac,"p"]},kTto\[Theta]aCMEaCM[mf,thvals[[i]],evals[[i]]]},{i,1,nsim,1}],#[[5,2]]!=0.&];//AbsoluteTiming*)
(*tttt1=Take[SortBy[tabb,-#[[5,1]]&],{1,Min[50,Length[tabb]]}];*)
(*tttt2=Take[SortBy[tabb,-Abs[(#[[5,2]]-#[[7,2]])/#[[5,2]]]&],{1,Min[50,Length[tabb]]}]*)*)


(* ::Chapter::Closed:: *)
(*ALP-fermion*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*(*List of processes*)*)
(*LLPname="ALP-fermion";*)
(*(*There are production channels via mixing with neutral light mesons, ##-mixing*)*)
(*ProcessesListAll[LLPname]={"B","Pi0","Eta","EtaPr"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Mixing","Mixing","Mixing"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","PiCharged",LLPname},{"Pi0",LLPname},{"Eta",LLPname},{"EtaPr",LLPname}}}];*)
(*LLPname//Clear*)


(* ::Chapter::Closed:: *)
(*DP*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*(*List of processes*)*)
(*LLPname="DP";*)
(*(*Only decays, mixing with \[Rho]^0, and proton bremsstrahlung are listed. Drell-Yan is computed externally (MadGraph+pythia)*)*)
(*ProcessesListAll[LLPname]={"Pi0","Eta","EtaPr","Bremsstrahlung","Mixing-Old"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Decay","Decay","Scattering","Mixing"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Pi0","photon",LLPname},{"Eta","photon",LLPname},{"EtaPr","photon",LLPname},{"p",LLPname},{"Rho0",LLPname}}}];*)
(*LLPname//Clear*)


(* ::Chapter::Closed:: *)
(*B-Subscript[L, \[Alpha]]*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*BLlist={"B-L","B-3Lmu","B-Le-3Lmu+Ltau","B-3Le-Lmu+Ltau"};*)
(*Do[*)
(*(*List of processes*)*)
(*LLPname=fipname;*)
(*(*Only decays, mixing with \[Omega], and proton bremsstrahlung are listed. Drell-Yan is computed externally (MadGraph+pythia)*)*)
(*ProcessesListAll[LLPname]={"Pi0","Eta","EtaPr","Bremsstrahlung","Mixing-Old"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Decay","Decay","Scattering","Mixing"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Pi0","photon",LLPname},{"Eta","photon",LLPname},{"EtaPr","photon",LLPname},{"p",LLPname},{"Omega",LLPname}}}];*)
(*,{fipname,BLlist}]*)
(*LLPname//Clear*)


(* ::Chapter::Closed:: *)
(*Scalar*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*(*List of processes*)*)
(*LLPname="Scalar";*)
(*(*The kinematics of 2-body decays of B via the mixing channel is approximated by B -> \[Pi]+S. This is reasonable since at low scalar masses the accompanying meson mass is irrelevant, while at higher masses, only \[Pi],K may be*)*)
(*ProcessesListAll[LLPname]={"B-mixing","Bs-quartic","B-quartic","h-quartic","K-mixing","Bremsstrahlung"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{"Decay","Decay","Decay","Decay","Decay","Scattering"}}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Bplus","PiCharged",LLPname},{"Bs",LLPname,LLPname},{"Bplus","Kplus",LLPname,LLPname},{"h",LLPname,LLPname},{"Kplus","PiCharged",LLPname},{"p",LLPname}}}];*)


(* ::Section::Closed:: *)
(*Squared matrix elements for 3-body processes (https://arxiv.org/abs/1904.10447)*)


(* ::Input:: *)
(*MBpole=Sqrt[38.];*)
(*Msquared3Body[LLPname,"B-quartic",mLLP_,E1_,E3_]=(1/(1-ScalarProduct[k-k1,k-k1]/MBpole^2)^2//ExpandScalarProduct)/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k,k1]-> ProductKK1energy}/.{m->mSM["Bplus"],m1->mSM["PiCharged"]}*)
(*LLPname//Clear*)


(* ::Chapter::Closed:: *)
(*MCPs*)


(* ::Section::Closed:: *)
(*Relevant processes*)


(* ::Input:: *)
(*LLPname="MCP";*)
(*(*Only decays are listed. Drell-Yan is computed externally (MadGraph+pythia)*)*)
(*ProcessesListAll[LLPname]={"Pi0","Eta","Phi","JPsi","Rho0","Omega","Upsilon"};*)
(*(*Topology of the process*)*)
(*MapThread[(ProductionType[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],Table["Decay",Length[ProcessesListAll[LLPname]]]}];*)
(*(*Particle content: mother particle, decay products*)*)
(*MapThread[(ReactionProductsList[LLPname,#1]=#2)&,{ProcessesListAll[LLPname],{{"Pi0","photon",LLPname,LLPname},{"Eta","photon",LLPname,LLPname},{"Phi",LLPname,LLPname},{"JPsi",LLPname,LLPname},{"Rho0",LLPname,LLPname},{"Omega",LLPname,LLPname},{"Upsilon",LLPname,LLPname}}}];*)


(* ::Section::Closed:: *)
(*Matrix elements of 3-body decays*)


(* ::Subsection::Closed:: *)
(*Decay of \[Pi]^0/\[Eta]*)


(* ::Input:: *)
(*LLPname="MCP";*)
(*FileM2MCPprod=FileNameJoin[{NotebookDirectory[],"phenomenology/"<>LLPname<>"/Production probabilities/M2Pi0Eta.mx"}];*)
(*If[!FileExistsQ[FileM2MCPprod],*)
(*MmesonDecayMCP3Body=LeviCivita[\[Mu],\[Nu],\[Alpha],\[Beta]]/ScalarProduct[k2+k3,k2+k3] (FV[k1,\[Mu]]*PolarizationVector[k1,\[Nu]]-FV[k1,\[Nu]]*PolarizationVector[k1,\[Mu]])(-FV[k2+k3,\[Alpha]]*MT[\[Beta],\[Delta]]+FV[k2+k3,\[Beta]]*MT[\[Alpha],\[Delta]])SpinorVBar[k2,m2] . GA[\[Delta]] . SpinorU[k3,m3]//Contract;*)
(*MmesonDecayMCP3BodyStar=MmesonDecayMCP3Body//ComplexConjugate;*)
(*MmesonDecayMCP3BodySquaredTemp=(Simplify[Expand[DoPolarizationSums[FermionSpinSum[MmesonDecayMCP3Body*MmesonDecayMCP3BodyStar]/.DiracTrace->TR,k1]//Contract//Simplify]]/.{ScalarProduct[k,k]->ProductKK,ScalarProduct[k1,k1]->ProductK1K1,ScalarProduct[k2,k2]->ProductK2K2,ScalarProduct[k3,k3]->ProductK3K3}/.{ScalarProduct[k,k1]-> ProductKK1energy,ScalarProduct[k2,k3]->ProductK2K3energy,ScalarProduct[k1,k3]->ProductK1K3energy,ScalarProduct[k,k3]->ProductKK3energy,ScalarProduct[k1,k2]->ProductK1K2energy,ScalarProduct[k,k2]->ProductKK2energy});*)
(*Msquared3Body[LLPname,"Pi0",mLLP_,E1_,E3_]=MmesonDecayMCP3BodySquaredTemp/.{m->mSM["Pi0"],m1->0,m2->mLLP,m3->mLLP}//Simplify;*)
(*Msquared3Body[LLPname,"Eta",mLLP_,E1_,E3_]=MmesonDecayMCP3BodySquaredTemp/.{m->mSM["Eta"],m1->0,m2->mLLP,m3->mLLP}//Simplify;*)
(*Export[FileM2MCPprod,{Msquared3Body[LLPname,"Pi0",mLLP,E1,E3],Msquared3Body[LLPname,"Eta",mLLP,E1,E3]},"MX"]*)
(*,*)
(*{Msquared3Body[LLPname,"Pi0",mLLP_,E1_,E3_],Msquared3Body[LLPname,"Eta",mLLP_,E1_,E3_]}=Import[FileM2MCPprod,"MX"];*)
(*]*)
(*LLPname//Clear*)


(* ::Chapter::Closed:: *)
(*Common definitions*)


(* ::Section::Closed:: *)
(*Bremsstrahlung*)


(* ::Input:: *)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/Bremsstrahlung.nb"}]]];*)


(* ::Section::Closed:: *)
(*Threshold mass for all processes*)


(* ::Input:: *)
(*(*The list with all particular LLPs*)*)
(*LLPlist=Keys[DownValues@ProcessesListAll][[All,1,1]]//Sort;*)
(*(*The list where HNL-mixing-e, HNL-mixing-mu, HNL-mixing-tau is replaced with single HNL*)*)
(*LLPlistEffective=Join[Select[LLPlist,!StringContainsQ[#,"HNL"]&],{"HNL"}]//Sort;*)
(*(*Maximal LLP mass for the implemented production channels*)*)
(*Do[*)
(*Do[*)
(*Module[{partlist,mother,nfips},*)
(*partlist=ReactionProductsList[LLP,mode];*)
(*mother=partlist[[1]];*)
(*(*If the production is via mixing or the mother particle is proton, no robust estimate of the threshold exists*)*)
(*If[Length[partlist]==2||mother=="p",MaxMass[LLP,Facility,mode]=Min[4.,EcmFacility[Facility]-2*0.938],*)
(*(*If the mother particle cannot be produced at the given facility, then MaxMass = 0*)*)
(*If[IfSMatFacility[mother,Facility]==0,MaxMass[LLP,Facility,mode]=0.];*)
(*(*If it may be produced, then calculating the max mass as (Subscript[m, mother]-\[Sum]Subscript[m, SM products])/Subscript[n, LLPs,per decay]*)*)
(*If[IfSMatFacility[mother,Facility]!=0,*)
(*nfips=Select[partlist,#==LLP&]//Length;*)
(*MaxMass[LLP,Facility,mode]=mSM[partlist[[1]]]-Sum[mSM[partlist[[i]]],{i,2,Length[partlist]-nfips}];*)
(*If[nfips>1,MaxMass[LLP,Facility,mode]=MaxMass[LLP,Facility,mode]/nfips];*)
(*]];*)
(*],{mode,ProcessesListAll[LLP]}],{Facility,FacilitiesList},{LLP,LLPlist}]*)
(*(*_______________*)*)
(*(*For averaged HNL production*)*)
(*(*_______________*)*)
(*(*Max mass for averaged production from B*)*)
(*Do[MaxMass[HNL,Facility,"B"]=Max[MaxMass[HNL,Facility,#]&/@{"B-3-body","Bc","B-2-body"}],{HNL,ListHNLs},{Facility,FacilitiesList}]*)
(*(*Max mass for averaged production from D*)*)
(*Do[*)
(*prl=Select[{"D-3-body","D-2-body","\[Tau]-2-body","\[Tau]-3-body"},MemberQ[ProcessesListAll[HNL],#]==True&];*)
(*MaxMass[HNL,Facility,"D"]=Max[MaxMass[HNL,Facility,#]&/@prl],{HNL,ListHNLs},{Facility,FacilitiesList}]*)


(* ::Section::Closed:: *)
(*List of facility-specific channels*)


(* ::Input:: *)
(*(*Selecting only those channels for which:*)*)
(*(*1. Is kinematically possible to produce LLP at the given facility (==max LLP mass at the given facility is > 0)*)*)
(*(*2. There is available mother particle distribution*)*)
(*Do[*)
(*Module[{proc,mother},*)
(*If[!StringContainsQ[LLP,"HNL"],*)
(*(*First, filtering to processes which are kinematically possible*)*)
(*ProcessesListFacilityTemp[LLP,Facility]=Select[ProcessesListAll[LLP],MaxMass[LLP,Facility,#]>0&];*)
(*(*Second, checking if the mother distribution is present*)*)
(*ProcessesListFacility[LLP,Facility]={};*)
(*Do[*)
(*proc=ProcessesListFacilityTemp[LLP,Facility][[i]];*)
(*mother=ReactionProductsList[LLP,proc][[1]];*)
(*(*Specific condition is to *)*)
(*If[Select[sortedDataPairs,#[[1]]==Facility&&MemberQ[{mother,SimilarParticle[Facility,mother]},#[[2]]]&]!={},*)
(*ProcessesListFacility[LLP,Facility]=Join[ProcessesListFacility[LLP,Facility],{proc}]*)
(*];*)
(*,{i,1,Length[ProcessesListFacilityTemp[LLP,Facility]],1}]*)
(*];*)
(*If[StringContainsQ[LLP,"HNL"],*)
(*ProcessesListFacilityTemp[LLP,Facility]=Select[{"W","K","D","B","mu","PiCharged"},MaxMass[LLP,Facility,#]>0&];*)
(*ProcessesListFacility[LLP,Facility]={};*)
(*Do[*)
(*proc=ProcessesListFacilityTemp[LLP,Facility][[i]];*)
(*mother=If[proc=="D","tau",If[proc=="B","Bplus",ReactionProductsList[LLP,proc][[1]]]];*)
(*(*Specific condition is to *)*)
(*If[Select[sortedDataPairs,#[[1]]==Facility&&MemberQ[{mother,SimilarParticle[Facility,mother]},#[[2]]]&]!={},*)
(*ProcessesListFacility[LLP,Facility]=Join[ProcessesListFacility[LLP,Facility],{proc}]*)
(*];*)
(*,{i,1,Length[ProcessesListFacilityTemp[LLP,Facility]],1}]*)
(*];*)
(*];*)
(*,{LLP,LLPlist},{Facility,FacilitiesList}]*)
(*Do[ProcessesListFacility["HNL",Facility]=Table[ProcessesListFacility[LLP,Facility],{LLP,ListHNLs}]//Flatten//DeleteDuplicates,{Facility,FacilitiesList}]*)
(*Print["List of all implemented channels:"]*)
(*TabProcesses=Flatten[Table[{LLP,Facility,ProcessesListFacility[LLP,Facility]},{LLP,LLPlist},{Facility,FacilitiesList}],1]*)


(* ::Title::Closed:: *)
(*Preliminary code: PDFs of LLPs*)


(* ::Chapter::Closed:: *)
(*Production via decays: sampling boosted LLPs*)


(* ::Section::Closed:: *)
(*Generic code for phase space of 2-body and 3-body decays  at rest frame of the decaying particle*)


(* ::Subsection::Closed:: *)
(*2-body*)


(* ::Input:: *)
(*tabPS2bodyCompiled=Hold@Compile[{{MASSM,_Real},{mLLP,_Real},{m1,_Real},{\[Theta]rand,_Real},{\[Phi]rand,_Real}},Module[{pval,px1,py1,pz1,E12body,E22body},*)
(*(*Energies of particles 1 (E12body) and 2 (E22body) at the rest frame of decaying particle*)*)
(*E12body=(MASSM^2-mLLP^2+m1^2)/(2*MASSM);*)
(*E22body=(MASSM^2-m1^2+mLLP^2)/(2*MASSM);*)
(*pval=pPar[E22body,mLLP];*)
(*px1=pval*Cos[\[Phi]rand]*Sin[\[Theta]rand];*)
(*py1=pval*Sin[\[Phi]rand]*Sin[\[Theta]rand];*)
(*pz1=pval*Cos[\[Theta]rand];*)
(*{-px1,-py1,-pz1,E12body,m1,px1,py1,pz1,E22body,mLLP}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.DownValues@pPar//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@tabPS2bodyCompiled;*)
(*TwoBodyDecaysEventsAtRest[LLP_,Process_, mLLP_,Nevents_]:=Block[{partcontent,MASSM,MASS1,\[Phi]Rand,\[Theta]Rand},*)
(*partcontent=ReactionProductsList[LLP,Process];*)
(*{MASSM,MASS1}={mSM[partcontent[[1]]],If[partcontent[[2]]==LLP,mLLP,mSM[partcontent[[2]]]]};*)
(*(*Array of random values of \[Phi] and \[Theta] defined via Subscript[p, 2] = (-p\[Times]Cos[\[Phi]]\[Times]Sin[\[Theta]],-p\[Times]Sin[\[Phi]]\[Times]Sin[\[Theta]],-p\[Times]Cos[\[Theta]])*)*)
(*(*Distribution in \[Phi] is isotropic. Distribution in cos(\[Theta]) is isotropic. Hence, one should generate random values of \[Phi] in (-Pi,Pi) and random values of cos(\[Theta]) from -1 to 1, then takin arccos()*)*)
(*\[Phi]Rand=RandomReal[{-Pi,Pi},Nevents];*)
(*\[Theta]Rand=ArcCos[RandomReal[{-1,1},Nevents]];*)
(*(*The final phase space*)*)
(*TabPS2bodyTemp=tabPS2bodyCompiled[MASSM,mLLP,MASS1,\[Theta]Rand,\[Phi]Rand];*)
(*If[partcontent[[2]]==LLP,Riffle[TabPS2bodyTemp[[All,Range[1,5]]],TabPS2bodyTemp[[All,Range[6,10]]]],TabPS2bodyTemp[[All,Range[6,10]]]]*)
(*]*)
(*(*tabtest=TwoBodyDecaysEventsAtRest["HNL-mixing-e","B-2-body",1,5*10^6];//AbsoluteTiming*)
(*Print["Distribution in cos(\[Theta]) (must be isotropic):"]*)
(*Histogram[tabtest[[All,3]]/Sqrt[tabtest[[1]][[4]]^2-tabtest[[1]][[5]]^2],100,"ProbabilityDensity"]*)*)


(* ::Subsection::Closed:: *)
(*3-body*)


(* ::Subsubsection::Closed:: *)
(*Full phase space in terms of energies Subscript[E, 1],Subscript[E, 3], and uniformly distributed angles*)


(* ::Input:: *)
(*(*Rotation matrices with around z axis (\[Phi] angle) and x axis (\[Theta] angle)*)*)
(*\[Phi]RotMatrix[\[Phi]_]={{Cos[\[Phi]],Sin[\[Phi]],0},{-Sin[\[Phi]],Cos[\[Phi]],0},{0,0,1}};*)
(*\[Theta]RotMatrix[\[Theta]_]={{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};*)
(*pvecRotated[px_,py_,pz_,\[Theta]V_,\[Phi]V_]=\[Phi]RotMatrix[\[Phi]V] . \[Theta]RotMatrix[\[Theta]V] . {px,py,pz};*)
(*(*Momenta at frame where Subscript[p, 1] is aligned along z axis*)*)
(*p1unrotated={0,0,pPar[E1,m1]};*)
(*p2unrotated={pPar[E2valEnergies[m,E1,E3],m2]*Sin[\[Theta]12[E1,E3,m,m1,m2,m3]]*Sin[\[Kappa]],pPar[E2valEnergies[m,E1,E3],m2]*Sin[\[Theta]12[E1,E3,m,m1,m2,m3]]*Cos[\[Kappa]],pPar[E2valEnergies[m,E1,E3],m2]*Cos[\[Theta]12[E1,E3,m,m1,m2,m3]]};*)
(*p3unrotated={-pPar[E3,m3]*Sin[\[Theta]13[E1,E3,m,m1,m2,m3]]*Sin[\[Kappa]],-pPar[E3,m3]*Sin[\[Theta]13[E1,E3,m,m1,m2,m3]]*Cos[\[Kappa]],pPar[E3,m3]*Cos[\[Theta]13[E1,E3,m,m1,m2,m3]]};*)
(*(*\[Theta]rand=RandomReal[{0,Pi}];*)
(*\[Phi]rand=RandomReal[{-Pi,Pi}];*)*)
(*{p1rotatedX[E1_,m1_,\[Theta]V_,\[Phi]V_],p1rotatedY[E1_,m1_,\[Theta]V_,\[Phi]V_],p1rotatedZ[E1_,m1_,\[Theta]V_,\[Phi]V_]}=(*\[Phi]RotMatrix[\[Phi]V].\[Theta]RotMatrix[\[Theta]V].p1Unrotated*)pvecRotated[p1unrotated[[1]],p1unrotated[[2]],p1unrotated[[3]],\[Theta]V,\[Phi]V];*)
(*{p2rotatedX[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_],p2rotatedY[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_],p2rotatedZ[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]}=pvecRotated[p2unrotated[[1]],p2unrotated[[2]],p2unrotated[[3]],\[Theta]V,\[Phi]V]//Simplify;*)
(*{p3rotatedX[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_],p3rotatedY[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_],p3rotatedZ[E1_,E3_,m_,m1_,m2_,m3_,\[Theta]V_,\[Phi]V_,\[Kappa]_]}=pvecRotated[p3unrotated[[1]],p3unrotated[[2]],p3unrotated[[3]],\[Theta]V,\[Phi]V]//Simplify;*)


(* ::Subsubsection::Closed:: *)
(*Table with distributions*)


(* ::Input:: *)
(*(*The block that produces random energies Subscript[E, 1],Subscript[E, 3] from 3-body phase space - assuming uniform M^2 (preliminary sampling) and do not taking into account Subscript[\[CapitalDelta]E, 3](Subscript[E, 1])*)*)
(*(*It first generates Subscript[E, 1] within Subscript[E, 1,min],Subscript[E, 1,max]. Then, it generates Subscript[E, 3] until it is within the range {Subscript[E, 3,min](Subscript[E, 1]),Subscript[E, 3,max](Subscript[E, 1])}*)*)
(*BlockRandomEnergiesOld=Compile[{m,m1,m2,m3,E1min,E1max},Module[{E1r=0.,E2v=0.,E3r=0.},While[E3r=RandomReal[{m3,(m^2+m3^2-(m1+m2)^2)/(2*m)}];*)
(*E1r=RandomReal[{E1min,E1max}];*)
(*E2v=m-E1r-E3r;*)
(*E2v<=m2||(E2v^2-m2^2-(E1r^2-m1^2)-(E3r^2-m3^2))^2>=4*(E1r^2-m1^2)*(E3r^2-m3^2)];*)
(*{E1r,E3r}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True];*)
(*(*The routine that computes the weights M^2(Subscript[E, 1],Subscript[E, 3])Subscript[\[CapitalDelta]E, 3](Subscript[E, 1]) for the given uniformly distributed Subscript[E, 1],Subscript[E, 3]*)*)
(*weightsNonUniformComp:=Hold@Compile[{{tabe1e3,_Real,1},MASSM,MASS1,MASS2,MASS3},Module[{e1,e3},*)
(*e1=Compile`GetElement[tabe1e3,1];*)
(*e3=Compile`GetElement[tabe1e3,2];*)
(*Abs[distr[e1,e3]*\[CapitalDelta]E3[e1,MASSM,MASS1,MASS2,MASS3]]*)
(*],CompilationTarget->"MVM",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{distr,\[CapitalDelta]E3}]//ReleaseHold;*)
(*weightsUniformComp=Hold@Compile[{{tabe1e3,_Real,1},MASSM,MASS1,MASS2,MASS3},Module[{e1,e3},*)
(*e1=Compile`GetElement[tabe1e3,1];*)
(*Abs[\[CapitalDelta]E3[e1,MASSM,MASS1,MASS2,MASS3]]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{\[CapitalDelta]E3}]//ReleaseHold;*)
(*E3valsComp=Hold@Compile[{{E1vals,_Real},MASSM,MASS1,MASS2,MASS3},Module[{e3max,e3min},*)
(*e3min=Abs[E3domain1[E1vals,MASSM,MASS1,MASS2,MASS3]];*)
(*e3max=Abs[E3domain2[E1vals,MASSM,MASS1,MASS2,MASS3]];*)
(*RandomReal[{e3min,e3max}]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{E3domain2,E3domain1}]//ReleaseHold*)
(*NN=10^6;*)
(*BlockRandomEnergies[LLP_,Process_,mLLP_,Nevents_]:=Module[{partcontent,m,m1,m2,m3},*)
(*partcontent=ReactionProductsList[LLP,Process];*)
(*{m,m1,m2,m3}={mSM[partcontent[[1]]],mSM[partcontent[[2]]],If[partcontent[[3]]==LLP,mLLP,mSM[partcontent[[3]]]],mLLP};*)
(*distr[E1_,E3_]=Msquared3Body[LLP,Process,m,E1,E3]//Simplify;*)
(*E1maxval=E1domain[m,m1,m2,m3][[2]];*)
(*E1vals=RandomReal[{m1,E1maxval},Max[NN,Nevents]];*)
(*E3vals=E3valsComp[E1vals,m,m1,m2,m3];*)
(*tabE1E3unweighted={E1vals,E3vals}//Transpose;*)
(*(*Weights for the generated values of {E1,E3} from matrix element squared*)*)
(*If[distr[tabE1E3unweighted[[1]][[1]],tabE1E3unweighted[[1]][[2]]]!=1,*)
(*(*Table with random energies distributed in the Dalitz range before accounting for weights*)*)
(*weights1=weightsNonUniformComp;*)
(*(*Weights from matrix element. Near the boundary values of E1, E3, they may become negative (Mathematica's numeric inaccuracy). Because of that, I will just replace such weights by zero*)*)
(*weights=weights1[tabE1E3unweighted,m,m1,m2,m3](*/._?Negative\[Rule]0*);*)
(*,*)
(*weights1=weightsUniformComp;*)
(*weights=weights1[tabE1E3unweighted,m,m1,m2,m3](*/._?Negative\[Rule]0*);*)
(*];*)
(*(*True random energies. Computed via empirical distribution from the weigthed data*)*)
(*RandomChoice[weights->tabE1E3unweighted,Nevents]*)
(*(*(*Weighted random points*)*)
(*weightedData=WeightedData[tabE1E3unweighted,weights];*)
(*(*True random energies. Computed via empirical distribution from the weigthed data*)*)
(*edist=EmpiricalDistribution[weightedData];*)
(*RandomVariate[edist,Nevents];*)*)
(*]*)
(*(*Temp*)*)
(*E12E23domain[m_,m1_,m2_,m3_,Emin_,Emax_]:=NIntegrate[UnitStep[E3v-Emin]*UnitStep[Emax-E3v],{E1v,E1domain[m,m1,m2,m3][[1]],E1domain[m,m1,m2,m3][[2]]},{E3v,Max[E3domain[E1v,m,m1,m2,m3][[1]],Emin],Min[Emax,E3domain[E1v,m,m1,m2,m3][[2]]]},Method->"AdaptiveMonteCarlo"]*)
(*(*The block that returns the phase space of 3-body decays 0 -> 1+2+3 given the set of energies Subscript[E, 1],Subscript[E, 3] (obtained after re-sampling with the true M^2), the angles \[Theta],\[Phi]*)*)
(*tabPS3bodyCompiled=Hold@Compile[{{tabPSenergies,_Real,1},{MASSM,_Real},{MASS1,_Real},{MASS2,_Real},{MASS3,_Real}},Module[{e1,e3,p1x,p1y,p1z,p2x,p2y,p2z,p3x,p3y,p3z,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab},*)
(*e1=Compile`GetElement[tabPSenergies,1];*)
(*e3=Compile`GetElement[tabPSenergies,2];*)
(*(*Angles relating generated energies to the 4-momenta*)*)
(*\[Theta]randTab=ArcCos[RandomReal[{-1,1}]];*)
(*\[Phi]randTab=RandomReal[{-Pi,Pi}];*)
(*\[Kappa]randTab=RandomReal[{-Pi,Pi}];*)
(*p2x=p2rotatedX[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p2y=p2rotatedY[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p2z=p2rotatedZ[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p3x=p3rotatedX[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p3y=p3rotatedY[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p3z=p3rotatedZ[e1,e3,MASSM,MASS1,MASS2,MASS3,\[Theta]randTab,\[Phi]randTab,\[Kappa]randTab];*)
(*p1x=-p2x-p3x;*)
(*p1y=-p2y-p3y;*)
(*p1z=-p2z-p3z;*)
(*{p1x,p1y,p1z,e1,MASS1,p2x,p2y,p2z,MASSM-e1-e3,MASS2,p3x,p3y,p3z,e3,MASS3}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{p2rotatedX,p2rotatedY,p2rotatedZ,p3rotatedX,p3rotatedY,p3rotatedZ}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@tabPS3bodyCompiled;*)
(*(*The block that collects altogether and produces the phase space of 3-body decay with LLPs only*)*)
(*ThreeBodyDecaysEventsAtRest[LLP_,Process_,mLLP_,Nevents_]:=Module[{partcontent(*,MASSM,MASS1,MASS2,MASS3*),E1maxval},*)
(*(*___________________________________*)*)
(*(*Extracting information about the decay*)*)
(*(*___________________________________*)*)
(*partcontent=ReactionProductsList[LLP,Process];*)
(*{MASSM,MASS1,MASS2,MASS3}={mSM[partcontent[[1]]],mSM[partcontent[[2]]],If[partcontent[[3]]==LLP,mLLP,mSM[partcontent[[3]]]],mLLP};*)
(*(*___________________________________*)*)
(*(*Generating the true Subscript[E, 1],Subscript[E, 3] for the decay process 0->1+2+3*)*)
(*(*___________________________________*)*)
(*tabE1E3true=BlockRandomEnergies[LLP,Process,mLLP,Nevents];*)
(*(*_____________________________________________*)*)
(*(*Final phase space*)*)
(*(*_____________________________________________*)*)
(*tabPS3bodyTemp=tabPS3bodyCompiled[tabE1E3true,MASSM,MASS1,MASS2,MASS3];*)
(*(*If there are two LLPs, then the code below extracts their data and combines in a way such that the data for two LLPs from each decay is neighboring. Otherwise, it just extracts the data per one LLP*)*)
(*tabPS3body=If[partcontent[[3]]==LLP,Riffle[tabPS3bodyTemp[[All,Range[6,10]]],tabPS3bodyTemp[[All,Range[11,15]]]],tabPS3bodyTemp[[All,Range[11,15]]]];*)
(*tabPS3body*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Test - Dalitz plot for spinless decays*)


(* ::Input:: *)
(*(*mtest=0.3;*)
(*TestPhaseSpace=ThreeBodyDecaysEventsAtRest[mtest,0,"test","test",10^4];//AbsoluteTiming*)
(*m12test[E1_,E2_,p1x_,p1y_,p1z_,p2x_,p2y_,p2z_,m1_,m2_]=m1^2+m2^2+2*(E1*E2-p1x*p2x-p1y*p2y-p1z*p2z);*)
(*m23test[E2_,E3_,p2x_,p2y_,p2z_,p3x_,p3y_,p3z_,m2_,m3_]=m2^2+m3^2+2*(E2*E3-p2x*p3x-p2y*p3y-p2z*p3z);*)
(*Testm12m23Compiled=Hold@Compile[{{TestPhaseSpace,_Real,2},m1,m2,m3},Table[{m12test[TestPhaseSpace[[i]][[4]],TestPhaseSpace[[i]][[8]],TestPhaseSpace[[i]][[1]],TestPhaseSpace[[i]][[2]],TestPhaseSpace[[i]][[3]],TestPhaseSpace[[i]][[5]],TestPhaseSpace[[i]][[6]],TestPhaseSpace[[i]][[7]],m1,m2],m23test[TestPhaseSpace[[i]][[8]],TestPhaseSpace[[i]][[12]],TestPhaseSpace[[i]][[5]],TestPhaseSpace[[i]][[6]],TestPhaseSpace[[i]][[7]],TestPhaseSpace[[i]][[9]],TestPhaseSpace[[i]][[10]],TestPhaseSpace[[i]][[11]],m2,m3]},{i,1,Length[TestPhaseSpace],1}],CompilationTarget\[Rule]"C",RuntimeOptions\[Rule]"Speed"]/.DownValues@m12test/.DownValues@m23test//ReleaseHold*)
(*Testm12m23=Testm12m23Compiled[TestPhaseSpace,mass13bodyProcess["test","test"],mass23bodyProcess["test","test",0,0],mtest];//AbsoluteTiming*)
(*ListPlot[{Testm12m23,Table[{(mass13bodyProcess["test","test"]+mass23bodyProcess["test","test",0,0])^2,x},{x,0,massM3bodyProcess["test","test"],0.05}],Table[{x,(mass23bodyProcess["test","test",0,0]+mtest)^2},{x,0,massM3bodyProcess["test","test"],0.05}],Table[{x,(massM3bodyProcess["test","test"]-mass13bodyProcess["test","test"])^2},{x,0,massM3bodyProcess["test","test"],0.05}],Table[{(massM3bodyProcess["test","test"]-mtest)^2,x},{x,0,massM3bodyProcess["test","test"],0.05}]},Frame\[Rule]True,Joined\[Rule]{False,True,True,True,True},FrameLabel\[Rule]{"Subscript[m, 12] [GeV^2]" , "Subscript[m, 23] [GeV^2]"},FrameStyle\[Rule]Directive[Black, 23],PlotStyle\[Rule]{{Thick,Blue},{Thick,Black,Dashing[0.01]},{Thick,Black,Dashing[0.02]},{Thick,Black,Dashing[0.03]},{Thick,Black,Dashing[0.04]},{Thick,Darker@Cyan,PointSize[0.01]},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green,Dashing[0.02]},{Darker@Red,PointSize[0.04]}},ImageSize\[Rule]Large,PlotRange\[Rule]{{0,massM3bodyProcess["test","test"]},All},PlotLabel\[Rule]Style[Row[{"Dalitz plot for M^2 = const, Subscript[m, mother] = ",massM3bodyProcess["test","test"]," GeV, Subscript[m, 1] = ",mass13bodyProcess["test","test"]," GeV, Subscript[m, 2] = ",mass23bodyProcess["test","test",0,0] ," GeV, Subscript[m, 3] = ",mtest, " GeV"}],15,Black],PlotLegends\[Rule]Placed[Style[#,15]&/@{"Dalitz plot","(Subscript[m, 1]+Subscript[m, 2])^2","(Subscript[m, 2]+Subscript[m, 3])^2","(m - Subscript[m, 1])^2","(m - Subscript[m, 3])^2"},Right]]*)*)


(* ::Section::Closed:: *)
(*Lorentz boosts*)


(* ::Subsection::Closed:: *)
(*Table with 4-momentum of boosted LLPs*)


(* ::Input:: *)
(*(*Table Subscript[p, product,x], Subscript[p, product,y], Subscript[p, product,z], Subscript[E, product]*)*)
(*indexpx=1;*)
(*indexpy=2;*)
(*indexpz=3;*)
(*indexE=4;*)
(*indexm=5;*)
(*BoostedLLPsFromDecaysTable=Hold@Compile[{{tablemother,_Real,1},{tabledaughter,_Real,1}},Module[{motherE,motherpx,motherpy,motherpz,daughterErest,daughterpxrest,daughterpyrest,daughterpzrest,daughterElab,daughterpxlab,daughterpylab,daughterpzlab,mmother},*)
(*mmother=Compile`GetElement[tablemother,indexm];*)
(*motherE=Compile`GetElement[tablemother,indexE];*)
(*motherpx=Compile`GetElement[tablemother,indexpx];*)
(*motherpy=Compile`GetElement[tablemother,indexpy];*)
(*motherpz=Compile`GetElement[tablemother,indexpz];*)
(*daughterErest=Compile`GetElement[tabledaughter,indexE];*)
(*daughterpxrest=Compile`GetElement[tabledaughter,indexpx];*)
(*daughterpyrest=Compile`GetElement[tabledaughter,indexpy];*)
(*daughterpzrest=Compile`GetElement[tabledaughter,indexpz];*)
(*daughterElab=EproductLabCart[motherpx,motherpy,motherpz,motherE,mmother,daughterpxrest,daughterpyrest,daughterpzrest,daughterErest];*)
(*daughterpxlab=pproductLab1Cart[motherpx,motherpy,motherpz,motherE,mmother,daughterpxrest,daughterpyrest,daughterpzrest,daughterErest];*)
(*daughterpylab=pproductLab2Cart[motherpx,motherpy,motherpz,motherE,mmother,daughterpxrest,daughterpyrest,daughterpzrest,daughterErest];*)
(*daughterpzlab=pproductLab3Cart[motherpx,motherpy,motherpz,motherE,mmother,daughterpxrest,daughterpyrest,daughterpzrest,daughterErest];*)
(*{daughterpxlab,daughterpylab,daughterpzlab,daughterElab}*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]/.ruleDown[{pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{indexpx,indexpy,indexpz,indexE,indexm}]//ReleaseHold;*)
(*(*This code converts the data in the form {Subscript[p, x],Subscript[p, y],Subscript[p, z],E,m} into {\[Theta],E}. If the facility is based on symmetric pp collisions, it also converts everything to the forward hemisphere to increase the statistics*)*)
(*BoostedLLPsAngleEnergyData=Hold@Compile[{{BoostedLLPs,_Real,1},{mLLP,_Real},{abs,_Integer}},Module[{pzvals,Evals},*)
(*pzvals=If[abs==1,Abs[Compile`GetElement[BoostedLLPs,indexpz]],Compile`GetElement[BoostedLLPs,indexpz]];*)
(*Evals=Compile`GetElement[BoostedLLPs,indexE];*)
(*{ArcCos[pzvals/Sqrt[Evals^2-mLLP^2]],Evals}],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable}]/.ruleOwn[{indexpz,indexE}]//ReleaseHold*)
(**)


(* ::Subsection::Closed:: *)
(*Block computing the phase space at rest and boosting it*)


(* ::Subsubsection::Closed:: *)
(*If no averaging over various channels is performed*)


(* ::Input:: *)
(*BoostedLLPsBlock[LLP_,Facility_,mLLP_,process_,Nevents_]:=Module[{(*MotherMass,topology,mother,IfTwoLLPs,partcontent*)},*)
(*partcontent=ReactionProductsList[LLP,process];*)
(*mother=partcontent[[1]];*)
(*IfTwoLLPs=If[Length[Select[partcontent,#==LLP&]]==2,"True","False"];*)
(*nproducts=Length[partcontent]-1;*)
(*If[Length[MotherPoints[mother,Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints[mother,Facility,IfTwoLLPs]=PointsSampler[Facility,mother,Nevents,IfTwoLLPs]];*)
(*NevSampl=If[IfTwoLLPs=="True",1/2,1]Nevents;*)
(*(*Phase space of HNLs at the rest frame of the decaying particle*)*)
(*DataRest=If[nproducts==3,ThreeBodyDecaysEventsAtRest[LLP,process,mLLP,NevSampl],TwoBodyDecaysEventsAtRest[LLP,process,mLLP,NevSampl]];*)
(*(*Boosting and returning the data in the form Log[\[Theta]],Log[E]*)*)
(*If[Facility=="ESS"&&MemberQ[{"PiCharged","mu"},mother],*)
(*datafinal=BoostedLLPsAngleEnergyData[DataRest,mLLP,0]*)
(*,*)
(*DataBoosted=BoostedLLPsFromDecaysTable[MotherPoints[mother,Facility,IfTwoLLPs],DataRest];*)
(*datafinal=BoostedLLPsAngleEnergyData[DataBoosted,mLLP,If[MemberQ[{"LHC","FCC-hh"},Facility]==True,1,0]];*)
(*];*)
(*datafinal*)
(*]*)
(*(*pts=PointsSampler["LHC","Bplus",10^6,"False"];//AbsoluteTiming*)
(*BoostedLLPsBlock["HNL-mixing-e","B-2-body",5.2,pts];//AbsoluteTiming*)
(*Histogram[{DataBoosted[[All,4]],pts[[All,4]]},1000,ScalingFunctions->{"Log","Log"}]*)*)


(* ::Subsubsection::Closed:: *)
(*Averaging over several production channels (complicated HNL case)*)


(* ::Input:: *)
(*BoostedHNLsBlockTemp[LLP_,Facility_,mLLP_,process_,MotherData_]:=Module[{MotherMass,topology,Nev},*)
(*partcontent=ReactionProductsList[LLP,process];*)
(*nproducts=Length[partcontent]-1;*)
(*Nev=Length[MotherData];*)
(*(*Phase space of HNLs at the rest frame of the decaying particle*)*)
(*DataRest=If[nproducts==3,ThreeBodyDecaysEventsAtRest[LLP,process,mLLP,Nev],TwoBodyDecaysEventsAtRest[LLP,process,mLLP,Nev]];*)
(*(*Boosting and returning the data in the form Log[\[Theta]],Log[E]*)*)
(*DataBoosted=BoostedLLPsFromDecaysTable[MotherData,DataRest];*)
(*BoostedLLPsAngleEnergyData[DataBoosted,mLLP,If[MemberQ[{"LHC","FCC-hh"},Facility]==True,1,0]]*)
(*]*)
(*BoostedHNLsBlock[HNL_,Facility_,mN_,process_,Nevents_]:=Module[{IfTwoLLPs,proc,nev,proclist,mother},*)
(*IfTwoLLPs="False";*)
(*If[process=="B",*)
(*proclist={"B-3-body","B-2-body","Bc"};*)
(*If[Length[MotherPoints["Bplus",Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints["Bplus",Facility,IfTwoLLPs]=PointsSampler[Facility,"Bplus",Nevents,IfTwoLLPs]];*)
(*If[Length[MotherPoints["Bc",Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints["Bc",Facility,IfTwoLLPs]=DataConverted[MotherPoints["Bplus",Facility,IfTwoLLPs],mSM["Bc"]]];*)
(*];*)
(*If[process=="D",*)
(*proclist={"D-3-body","D-2-body","\[Tau]-2-body","\[Tau]-3-body"};*)
(*If[Length[MotherPoints["Ds",Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints["Ds",Facility,IfTwoLLPs]=PointsSampler[Facility,"Ds",Nevents,IfTwoLLPs]];*)
(*If[Length[MotherPoints["Dplus",Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints["Dplus",Facility,IfTwoLLPs]=DataConverted[MotherPoints["Ds",Facility,IfTwoLLPs],mSM["Dplus"]]];*)
(*If[Length[MotherPoints["tau",Facility,IfTwoLLPs]]!=Nevents,*)
(*MotherPoints["tau",Facility,IfTwoLLPs]=DataConverted[MotherPoints["Ds",Facility,IfTwoLLPs],mSM["tau"]]];*)
(*];*)
(*If[MemberQ[{"B","D"},process],*)
(*proclistspl=NeventsSplitterHNL[HNL,Facility,proclist,mN,Nevents];*)
(*boosteddata={{}};*)
(*Do[*)
(*{proc,nev}={proclistspl[[i]][[1]],proclistspl[[i]][[2]]};*)
(*mother=ReactionProductsList[HNL,proc][[1]];*)
(*boosteddata=Join[boosteddata,BoostedHNLsBlockTemp[HNL,Facility,mN,proc,Take[MotherPoints[mother,Facility,IfTwoLLPs],nev]]];*)
(*,{i,1,Length[proclistspl],1}];*)
(*boosteddata=Drop[boosteddata,1];*)
(*];*)
(*If[!MemberQ[{"B","D"},process],*)
(*boosteddata=BoostedLLPsBlock[HNL,Facility,mN,process,Nevents];*)
(*];*)
(*boosteddata*)
(*]*)


(* ::Chapter::Closed:: *)
(*Production via decays: converting boosted LLPs data into PDF*)


(* ::Section::Closed:: *)
(*Converting data Log[\[Theta]], Log[E] into PDF*)


(* ::Input:: *)
(*\[Theta]listBinning["SPS"]=\[Theta]listBinning["Serpukhov"]=\[Theta]listBinning["FermilabBD"]=Join[{10^-6.,10^-5.,(*3*10^-5.,6*10^-5.,*),10^-4.,5*10^-4.,10^-3.,2*10^-3.,4*10^-3.,6*10^-3.,8*10^-3.},Table[10^\[Theta]N,{\[Theta]N,Log10[10^-2],Log10[0.5],0.025}],Table[10^\[Theta]N,{\[Theta]N,Log10[0.52],Log10[Pi],0.015}],{Pi}]//N//DeleteDuplicates//Developer`ToPackedArray;*)
(*\[Theta]listBinning["LHC"]=Join[{10^-6.,10^-5.,(*3*10^-5.,6*10^-5.,*)5*10^-5.,10^-4.,3*10^-4.,6*10^-4.,10^-3.,2*10^-3.,4*10^-3.,6*10^-3.,8*10^-3.},Table[10^\[Theta]N,{\[Theta]N,Log10[10^-2.],Log10[0.5],0.025}],Table[10^\[Theta]N,{\[Theta]N,Log10[0.52],Log10[1.],0.015}],Table[10^\[Theta]N,{\[Theta]N,Log10[1.02],Log10[Pi/2],0.01}],{Pi/2}]//N//DeleteDuplicates//Developer`ToPackedArray;*)
(*\[Theta]listBinning["FCC-hh"]=Join[{10^-6.,10^-5.,(*3*10^-5.,6*10^-5.,*)7*10^-5.,10^-4.,3*10^-4.,6*10^-4.,10^-3.,2*10^-3.,4*10^-3.,6*10^-3.,8*10^-3.},Table[10^\[Theta]N,{\[Theta]N,Log10[10^-2],Log10[0.5],0.025}],Table[10^\[Theta]N,{\[Theta]N,Log10[0.52],Log10[Pi/2],0.02}],{Pi/2}]//N//DeleteDuplicates//Developer`ToPackedArray;*)
(*\[Theta]listBinning["ESS"]=Join[{10^-6.,10^-5.,(*3*10^-5.,6*10^-5.,*)10^-4.,10^-3.,10^-2.},Table[10^\[Theta]N,{\[Theta]N,Log10[3*10^-2.],Log10[0.5],0.25}],Table[10^\[Theta]N,{\[Theta]N,Log10[0.52],Log10[Pi],0.1}],{Pi}]//N//DeleteDuplicates//Developer`ToPackedArray;*)
(*(*The block that computes the smooth pdf Subscript[f, \[Theta],E] from the data BoostedData in the form Log[\[Theta]],Log[E]*)*)
(*FromDataToSmoothDistribution[BoostedData_,mass_,Facility_,IfTesting_]:=Block[{},*)
(*{\[Theta]minDistr,\[Theta]maxDistr}=MinMax[BoostedData[[All,1]]];*)
(*{EminDistr,EmaxDistr}=MinMax[BoostedData[[All,2]]];*)
(*vals\[Theta]=Join[Select[\[Theta]listBinning[Facility],#<\[Theta]maxDistr&],{\[Theta]maxDistr}];*)
(*If[Facility=="ESS",*)
(*valsE=ENlist["ESS"],*)
(*valsE=Join[{0.97EminDistr},With[{start=EminDistr,end=EmaxDistr},*)
(*NestWhileList[#+StepEtemp[#]&,start,#<=end&,1,\[Infinity],-1]],{EmaxDistr,1.03EmaxDistr}]//N//DeleteDuplicates;*)
(*];*)
(*bcc=BinCounts[BoostedData,{vals\[Theta]},{valsE}];*)
(*tabpdf=Flatten[Table[{(vals\[Theta][[i]]+vals\[Theta][[i+1]])/2,(valsE[[j]]+valsE[[j+1]])/2,Max[10^-90.,bcc[[i]][[j]]/((valsE[[j+1]]-valsE[[j]])*(vals\[Theta][[i+1]]-vals\[Theta][[i]]))]},{i,1,Length[vals\[Theta]]-1,1},{j,1,Length[valsE]-1,1}],1];*)
(*{thmin,thmax,emin,emax}={tabpdf[[All,1]]//Min,Min[Pi,tabpdf[[All,1]]//Max],tabpdf[[All,2]]//MinMax}//Flatten//N;*)
(*(*DoubleDistr[\[Theta]LLP_,ELLP_]=If[emin<=ELLP<=emax&&thmin<=\[Theta]LLP<=thmax,Evaluate[1/Length[BoostedData]Interpolation[tabpdf,InterpolationOrder->1][\[Theta]LLP,ELLP]],10^-90.];*)*)
(*DoubleDistr[\[Theta]LLP_,ELLP_]=If[emin<=ELLP<=emax&&thmin<=\[Theta]LLP<=thmax,Evaluate[1/Length[BoostedData] Interpolation[{Log[#[[1]]],Log[#[[2]]],#[[3]]}&/@tabpdf,InterpolationOrder->1][Log[\[Theta]LLP],Log[ELLP]]],10^-90.];*)
(*(*DoubleDistr[\[Theta]LLP_,ELLP_]=If[emin<=ELLP<=emax&&thmin<=\[Theta]LLP<=thmax,Evaluate[1/Length[BoostedData]10^(Interpolation[Log10[tabpdf],InterpolationOrder->1][Log10[\[Theta]LLP],Log10[ELLP]])],10^-90.];*)*)
(*collopt=MemberQ[{"LHC","FCC-hh"},Facility];*)
(*If[collopt,DoubleDistr[\[Theta]LLP_,ELLP_]=1/2 (DoubleDistr[\[Theta]LLP,ELLP]+DoubleDistr[Pi-\[Theta]LLP,ELLP])];*)
(*(*_______________________________________*)*)
(*(*For cross-checks. Uncomment if needed*)*)
(*(*_______________________________________*)*)
(*If[IfTesting=="True",*)
(*normPDF=If[collopt,2,1]*NIntegrate[DoubleDistr[Exp[x],Exp[y]]Exp[x+y],{x,Log[thmin],Log[thmax]},{y,Log[emin],Log[emax]},Method->"InterpolationPointsSubdivision"];*)
(*{tabpdf\[Theta]temp,tabpdfEtemp}={BinCounts[BoostedData[[All,1]],{vals\[Theta]}],BinCounts[BoostedData[[All,2]],{valsE}]};*)
(*tabpdf\[Theta]=Table[{(vals\[Theta][[i]]+vals\[Theta][[i+1]])/2,Max[10^-90.,tabpdf\[Theta]temp[[i]]/(vals\[Theta][[i+1]]-vals\[Theta][[i]])]},{i,1,Length[vals\[Theta]]-1,1}];*)
(*tabpdfE=Table[{(valsE[[i]]+valsE[[i+1]])/2,Max[10^-90.,tabpdfEtemp[[i]]/(valsE[[i+1]]-valsE[[i]])]},{i,1,Length[valsE]-1,1}];*)
(*AngleDistr[\[Theta]LLP_]=If[thmin<=\[Theta]LLP<=thmax,Evaluate[1/Length[BoostedData] (Interpolation[Log[tabpdf\[Theta]],InterpolationOrder->1][Log[\[Theta]LLP]]//Exp)],0.];*)
(*EnergyDistr[ELLP_]=If[emin<= ELLP<=emax,Evaluate[1/Length[BoostedData] Interpolation[tabpdfE,InterpolationOrder->1][ELLP]],0.];*)
(*If[MemberQ[{"LHC","FCC-hh"},Facility]==True,AngleDistr[\[Theta]LLP_]=1/2 (AngleDistr[\[Theta]LLP]+AngleDistr[Pi-\[Theta]LLP])];*)
(*];*)
(*(*_______________________________________*)*)
(*(*Old method. Much slower*)*)
(*(*_______________________________________*)*)
(*(*smoothkerneldistrX=SmoothKernelDistribution[BoostedData,"LeastSquaresCrossValidation",{"Bounded",{{Log\[Theta]minDistr,Log\[Theta]maxDistr},{LogEminDistr,LogEmaxDistr}},"Gaussian"},MaxMixtureKernels\[Rule]All,InterpolationPoints\[Rule]300,MaxExtraBandwidths\[Rule]0];*)
(*(*Double and marginal PDFs*)*)
(*DoubleDistr[\[Theta]LLP_,ELLP_]=If[Exp[Log\[Theta]minDistr]\[LessEqual]\[Theta]LLP\[LessEqual]Exp[Log\[Theta]maxDistr]&&mass\[LessEqual] ELLP\[LessEqual]Exp[LogEmaxDistr],Evaluate[1/\[Theta]LLP1/ELLPPDF[smoothkerneldistrX,{Log[\[Theta]LLP],Log[ELLP]}],0]];*)
(*AngleDistr[\[Theta]LLP_]=If[Exp[Log\[Theta]minDistr]\[LessEqual]\[Theta]LLP\[LessEqual]Exp[Log\[Theta]maxDistr],Evaluate[1/\[Theta]LLPPDF[MarginalDistribution[smoothkerneldistrX,1],Log[\[Theta]LLP]],0]];*)
(*EnergyDistr[ELLP_]=If[mass\[LessEqual] ELLP\[LessEqual]Exp[LogEmaxDistr],Evaluate[1/ELLPPDF[MarginalDistribution[smoothkerneldistrX,2],Log[ELLP]],0]];*)*)
(*]*)


(* ::Section::Closed:: *)
(*Tabulated distribution and its exporting*)


(* ::Input:: *)
(*TabZeroDistr[mLLP_,\[Theta]list_,Elist_]:=Flatten[Table[{mLLP,\[Theta]N,EN,10^-90.},{\[Theta]N,\[Theta]list},{EN,Elist}],1]*)
(*(*This block produces the tabulated PDF for the fixed mass mLLP. Tabulation is for the values of \[Theta],E belonging to \[Theta]list, Elist*)*)
(*(*The argument Subscript[\[Theta], extr] defines the angle below which the angular distribution is just ~sin(\[Theta]) (the true distribution has wiggles there due to low statistics*)*)
(*BlockTabulatedPDFsFromDecaysMass[LLP_,Facility_,mLLP_,process_,Nevents_,\[Theta]list_,Elist_,\[Theta]minExtr_,IfTesting_]:=Module[{tab1,(*boosteddata,*)maxmass},*)
(*maxmass=MaxMass[LLP,Facility,process];*)
(*If[mLLP<maxmass,*)
(*(*If the mother particle is at rest, then the angle-energy distribution of the daughter is just the product of (sin(Subscript[\[Theta], LLP]))/2*f[Subscript[E, LLP]], 0 < Subscript[\[Theta], LLP] < Pi, and with f normalized by one*)*)
(*If[Facility=="ESS"&&MemberQ[{"mu","PiCharged"},process],*)
(*DoubleDistr[\[Theta]LLP_,ELLP_]=\[Theta]EdistrRest[LLP,process,mLLP,\[Theta]LLP,ELLP],*)
(*(*If the mother particle is not at rest, the launch the routine calculating the phase space at rest and boosting it to lab frame of the mother particle*)*)
(*(*Producing the boosted LLPs from the given decay process*)*)
(*boosteddata=If[MemberQ[ListHNLs,LLP],BoostedHNLsBlock[LLP,Facility,mLLP,process,Nevents],BoostedLLPsBlock[LLP,Facility,mLLP,process,Nevents]]//Developer`ToPackedArray;*)
(*(*Making the PDF. It defines the functions DoubleDist[\[Theta],E],AngleDistr[\[Theta]],EnergyDistr[E], which are PDF in these variables*)*)
(*FromDataToSmoothDistribution[boosteddata,mLLP,Facility,IfTesting]*)
(*];*)
(*(*The tabulated distribution*)*)
(*tab1=Flatten[Table[{mLLP,\[Theta]LLP,ELLP,If[\[Theta]LLP<\[Theta]minExtr,\[Theta]LLP/\[Theta]minExtr DoubleDistr[\[Theta]minExtr,ELLP],DoubleDistr[\[Theta]LLP,ELLP]]},{\[Theta]LLP,\[Theta]list},{ELLP,Elist}],1]*)
(*];*)
(*If[mLLP>=maxmass,*)
(*tab1=TabZeroDistr[mLLP,\[Theta]list,Elist];*)
(*];*)
(*tab1*)
(*]*)
(*(*filenameToExport["HNL-mixing-e","B","LHC"]*)*)


(* ::Subsection::Closed:: *)
(*Test*)


(* ::Input:: *)
(*TestingBlock[LLP_,Facility_,mLLP_,process_,Nev_,\[Theta]list_,Elist_,\[Theta]extr_]:=Block[{},*)
(*Quiet[BlockTabulatedPDFsFromDecaysMass[LLP,Facility,mLLP,process,Nev,\[Theta]list,Elist,\[Theta]extr,"True"]];*)
(*normtab={{"\!\(\*SubscriptBox[\(Normalization\), \(PDF[\[Theta], E]\)]\)", "\!\(\*SubscriptBox[\(Normalization\), \(PDF[\[Theta]]\)]\)","\!\(\*SubscriptBox[\(Normalization\), \(PDF[E]\)]\)"},{normPDF,If[collopt,2,1]*NIntegrate[AngleDistr[\[Theta]LLP],{\[Theta]LLP,thmin,Min[thmax,Pi]},Method->"InterpolationPointsSubdivision"],NIntegrate[EnergyDistr[ELLP],{ELLP,emin,emax},Method->"InterpolationPointsSubdivision"]}};*)
(*angdistr2data=ParallelTable[{10^x,If[collopt,1/2,1]*Quiet[NIntegrate[DoubleDistr[10^x,Exp[y]]Exp[y],{y,Log[emin],Log[emax]},Method->"AdaptiveMonteCarlo"]]},{x,Log10[thmin],Log10[Pi/2.],0.05}];*)
(*angdistr2[\[Theta]X_]=Interpolation[Log[angdistr2data],InterpolationOrder->1][Log[\[Theta]X]]//Exp;*)
(*pt1=LogLogPlot[Evaluate[{If[collopt,1/2,1]*AngleDistr[x],If[x<thextr,Evaluate[x/thextr angdistr2[thextr]],Evaluate[angdistr2[x]]]}],{x,thmin,Pi/2},Frame->True,FrameStyle->Directive[Black, 20],PlotRange->{{thmin,Pi/2},{10^-4,2*(angdistr2data[[All,2]]//Max)}},ImageSize->Large,FrameLabel->{"\[Theta] [rad]","PDF[\[Theta]]"},PlotLegends->Placed[Style[#,16]&/@{"data->PDF[\[Theta]]","data->PDF[\[Theta],E]->PDF[\[Theta]]"},{0.25,0.2}],PlotStyle->{{Thickness[0.003],Blue},{Thickness[0.003],Darker@Red},{Thickness[0.003],Darker@Green},{Thickness[0.003],Darker@Red,Dashing[0.02]},{Thickness[0.003],Blue,Dashing[0.02]},{Thickness[0.003],Darker@Green,Dashing[0.02]}}(*,PlotLabel\[Rule]Style[Row[{"Normalized on events with 2<Subscript[\[Eta], B]<5"}],18,Black]*)];*)
(*endistr2data=ParallelTable[{10^x,If[collopt,2,1]*Quiet[NIntegrate[DoubleDistr[Exp[y],10^x]Exp[y],{y,Log[thmin],Log[thmax]},Method->"AdaptiveMonteCarlo"]]},{x,Log10[emin],Log10[emax],0.015}];*)
(*endistr2[EX_]=Interpolation[Log[endistr2data],InterpolationOrder->1][Log[EX]]//Exp;*)
(*pt2=LogLogPlot[Evaluate[{EnergyDistr[x],endistr2[x]}],{x,emin,emax},Frame->True,FrameStyle->Directive[Black, 20],PlotRange->{{emin,emax},{10^-10,2*(endistr2data[[All,2]]//Max)}},ImageSize->Large,FrameLabel->{"E [GeV]","PDF[E]"},PlotLegends->Placed[Style[#,16]&/@{"data->PDF[E]","data->PDF[\[Theta],E]->PDF[E]"},{0.25,0.2}],PlotStyle->{{Thickness[0.003],Blue},{Thickness[0.003],Darker@Red},{Thickness[0.003],Darker@Green},{Thickness[0.003],Darker@Red,Dashing[0.02]},{Thickness[0.003],Blue,Dashing[0.02]},{Thickness[0.003],Darker@Green,Dashing[0.02]}}(*,PlotLabel\[Rule]Style[Row[{"Normalized on events with 2<Subscript[\[Eta], B]<5"}],18,Black]*)];*)
(*pdfplots=Style[Row[{pt1,pt2}],ImageSizeMultipliers->{1, 1}];*)
(*histoenergy=With[{min=Min[boosteddata[[All,2]]],max=Max[PTS[[All,2]]]},Histogram[Evaluate[{(*erand//Exp,*)PTS[[All,2]],boosteddata[[All,2]]}],{min,max,(max-min)/100},"ProbabilityDensity",ScalingFunctions->{"Log","Log"},PlotRange->{{min,max},All},Frame-> True,ChartStyle->{Opacity[.25,Red],Opacity[.25,Blue],Opacity[.25,Darker@Darker@Green]},FrameStyle->Directive[Black, 22],ImageSize->Large,FrameLabel->{"E, GeV","Fraction"},PlotLabel->Style[Row[{LLPtest,", ",fac,", production: ",prodtest,", \!\(\*SubscriptBox[\(m\), \(LLP\)]\) = ", masstest," GeV"}],18,Black],ChartLegends->Placed[{(*"Subscript[mother, unweighted]",*)"mother",LLPtest},Bottom]]];*)
(*histoangle=With[{min=Min[PTS[[All,1]]],max=Max[boosteddata[[All,1]]]},Histogram[Evaluate[{(*\[Theta]rand//Exp,*)PTS[[All,1]],boosteddata[[All,1]]}],{min,max,(max-min)/100},"ProbabilityDensity",ScalingFunctions->{"Log","Log"},PlotRange->{{min,max},All},Frame-> True,ChartStyle->{Opacity[.25,Red],Opacity[.25,Blue],Opacity[.25,Darker@Darker@Green]},FrameStyle->Directive[Black, 22],ImageSize->Large,FrameLabel->{"\[Theta], rad","Fraction"},PlotLabel->Style[Row[{LLPtest,", ",fac,", production: ",prodtest,", \!\(\*SubscriptBox[\(m\), \(LLP\)]\) = ", masstest," GeV"}],18,Black],ChartLegends->Placed[{(*"Subscript[mother, unweighted]",*)"mother",LLPtest},Bottom]]];*)
(*histoplots=Style[Row[{histoangle,histoenergy}],ImageSizeMultipliers->{1, 1}];*)
(*testdata={histoplots,normtab,pdfplots}*)
(*]*)
(*IfTest=0;*)
(*If[IfTest==1,*)
(*fac="LHC";*)
(*num=10^7;*)
(*masstest=3.;*)
(*LLPtest="Scalar";*)
(*prodtest="B-mixing";*)
(*thextr=0.5*10^-3;*)
(*TestingBlock[LLPtest,fac,masstest,prodtest,num,\[Theta]Nlist[fac],ENlist[fac],thextr]*)
(*]*)


(* ::Chapter::Closed:: *)
(*Production via mixing (following 2201.05170): PDF*)


(* ::Section::Closed:: *)
(*Subscript[\[Theta], mother],Subscript[E, mother]->Subscript[\[Theta], LLP],Subscript[E, LLP], following 2201.05170*)


(* ::Input:: *)
(*LLPkinematicsMixing=Hold@Compile[{{mdata,_Real,1},{mLLP,_Real},{Eplab,_Real},{IfCollider,True|False},{IfESS,True|False}},Module[{\[Theta]llpFin=0.,ellpFin=0.,pboost=0.,emes=0.,pxmes=0.,pymes=0.,pzmes=0.,mmes=0.,pzmesCM=0.,pzllpCM=0.,ellpCM=0.,pxllpLab=0.,pyllpLab=0.,pzllpLab=0.},*)
(*pboost=Sqrt[Eplab^2-0.938^2];*)
(*emes=Compile`GetElement[mdata,4];*)
(*pxmes=Compile`GetElement[mdata,1];*)
(*pymes=Compile`GetElement[mdata,2];*)
(*pzmes=Compile`GetElement[mdata,3];*)
(*mmes=Compile`GetElement[mdata,5];*)
(*(*If the facility is beam dump, then boost the meson's kinematics to CM frame, relate it to the LLP's kinematics, and boost back. Otherwise (if it is collider), simply renormalize the LLP energy*)*)
(*If[!IfCollider,*)
(*(*Meson's and LLP's kinematics at CM frame, assuming that their CM momenta are the same. It is also assumed that the boost is in the z direction*)*)
(*pzmesCM=pzllpCM=pproductLab3Cart[0.,0.,-pboost,Eplab,0.938,pxmes,pymes,pzmes,emes];*)
(*ellpCM=Sqrt[pxmes^2+pymes^2+pzllpCM^2+mLLP^2];*)
(*(*LLP's kinematics at lab frame*)*)
(*pxllpLab=pxmes;*)
(*pyllpLab=pymes;*)
(*pzllpLab=pproductLab3Cart[0.,0.,pboost,Eplab,0.938,pxmes,pymes,pzllpCM,ellpCM];*)
(*ellpFin=Sqrt[pxllpLab^2+pyllpLab^2+pzllpLab^2+mLLP^2];*)
(*(*Warning! If relating the angle of the LLP to the meson angle by boosting to CM frame, inadequate results may be produced. I am working on improved approach of the production via mixing*)*)
(*\[Theta]llpFin=If[!IfESS,ArcCos[pzllpLab/Sqrt[pxllpLab^2+pyllpLab^2+pzllpLab^2]],ArcCos[pzmes/Sqrt[pxmes^2+pymes^2+pzmes^2]]];*)
(*,*)
(*ellpFin=Sqrt[pxmes^2+pymes^2+pzmes^2+mLLP^2];*)
(*\[Theta]llpFin=ArcCos[Abs[pzmes]/Sqrt[pxmes^2+pymes^2+pzmes^2]];*)
(*];*)
(*{\[Theta]llpFin,ellpFin}*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{pproductLab3Cart}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@LLPkinematicsMixing;*)
(*(*(*Subscript[p, CM] (proton-proton collisions) in terms of Subscript[p, lab] assuming that Subscript[p, lab] is aligned along the boost*)*)
(*PcmPlab[plab_,m_,Eplab_,mp_]=Assuming[mp>0&&Eplab>0,Simplify[\[Gamma]CMbeamDump[Eplab,mp](plab-vCMbeamDump[Eplab,mp]*Sqrt[plab^2+m^2])]];*)
(*(*inverse relation*)*)
(*PlabPcm[pcm_,m_,Eplab_,mp_]=plab/.Solve[PcmPlab[plab,m,Eplab,mp]\[Equal]pcm,plab][[2]]//Simplify;*)
(*(*Relation between the meson and DP energies and angles in the CM frame. Obtained under assumption that at the CM frame of proton-proton collisions the meson and DP |momenta| are the same*)*)
(*EcmMesonEcmLLP[EV_,mV_,mmeson_]=Sqrt[EV^2-mV^2+mmeson^2];*)
(*(*Relation between meson and DP kinematics in lab frame. Obtained under assumption that at the CM frame of proton-proton collisions the meson and DP |momenta| are the same*)*)
(*plabMesonElabLLP[EV_,mmeson_,mV_,Eplab_,mp_]=Assuming[EV>0,Simplify[PlabPcm[PcmPlab[Sqrt[EV^2-mV^2],mV,Eplab,mp],mmeson,Eplab,mp]]];*)
(*ElabMesonElabDP[EV_,mmeson_,mV_,Eplab_,mp_]=Sqrt[plabMesonElabLLP[EV,mmeson,mV,Eplab,mp]^2+mmeson^2];*)
(*\[Theta]labMeson\[Theta]ElabDP[EV_,\[Theta]V_,mmeson_,mV_,Eplab_,mp_]=ArcSin[Sin[\[Theta]V]Sqrt[EV^2-mV^2]/plabMesonElabLLP[EV,mmeson,mV,Eplab,mp]];*)
(*(*If Subscript[E, a] < Subscript[E, a,min], then there is no solution Subscript[E, meson](Subscript[E, a])*)*)
(*EVminBeamDump[mmeson_,mV_,Eplab_,mp_]=EV/.Solve[plabMesonElabLLP[EV,mmeson,mV,Eplab,mp]\[Equal]0,EV][[4]];*)
(*EVminCM[mmeson_,mV_]=If[mV>mmeson,Evaluate[EV/.Solve[EcmMesonEcmLLP[EV,mV,mmeson]\[Equal]0,EV][[2]]],mV];*)
(*(*Jacobian Subscript[E, meson],Subscript[\[Theta], meson] \[Rule] Subscript[E, a],Subscript[\[Theta], a]*)*)
(*Jacobian\[Theta]mesonEmesonTo\[Theta]VEVBeamDump[Eplab_,mp_,mmeson_,mV_,\[Theta]V_,EV_]=Abs[D[\[Theta]labMeson\[Theta]ElabDP[EV,\[Theta]V,mmeson,mV,Eplab,mp],\[Theta]V]*D[ElabMesonElabDP[EV,mmeson,mV,Eplab,mp],EV]-D[\[Theta]labMeson\[Theta]ElabDP[EV,\[Theta]V,mmeson,mV,Eplab,mp],EV]*D[ElabMesonElabDP[EV,mmeson,mV,Eplab,mp],\[Theta]V]]//Simplify;*)
(*JacobianEmesonToEVCollider[EV_,mV_,mmeson_]=D[EcmMesonEcmLLP[EV,mV,mmeson],EV];*)*)


(* ::Section::Closed:: *)
(*Distribution of LLPs obtained using the transformation Subscript[E, meson],Subscript[\[Theta], meson] ->Subscript[E, LLP], Subscript[\[Theta], LLP]*)


(* ::Input:: *)
(*BlockTabulatedPDFsFromMixingsMass[LLP_,Facility_,mLLP_,process_,Nevents_,\[Theta]list_,Elist_,\[Theta]minExtr_]:=Module[{},*)
(*maxmass=MaxMass[LLP,Facility,process];*)
(*If[mLLP<maxmass,*)
(*partcontent=ReactionProductsList[LLP,process];*)
(*meson=partcontent[[1]];*)
(*mmeson=mSM[meson];*)
(*elab=EmaxFacility[Facility];*)
(*If[Length[MotherPoints[meson,Facility,"False"]]!=Nevents,*)
(*MotherPoints[meson,Facility,"False"]=PointsSampler[Facility,meson,Nevents,"False"];*)
(*];*)
(*IfCollider=MemberQ[{"LHC","FCC-hh"},Facility];*)
(*IfESS=Facility=="ESS";*)
(*\[Theta]Edata=LLPkinematicsMixing[MotherPoints[meson,Facility,"False"],mLLP,elab,IfCollider,IfESS];*)
(*FromDataToSmoothDistribution[\[Theta]Edata,mLLP,Facility,"False"];*)
(*(*The tabulated distribution*)*)
(*tab1=Flatten[Table[{mLLP,\[Theta]LLP,ELLP,If[\[Theta]LLP<\[Theta]minExtr,\[Theta]LLP/\[Theta]minExtr DoubleDistr[\[Theta]minExtr,ELLP],DoubleDistr[\[Theta]LLP,ELLP]]},{\[Theta]LLP,\[Theta]list},{ELLP,Elist}],1];*)
(*];*)
(*If[mLLP>=maxmass,*)
(*tab1=TabZeroDistr[mLLP,\[Theta]list,Elist];*)
(*];*)
(*tab1*)
(*]*)
(*(*DoubleDistrLLPfromMixing[mLLP_,meson_,Facility_]:=Module[{mmeson,elab},*)
(*(*This block produces the interpolation of the mother distribution function *)*)
(*mmeson=mSM[meson];*)
(*elab=EmaxFacility[Facility];*)
(*distr[th_,e_]=DoubleDistrMotherInt[th,e,Facility,meson];*)
(*If[!MemberQ[{"FCC-hh","LHC"},Facility],*)
(*If[Facility!="ESS",*)
(*distrmixing[\[Theta]LLP_,ELLP_]=If[ELLP>Max[mLLP,EVminBeamDump[mmeson,mLLP,elab,mSM["p"]]]&&0<Sin[\[Theta]LLP]Sqrt[ELLP^2-mLLP^2]/plabMesonElabLLP[ELLP,mmeson,mLLP,elab,mSM["p"]]<1,Evaluate[Jacobian\[Theta]mesonEmesonTo\[Theta]VEVBeamDump[elab,mSM["p"],mmeson,mLLP,\[Theta]LLP,ELLP]*distr[\[Theta]labMeson\[Theta]ElabDP[ELLP,\[Theta]LLP,mmeson,mLLP,elab,mSM["p"]],ElabMesonElabDP[ELLP,mmeson,mLLP,elab,mSM["p"]]]],0.];*)
(*,*)
(*(*distrmixingTemp[\[Theta]LLP_,ELLP_]=If[ELLP>mLLP,Evaluate[distr[\[Theta]LLP,ELLP]],0.];*)
(*distrmixingNorm=NIntegrate[distrmixingTemp[Exp[\[Theta]LLP],Exp[ELLP]]Exp[\[Theta]LLP+ELLP],{\[Theta]LLP,Log[10^-5.],Log[Pi-10^-5.]},{ELLP,Log[mLLP],Log[elab]},Method->"InterpolationPointsSubdivision"];*)
(*distrmixing[\[Theta]LLP_,ELLP_]=distrmixingTemp[\[Theta]LLP,ELLP]/distrmixingNorm;*)*)
(*distrmixing[\[Theta]LLP_,ELLP_]=If[ELLP>Max[mLLP,EVminBeamDump[mmeson,mLLP,elab,mSM["p"]]]&&0<Sin[\[Theta]LLP]Sqrt[ELLP^2-mLLP^2]/plabMesonElabLLP[ELLP,mmeson,mLLP,elab,mSM["p"]]<1,Evaluate[Jacobian\[Theta]mesonEmesonTo\[Theta]VEVBeamDump[elab,mSM["p"],mmeson,mLLP,\[Theta]LLP,ELLP]*distr[\[Theta]labMeson\[Theta]ElabDP[ELLP,\[Theta]LLP,mmeson,mLLP,elab,mSM["p"]],ElabMesonElabDP[ELLP,mmeson,mLLP,elab,mSM["p"]]]],0.];*)
(*]*)
(*,*)
(*distrmixing[\[Theta]LLP_,ELLP_]=If[ELLP>Max[mLLP,EVminCM[mmeson,mLLP]],Evaluate[JacobianEmesonToEVCollider[ELLP,mLLP,mmeson]*distr[\[Theta]LLP,EcmMesonEcmLLP[ELLP,mLLP,mmeson]]],0.];*)
(*];*)
(*distrmixing[\[Theta]LLP,ELLP]*)
(*]*)
(*BlockTabulatedPDFsFromMixing[LLP_,Facility_,mLLP_,mode_,\[Theta]list_,Elist_]:=Module[{(*meson,distr,tab1,maxmass*)},*)
(*meson=ReactionProductsList[LLP,mode][[1]];*)
(*If[!IfMotherInterpolated[Facility,meson],MotherInterpolation[Facility,meson]];*)
(*distrMixing[\[Theta]LLP_,ELLP_]=DoubleDistrLLPfromMixing[mLLP,meson,Facility];*)
(*maxmass=MaxMass[LLP,Facility,mode];*)
(*If[mLLP<maxmass,*)
(*tab1=Quiet[Flatten[Table[{mLLP,\[Theta]LLP,ELLP,distrMixing[\[Theta]LLP,ELLP]},{\[Theta]LLP,\[Theta]list},{ELLP,Elist}],1]];*)
(*];*)
(*If[mLLP>=maxmass,*)
(*tab1=TabZeroDistr[mLLP,\[Theta]list,Elist];*)
(*];*)
(*tab1*)
(*]*)*)


(* ::Chapter::Closed:: *)
(*Production via bremsstrahlung: PDF and normalization*)


(* ::Input:: *)
(*mVminFromBrem=0.02;*)
(*mVmaxFromBrem["SPS"]=mVmaxFromBrem["LHC"]=mVmaxFromBrem["FCC-hh"]=5.;*)
(*mVmaxFromBrem["Serpukhov"]=mVmaxFromBrem["FermilabBD"]=3.;*)
(*BlockTabulatedPDFsFromBrem[LLP_,Facility_,Description_]:=Module[{ProdBremExportName,DistrBremName,scales,mmax,mrangeProdProb,mrangeDistr,distrbrem,pbeam,eminbrem,normdata,tabdistrbrem,\[Theta]maxAbs,\[Theta]gridBrem,ELLPgridBrem(*pbeam,eminbrem,\[Theta]Vlistbrem,EvlistBremTemp,EvlistBrem,\[Theta]list1*),mlistbrem},*)
(*pbeam=EmaxFacility[Facility];*)
(*eminbrem=ELLPminBrem[Facility];*)
(*intmethod="AdaptiveMonteCarlo";*)
(*ProdBremExportName=FileNameJoin[{NotebookDirectory[],"phenomenology/"<>LLP<>"/Production probabilities/Pbrem_"<>LLP<>"_"<>Description<>"_"<>Facility<>".m"}];*)
(*DistrBremName=If[LLP=="Scalar","Bremsstrahlung-"<>Description<>"-mixing","Bremsstrahlung-"<>Description];*)
(*If[Description=="Baseline",*)
(*(*Defining non-normalized distribution*)*)
(*distrbrem[mV_,\[Theta]V_,EV_]=FluxBrem[mV,\[Theta]V,EV,LLP,Description,Facility]/FormFactorSquaredBrem[mV,LLP];*)
(*(*Computing the normalization*)*)
(*mlistbrem=Join[{10^-3.},Table[mV,{mV,mVminFromBrem,mVmaxFromBrem[Facility],(mVmaxFromBrem[Facility]-mVminFromBrem)/25}]];*)
(*normdata=ParallelTable[{mV,NIntegrate[distrbrem[mV,\[Theta]V,EV],{\[Theta]V,10^-6.,\[Theta]maxBremBaseline[Facility]},{EV,eminbrem,Max[eminbrem,ELLPmaxBremBaseline[Facility,mV,\[Theta]V]]},Method->intmethod]},{mV,mlistbrem}];*)
(*normBrem[mV_]=Interpolation[normdata//Log,InterpolationOrder->1][Log[mV]]//Exp;*)
(*(*The distribution normalized by 1*)*)
(*DoubleDistrBrem[mV_,\[Theta]V_,EV_]=If[EV<EmaxFacility[Facility]*zMaxBrem[Facility],Evaluate[distrbrem[mV,\[Theta]V,EV]/normBrem[mV]],0.];*)
(*(*Exporting bremsstrahlung probabilities and maximal energy as a function of \[Theta]*)*)
(*Export[ProdBremExportName,{normBrem[mLLP]*FormFactorSquaredBrem[mLLP,LLP],eminbrem,\[Theta]maxBremBaseline[Facility],ELLPmaxBremBaseline[Facility,mLLP,\[Theta]LLP]},"MX"];*)
(*(*Tabulated normalized distribution*)*)
(*tabdistrbrem=Flatten[Table[{mV,\[Theta]V,EV,DoubleDistrBrem[mV,\[Theta]V,EV]},{mV,mlistbrem},{\[Theta]V,\[Theta]LLPgridBremBaseline[Facility]},{EV,ELLPgridBremBaseline[Facility]}],{1,2,3}];*)
(*Export[filenameToExport[LLP,DistrBremName,Facility],tabdistrbrem,"MX"]*)
(*];*)
(*If[MemberQ[{"AP","FR"},Description],*)
(*(*Defining the lower and upper boundaries for the production probability. Determined by the choice of the proton virtuality scale Subscript[\[CapitalLambda], p] and the elastic ppX form-factor*)*)
(*{\[CapitalLambda]pVal["Lower"],\[CapitalLambda]pVal["Central"],\[CapitalLambda]pVal["Upper"]}={0.5,1.,2.};*)
(*scales=Keys[DownValues@\[CapitalLambda]pVal][[All,1,1]];*)
(*mmax["Lower"]=mmax["Upper"]=mmax["Central"]=mVmaxFromBrem[Facility];*)
(*Do[*)
(**)
(*(*________________________________________________________*)*)
(*(*Mass grids*)*)
(*(*________________________________________________________*)*)
(*(*Temporary assignment of different maximal masses for the dark photon*)*)
(*If[LLP=="DP",*)
(*(*Dark photons*)*)
(*mrangeProdProb[ff]=Join[Table[m,{m,0.01,1.99,0.01}],{0.001,0.775,1.018,1.022,0.78},Table[m,{m,2.,mVmaxFromBrem[Facility],(mVmaxFromBrem[Facility]-2.)/15.}]]//Sort//DeleteDuplicates;*)
(*mrangeDistr[ff]=Join[Table[m,{m,0.099,1.89,0.2}],{0.001,0.02,0.05,0.775,0.95,1.022,1.99,1.4,1.47,1.53,1.58,1.65},Table[m,{m,2.,mVmaxFromBrem[Facility],(mVmaxFromBrem[Facility]-2.)/15.}]]//Sort//DeleteDuplicates;*)
(*distrbrem[mV_,\[Theta]V_,EV_,ff]=FluxBrem[mV,\[Theta]V,EV,LLP,Description,Facility,ff,\[CapitalLambda]pVal[ff]];*)
(*,*)
(*mrangeProdProb[ff]=mrangeDistr[ff]=Join[Table[10^x,{x,-3.,Log10[0.45],(Log10[0.45]+3.)/10}],Table[mV,{mV,0.5,mVmaxFromBrem[Facility],(mVmaxFromBrem[Facility]-0.5)/25}]];*)
(*distrbrem[mV_,\[Theta]V_,EV_,ff]=FluxBrem[mV,\[Theta]V,EV,LLP,Description,Facility,ff,\[CapitalLambda]pVal[ff]]/FormFactorSquaredBrem[mV,LLP];*)
(*];*)
(*(*Calculating the maximal polar angle for which the brem distribution is non-zero, as well as the specific grids in \[Theta],E for the tabulated distribution*)*)
(*{\[Theta]maxAbs[ff],\[Theta]gridBrem[ff],ELLPgridBrem[ff]}=GridBremAP[\[CapitalLambda]pVal[ff],Facility];*)
(*(*normdata[ff]=ParallelTable[{mV,Mean[Table[Quiet[NIntegrate[distrbrem[mV,\[Theta]V,EV,ff],{\[Theta]V,10^-6.,\[Theta]maxAbs[ff]},{EV,eminbrem,ELLPmaxBremAP[Facility,mV,\[Theta]V,\[CapitalLambda]pVal[ff]]},Method->intmethod]],5]]},{mV,mrangeProdProb[ff]}];*)*)
(*normdata[ff]=ParallelTable[{mV,Quiet[NIntegrate[distrbrem[mV,\[Theta]V,EV,ff],{\[Theta]V,10^-6.,\[Theta]maxAbs[ff]},{EV,eminbrem,ELLPmaxBremAP[Facility,mV,\[Theta]V,\[CapitalLambda]pVal[ff]]},Method->"QuasiMonteCarlo"]]},{mV,mrangeProdProb[ff]}];*)
(*normBrem[mV_,ff]=Interpolation[normdata[ff]//Log,InterpolationOrder->1][Log[mV]]//Exp;*)
(*DoubleDistrBrem[mV_,\[Theta]V_,EV_,ff]=distrbrem[mV,\[Theta]V,EV,ff]/normBrem[mV,ff];*)
(*tabdistrbrem[ff]=Flatten[Table[{mV,\[Theta]V,EV,If[\[Theta]V<=1.3\[Theta]maxAbs[ff],DoubleDistrBrem[mV,\[Theta]V,EV,ff],0.]},{mV,mrangeDistr[ff]},{\[Theta]V,\[Theta]gridBrem[ff]},{EV,ELLPgridBrem[ff]}],{1,2,3}];*)
(*,{ff,scales}];*)
(*Export[ProdBremExportName,{#,If[LLP=="DP",1,FormFactorSquaredBrem[mLLP,LLP]]*normBrem[mLLP,#],eminbrem,\[Theta]maxAbs[#],ELLPmaxBremAP[Facility,mLLP,\[Theta]LLP,\[CapitalLambda]pVal[#]]}&/@scales,"MX"];*)
(*Export[filenameToExport[LLP,DistrBremName,Facility],{#,tabdistrbrem[#]}&/@scales,"MX"]*)
(*];*)
(*]*)


(* ::Chapter::Closed:: *)
(*Production via Primakov process: PDF and normalization*)


(* ::Input:: *)
(*BlockTabulatedPDFsFromPrimakov[Facility_,Nucleus_,\[Theta]list_,Elist_]:=Module[{\[Theta]min,\[Theta]max,mlist,filename1,filename2,proc,fipn},*)
(*proc="Primakov";*)
(*fipn="ALP-photon";*)
(*mlist=MassList[fipn,proc,Facility];*)
(*ProbPrimakovTab=Flatten[ParallelTable[{ma,E\[Gamma],Max[10^-90.,1/\[Sigma]\[Gamma]Abs[Nucleus] (Quiet[\[Sigma]PrimakovNucleus[ma,E\[Gamma],mnucleus[Nucleus],anucleus[Nucleus],znucleus[Nucleus]]]+Quiet[\[Sigma]PrimakovNucleons[ma,E\[Gamma],znucleus[Nucleus]]])]},{ma,mlist},{E\[Gamma],ENlist[Facility]}],{1,2}];*)
(*(*Approximation: Subscript[E, a] = Subscript[E, \[Gamma]], Subscript[\[Theta], a] = Subscript[\[Theta], \[Gamma]]*)*)
(*ProbPrimakov[ma_,Ea_]=Exp[Interpolation[Log[ProbPrimakovTab],InterpolationOrder->1][Log[ma],Log[Ea]]];*)
(*MotherInterpolation[Facility,"photon"];*)
(*ALPdoubleFlux[ma_,\[Theta]a_,Ea_]=DoubleDistrMotherInt[\[Theta]a,Ea,Facility,"photon"]*ProbPrimakov[ma,Ea];*)
(*{\[Theta]min,\[Theta]max}=\[Theta]MinMax[Facility,"photon"][[#]]&/@{1,2};*)
(*NormalizationALP[ma_]=Interpolation[ParallelTable[{ma,Quiet[NIntegrate[ALPdoubleFlux[ma,Exp[t],Exp[e]]Exp[t+e],{t,Log[\[Theta]min],Log[\[Theta]max]},{e,Log[ma],Log[Emax[\[Theta]min,Facility,"photon"]]},Method->"InterpolationPointsSubdivision"]]},{ma,mlist}],InterpolationOrder->1][ma];*)
(*DoubleDistrALP[ma_,\[Theta]a_,Ea_]=ALPdoubleFlux[ma,\[Theta]a,Ea]/NormalizationALP[ma];*)
(*filename1=FileNameJoin[{NotebookDirectory[],"spectra/New physics particles spectra",LLPfolder["ALP-photon"],ToString@StringForm["DoubleDistr_``_``-``_``.m",Sequence@@{fipn,proc,Nucleus,Facility}]}];*)
(*filename2=FileNameJoin[{NotebookDirectory[],"phenomenology/",LLPfolder[fipn],"Production probabilities",ToString@StringForm["Pprod_``_``-``_``.m",Sequence@@{fipn,proc,Nucleus,Facility}]}];*)
(*Export[filename1,Flatten[Table[{ma,\[Theta]a,Ea,DoubleDistrALP[ma,\[Theta]a,Ea]},{ma,mlist},{\[Theta]a,\[Theta]list},{Ea,Elist}],{1,2,3}]//Developer`ToPackedArray,"MX"];*)
(*Export[filename2,NormalizationALP[ma],"MX"];*)
(*]*)


(* ::Chapter::Closed:: *)
(*Production via photon fusion: PDF and normalization*)


(* ::Input:: *)
(*TabulatedDistrFusion[m_,Facility_,Nucleus_,\[Theta]list_,Elist_]:=Module[{(*norm,tabulateddistr,distr*)logemin,logemax,logthmin,logthmax},*)
(*distrprob[th_,e_]:=If[!MemberQ[{"LHC","FCC-hh"},Facility],d2Pd\[Theta]adEaFusion1[m,th,e,Facility,Nucleus],d2Pd\[Theta]adEaFusion[m,th,e,Facility,Nucleus]];*)
(*tabulateddistr=Flatten[ParallelTable[{m,th,e,Max[Quiet[distrprob[th,e]],10^-90.]},{th,\[Theta]list},{e,Elist}],1];*)
(*distr[logth_,loge_]=Interpolation[Log[tabulateddistr[[All,{2,3,4}]]],InterpolationOrder->1][logth,loge]//Exp;*)
(*{logthmin,logthmax,logemin,logemax}=Log[Flatten[{MinMax[tabulateddistr[[All,2]]],MinMax[tabulateddistr[[All,3]]]}]];*)
(*norm=Quiet[NIntegrate[distr[logth,loge]Exp[logth+loge],{logth,logthmin,logthmax},{loge,Max[Log[m],logemin],logemax},Method->"InterpolationPointsSubdivision"]];*)
(*{{#[[1]],#[[2]],#[[3]],#[[4]]/norm}&/@tabulateddistr,{m,norm}}*)
(*];*)
(*BlockTabulatedPDFsFromFusion[Facility_,Nucleus_,\[Theta]list_,Elist_]:=Module[{\[Theta]min,\[Theta]max,mlist,filename1,filename2,fipn,procn},*)
(*fipn="ALP-photon";*)
(*procn="Photon-fusion";*)
(*mlist=MassList[fipn,procn,Facility];*)
(*tabphoton=Monitor[Table[TabulatedDistrFusion[mlist[[t]],Facility,Nucleus,\[Theta]list,Elist],{t,1,Length[mlist],1}],Row[{ProgressIndicator[t,{1,Length[mlist]}]," \!\(\*SubscriptBox[\(m\), \(LLP\)]\) = ",mlist[[t]]," GeV"," (",t,"/",Length[mlist],")"}," "]];*)
(*(*Approximation: Subscript[E, a] = Subscript[E, \[Gamma]], Subscript[\[Theta], a] = Subscript[\[Theta], \[Gamma]]*)*)
(*ProbFusion[ma_]=Interpolation[Log[tabphoton[[All,2]]],InterpolationOrder->1][Log[ma]]//Exp;*)
(*DoubleDistrDataTemp=Join[##]&@@tabphoton[[All,1]];*)
(*filename1=FileNameJoin[{NotebookDirectory[],"spectra/New physics particles spectra",LLPfolder[fipn],ToString@StringForm["DoubleDistr_``_``-``_``.m",Sequence@@{fipn,procn,Nucleus,Facility}]}];*)
(*filename2=FileNameJoin[{NotebookDirectory[],"phenomenology/",LLPfolder[fipn],"Production probabilities",ToString@StringForm["Pprod_``_``-``_``.m",Sequence@@{fipn,procn,Nucleus,Facility}]}];*)
(*Export[filename1,DoubleDistrDataTemp//Developer`ToPackedArray,"MX"];*)
(*Export[filename2,ProbFusion[ma],"MX"];*)
(*]*)


(* ::Title::Closed:: *)
(*Choose LLP and run*)


(* ::Chapter::Closed:: *)
(*Some definitions*)


(* ::Input:: *)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*(*The code which evaluates the sections whose tags are included in the list listproduction*)*)
(*headstypes={"Title","Chapter","Section","Subsection","Subsubsection"};*)
(*cells=Association[Table[type->Select[Cells[],CurrentValue[#,"CellStyle"]=={type}&],{type,headstypes}]];*)
(*inp=(#->First@NotebookRead[#])&/@cells["Section"];*)
(*SectionEvaluator[section_]:=Block[{},*)
(*SectionCell=Select[inp,#[[2]]==section&][[1]][[1]];*)
(*If[!(SectionCell=!=$Canceled),infoDialog[Column[{"There is no section/section name associated with the given LLP and production channel: ",section,"Add them"}]],*)
(*If[SectionCell=!=$Canceled,*)
(*SelectionMove[SectionCell,All,CellGroup];*)
(*SelectionEvaluate[InputNotebook[]]];*)
(*]*)
(*]*)
(*BlockProductionComputation[LLP_,prodlist_]:=Module[{seclist},*)
(*seclist=LLP<>"_"<>#&/@prodlist;*)
(*Do[SectionEvaluator[sec],{sec,seclist}]]*)
(*(*Pattern for filename of the tabulated distribution*)*)
(*filenameToExport[LLP_,mode_,facility_]:=FileNameJoin[{NotebookDirectory[],"spectra/New physics particles spectra",LLPfolder[LLP],ToString@StringForm["DoubleDistr_``_``_``.m",Sequence@@{LLP,mode,facility}]}]*)
(*(*This block produces the table m,\[Theta],E,distr for m belonging to mlist. function is BlockTabulatedPDFsFromDecays/Mixing where all the arguments except for mLLP are fixed*)*)
(*tabulatedblock[function_,mlist_,filename_]:=Module[{},*)
(*tabb=Monitor[Table[function[mlist[[t]]],{t,1,Length[mlist],1}],Row[{ProgressIndicator[t,{1,Length[mlist]}],"i = ",t,"/",Length[mlist],", m = ",mlist[[t]]," GeV"}," "]];*)
(*tabb=Flatten[tabb,1]//Developer`ToPackedArray;*)
(*Export[filename,tabb,"MX"];*)
(*]*)
(*(*List of the directories associated with the given LLP*)*)
(*Do[*)
(*If[!StringContainsQ[LLP,"HNL"],LLPfolder[LLP]=LLP,LLPfolder[LLP]="HNL"];*)
(*,{LLP,LLPlist}];*)
(*directories=Join[FileNameJoin[{NotebookDirectory[],#}]&/@{"spectra","spectra/New physics particles spectra"},FileNameJoin[{NotebookDirectory[],"spectra/New physics particles spectra",LLPfolder[#]}]&/@Keys[DownValues@LLPfolder][[All,1,1]]]//DeleteDuplicates;*)
(*Do[If[!DirectoryQ[dir],CreateDirectory[dir]],{dir,directories}]*)


(* ::Chapter::Closed:: *)
(*Selecting LLP, facility, and production channels*)


(* ::Input:: *)
(*NotebookDirectory[]//ParentDirectory;*)
(*(*Facilities*)*)
(*Print["List of implemented LLPs:"]*)
(*LLPlist*)
(*Print["Selected facility:"]*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*SelectedFacility=dropdownDialog[FacilitiesList,"Select the facility:"]*)
(*Print["Selected LLP:"]*)
(*LLPlistFacility=Select[LLPlistEffective,Length[ProcessesListFacility[#,SelectedFacility]]!=0&];*)
(*SelectedLLP=dropdownDialog[LLPlistFacility,"Select the LLP:"]*)
(*Print["Implemented production channels:"]*)
(*listproductionall=ProcessesListFacility[SelectedLLP,SelectedFacility];*)
(*listproductionall//TableForm*)
(*selectionDialog[list_]:=DialogInput[{choice={}},Column[{Row[{"Select the production channels by clicking on them:"}],TogglerBar[Dynamic[choice],list,Appearance->"Vertical"],Button["OK",DialogReturn[choice]]}]]*)
(*listproductionForComputation=selectionDialog[Join[{"All channels"},listproductionall]];*)
(*If[listproductionForComputation=={"All channels"},listproductionForComputation=listproductionall];*)
(*Print["Production channels selected for the computation:"]*)
(*listproductionForComputation//TableForm*)
(*(*BlockProductionComputation[listproduction_]:=Module[{facility},*)
(*nb=EvaluationNotebook[];*)
(*Do[NotebookFind[nb,listproduction[[index]],All,CellTags];*)
(*SelectionEvaluate[nb],{index,1,Length[listproduction],1}]*)
(*]*)*)


(* ::Chapter::Closed:: *)
(*Launching the computation of the distributions of LLPs*)


(* ::Input:: *)
(**)
(**)
(*CondSelLLP[prod_]:=If[SelectedLLP!="HNL",StringContainsQ[ProductionType[SelectedLLP,prod],{"Decay","Mixing-Old"}],StringContainsQ[ProductionType[ListHNLs[[1]],prod],{"Decay","Mixing-Old"}]]*)
(*If[Select[Table[CondSelLLP[prod],{prod,listproductionForComputation}],#==True&]!={},*)
(*Print["Number of simulated decays:"];*)
(*nsim=DialogInput[{br=10^6},Column[{"Enter the number of simulated decays (for decays only) in the form y*10^x. Reasonable values are ~\!\(\*SuperscriptBox[\(10\), \(6\)]\)-\!\(\*SuperscriptBox[\(10\), \(7\)]\)",InputField[Dynamic[br],Expression],Button["Proceed",DialogReturn[br],ImageSize->Automatic]}]]//IntegerPart;*)
(*nsim=Ceiling[nsim-0.5]+Mod[Ceiling[nsim-0.5],2]*)
(*]*)
(*(*Empirical estimate of the angles below which the distribution d^2f/d\[Theta]dE ~ sin(\[Theta])df/dE*)*)
(*modes=Table[ProcessesListFacility[LLP,Facility],{LLP,LLPlistEffective},{Facility,FacilitiesList}]//Flatten//DeleteDuplicates;*)
(*Do[*)
(*\[Theta]minExtrFacility["ESS",mode]=0.1;*)
(*\[Theta]minExtrFacility["Serpukhov",mode]=10^-1.3;*)
(*\[Theta]minExtrFacility["SPS",mode]=If[StringContainsQ[mode,"Pi0"]||StringContainsQ[mode,"Primakov"]||StringContainsQ[mode,"Eta"]||StringContainsQ[mode,"Rho0"]||StringContainsQ[mode,"Omega"],0.5*10^-3.,10^-3.];*)
(*\[Theta]minExtrFacility["FermilabBD",mode]=\[Theta]minExtrFacility["Serpukhov",mode]=10^-3.;*)
(*\[Theta]minExtrFacility["LHC",mode]=If[StringContainsQ[mode,"Pi0"]||StringContainsQ[mode,"Primakov"]||StringContainsQ[mode,"Eta"]||StringContainsQ[mode,"Rho0"]||StringContainsQ[mode,"Omega"]||StringContainsQ[mode,"EtaPr"],10^-4,0.5*10^-3.];*)
(*\[Theta]minExtrFacility["FCC-hh",mode]=If[StringContainsQ[mode,"Pi0"]||StringContainsQ[mode,"Primakov"]||StringContainsQ[mode,"Eta"]||StringContainsQ[mode,"Rho0"]||StringContainsQ[mode,"Omega"]||StringContainsQ[mode,"EtaPr"],0.7*10^-4,2*10^-4.];*)
(*,{mode,modes}]*)
(*(*Launch if you are interested in all production channels implemented in this notebook for the given LLP *)*)
(*BlockProductionComputation[SelectedLLP,listproductionForComputation]*)
(**)


(* ::Input:: *)
(**)


(* ::Title::Closed:: *)
(*Actual computation of the distributions*)


(* ::Chapter::Closed:: *)
(*HNL*)


(* ::Section::Closed:: *)
(*HNL_W*)


(* ::Input:: *)
(*If[MemberQ[{"LHC","FCC-hh"},SelectedFacility]==True,*)
(*proc="W";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList["HNL",proc,Facility]={0.02,0.05,1,2,5,7,10,15,20,25,30,35,40,50,60,65,70,75,mSM["W"]-mSM["e"]-0.1}//N;*)
(*,{Facility,{"LHC","FCC-hh"}}];*)
(*Do[*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(*mlist=MassList["HNL",proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{LLP,ListHNLs}*)
(*]*)
(*]//AbsoluteTiming*)
(*{proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*HNL_B*)


(* ::Input:: *)
(*Module[{LLPn,LLP,mlist,proc},*)
(*LLPn="HNL";*)
(*proc="B";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPn,proc,Facility]=If[MemberQ[{"LHC","FCC-hh"},Facility]==True,{0.02,0.05,0.1,0.15,0.2,0.5,1,1.5,2.,2.5,2.8,3.,3.45,4.,4.5,5.16,5.27,5.8,6.25},{0.05,0.2,0.5,1,1.5,2.,2.5,2.8,3.,3.45,4.,4.5,5.16,5.27}]//N;*)
(*,{Facility,FacilitiesList}];*)
(*Monitor[*)
(*Do[*)
(*LLP=ListHNLs[[k]];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(*mlist=MassList[LLPn,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{k,1,Length[ListHNLs],1}],*)
(*Row[{ProgressIndicator[k,{1,Length[ListHNLs]}]," ","HNL = ",ListHNLs[[k]]," (",k,"/",Length[ListHNLs],")"}]]//AbsoluteTiming*)
(*]*)


(* ::Section::Closed:: *)
(*HNL_D*)


(* ::Input:: *)
(*Module[{LLPn,LLP,mlist,proc},*)
(*LLPn="HNL";*)
(*proc="D";*)
(*Do[*)
(*MassList[LLPn,proc,Facility]={0.02,0.05`,0.1,0.15,0.17,0.1825,0.2`,0.5`,0.7`,1.,1.2`,1.5`,1.75`,1.84,1.95`};*)
(*,{Facility,FacilitiesList}];*)
(*Monitor[*)
(*Do[*)
(*LLP=ListHNLs[[k]];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(*mlist=MassList[LLPn,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{k,1,Length[ListHNLs],1}],*)
(*Row[{ProgressIndicator[k,{1,Length[ListHNLs]}]," ","HNL = ",ListHNLs[[k]]," (",k,"/",Length[ListHNLs],")"}]]//AbsoluteTiming*)
(*]*)


(* ::Section::Closed:: *)
(*HNL_K*)


(* ::Input:: *)
(*If[MemberQ[{"SPS"},SelectedFacility],*)
(*proc="K";*)
(*Do[*)
(*MassList["HNL",proc,Facility]={0.05`,0.1,0.2,0.4,0.99*MaxMass[ListHNLs[[2]],SelectedFacility,proc],0.99*MaxMass[ListHNLs[[1]],SelectedFacility,proc]};*)
(*,{Facility,FacilitiesList}];*)
(*Do[*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(*mlist=MassList["HNL",proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{LLP,Drop[ListHNLs,-1]}*)
(*]*)
(*]//AbsoluteTiming*)
(*{proc,mlist}//Clear;*)


(* ::Section::Closed:: *)
(*HNL_mu*)


(* ::Input:: *)
(*If[MemberQ[{"ESS"},SelectedFacility],*)
(*proc="mu";*)
(*Do[*)
(*MassList["HNL",proc,Facility]={0.005,0.01,0.015,0.02,0.025,0.03,0.035,0.04,0.045,0.05,0.055,0.06,0.065,0.07,0.075,0.08,0.085,0.09,0.095,0.1,0.99*MaxMass[ListHNLs[[1]],SelectedFacility,proc]}//Sort//DeleteDuplicates;*)
(*,{Facility,FacilitiesList}];*)
(*Do[*)
(*mlist=MassList["HNL",proc,SelectedFacility];*)
(*mlistExt=Join[mlist,Table[With[{mass=mlist[[i]],mmax=(mSM["mu"]^2-mSM["e"]^2+mlist[[i]]^2)/(2mSM["mu"])},Table[m,{m,mass+0.01(mmax-mass),mass+0.99(mmax-mass),(0.9(mmax-mass))/20}]],{i,1,Length[mlist],1}]//Flatten]//Sort//DeleteDuplicates;*)
(*elist=Join[Table[e,{e,10^-3.,mSM["mu"],0.001}],mlistExt,{mSM["mu"]}]//DeleteDuplicates//Sort;*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],elist,\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(**)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{LLP,Drop[ListHNLs,-1]}*)
(*]//AbsoluteTiming*)
(*]*)
(*{proc,mlist}//Clear;*)


(* ::Section::Closed:: *)
(*HNL_PiCharged*)


(* ::Input:: *)
(*If[MemberQ[{"ESS"},SelectedFacility],*)
(*proc="PiCharged";*)
(*Do[*)
(*MassList["HNL",proc,Facility]={0.001,0.005,0.01,0.015,0.02,0.027,0.032,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.115,0.12,0.125,0.13,0.135};*)
(*,{Facility,{"ESS"}}];*)
(*Do[*)
(*elist=Join[(mSM["PiCharged"]^2-mSM["e"]^2+MassList["HNL",proc,"ESS"]^2)/(2mSM["PiCharged"]),(mSM["PiCharged"]^2-mSM["mu"]^2+MassList["HNL",proc,"ESS"]^2)/(2mSM["PiCharged"])]//DeleteDuplicates//Sort;*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLP,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],elist,\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLP,proc,SelectedFacility];*)
(*mlist=MassList["HNL",proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]*)
(*,{LLP,Drop[ListHNLs,-1]}*)
(*]*)
(*]//AbsoluteTiming*)
(*{proc,mlist}//Clear;*)


(* ::Chapter::Closed:: *)
(*Scalar*)


(* ::Section::Closed:: *)
(*Scalar_B-mixing*)


(* ::Input:: *)
(*proc="B-mixing";*)
(*LLPv="Scalar";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,0.2,0.5,1,1.3,1.5,1.7,2.,2.3,2.5,2.7,3.,3.3,3.6,4.,4.4,4.8,5.13};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*Scalar_B-quartic*)


(* ::Input:: *)
(*LLPv="Scalar";*)
(*proc="B-quartic";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.2,0.5,1,1.5,2.,2.2,2.39},#<MaxMass[LLPv,SelectedFacility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist,filename}//Clear*)


(* ::Section::Closed:: *)
(*Scalar_Bs-quartic*)


(* ::Input:: *)
(*proc="Bs-quartic";*)
(*LLPv="Scalar";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,0.2,0.5,1,1.5,2.,2.5,2.65};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*Scalar_h-quartic*)


(* ::Input:: *)
(*If[MemberQ[{"LHC","FCC-hh"},SelectedFacility],*)
(*proc="h-quartic";*)
(*LLPv="Scalar";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.1,1.,5.,10.,15.,20.,25.,30.,35.,40.,45.,50.,55.,59.,60.,61.,62.,62.49};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)
(*]*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*Scalar_K-mixing*)


(* ::Input:: *)
(*proc="K-mixing";*)
(*LLPv="Scalar";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.2,0.3,0.99MaxMass["Scalar",SelectedFacility,proc]},#<MaxMass["Scalar",SelectedFacility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*Scalar_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="Scalar";*)
(*proc="Bremsstrahlung";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"AP"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Chapter::Closed:: *)
(*MCP*)


(* ::Section::Closed:: *)
(*MCP_Pi0*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,mSM["Pi0"]/2*0.99};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_Eta*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,0.1,0.2,mSM["Eta"]/2*0.99};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_Phi*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Phi";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_JPsi*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="JPsi";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,1.,1.3,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_Rho0*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Rho0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_Omega*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Omega";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*MCP_Upsilon*)


(* ::Input:: *)
(*LLPv="MCP";*)
(*proc="Upsilon";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Chapter::Closed:: *)
(*DP*)


(* ::Section::Closed:: *)
(*DP_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="DP";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"FR","Baseline"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Section::Closed:: *)
(*DP_Pi0*)


(* ::Input:: *)
(*LLPv="DP";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*DP_Eta*)


(* ::Input:: *)
(*LLPv="DP";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Input:: *)
(* *)


(* ::Section::Closed:: *)
(*DP_EtaPr*)


(* ::Input:: *)
(*LLPv="DP";*)
(*proc="EtaPr";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,0.9,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*DP_Mixing-Old*)


(* ::Input:: *)
(*LLPv="DP";*)
(*proc="Mixing-Old";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.77,1.,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*B-L*)


(* ::Section::Closed:: *)
(*B-L_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="B-L";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"AP","Baseline"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Section::Closed:: *)
(*B-L_Pi0*)


(* ::Input:: *)
(*LLPv="B-L";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-L_Eta*)


(* ::Input:: *)
(*LLPv="B-L";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-L_EtaPr*)


(* ::Input:: *)
(*LLPv="B-L";*)
(*proc="EtaPr";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,0.9,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-L_Mixing-Old*)


(* ::Input:: *)
(*LLPv="B-L";*)
(*proc="Mixing-Old";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.77,1.,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*B-3Lmu*)


(* ::Section::Closed:: *)
(*B-3Lmu_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="B-3Lmu";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"AP","Baseline"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Section::Closed:: *)
(*B-3Lmu_Pi0*)


(* ::Input:: *)
(*LLPv="B-3Lmu";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Lmu_Eta*)


(* ::Input:: *)
(*LLPv="B-3Lmu";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Lmu_EtaPr*)


(* ::Input:: *)
(*LLPv="B-3Lmu";*)
(*proc="EtaPr";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,0.9,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Lmu_Omega*)


(* ::Input:: *)
(*LLPv="B-3Lmu";*)
(*proc="Mixing-Old";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.77,1.,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*B-Le-3Lmu+Ltau*)


(* ::Section::Closed:: *)
(*B-Le-3Lmu+Ltau_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="B-Le-3Lmu+Ltau";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"AP","Baseline"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Section::Closed:: *)
(*B-Le-3Lmu+Ltau_Pi0*)


(* ::Input:: *)
(*LLPv="B-Le-3Lmu+Ltau";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-Le-3Lmu+Ltau_Eta*)


(* ::Input:: *)
(*LLPv="B-Le-3Lmu+Ltau";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-Le-3Lmu+Ltau_EtaPr*)


(* ::Input:: *)
(*LLPv="B-Le-3Lmu+Ltau";*)
(*proc="EtaPr";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,0.9,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-Le-3Lmu+Ltau_Omega*)


(* ::Input:: *)
(*LLPv="B-Le-3Lmu+Ltau";*)
(*proc="Mixing-Old";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.77,1.,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*B-3Le-Lmu+Ltau*)


(* ::Section::Closed:: *)
(*B-3Le-Lmu+Ltau_Bremsstrahlung*)


(* ::Input:: *)
(*LLPv="B-3Le-Lmu+Ltau";*)
(*Do[BlockTabulatedPDFsFromBrem[LLPv,SelectedFacility,descr],{descr,{"AP","Baseline"}}];//AbsoluteTiming*)
(*(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromBrem[LLPv,mLLP,\[Theta]listBrem,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename];//AbsoluteTiming*)*)
(*{LLPv,proc,mlist,\[CapitalLambda]plist,descr}//Clear*)


(* ::Section::Closed:: *)
(*B-3Le-Lmu+Ltau_Pi0*)


(* ::Input:: *)
(*LLPv="B-3Le-Lmu+Ltau";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Le-Lmu+Ltau_Eta*)


(* ::Input:: *)
(*LLPv="B-3Le-Lmu+Ltau";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.45,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Le-Lmu+Ltau_EtaPr*)


(* ::Input:: *)
(*LLPv="B-3Le-Lmu+Ltau";*)
(*proc="EtaPr";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.2,0.3,0.5,0.7,0.9,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*B-3Le-Lmu+Ltau_Omega*)


(* ::Input:: *)
(*LLPv="B-3Le-Lmu+Ltau";*)
(*proc="Mixing-Old";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.77,1.,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]NlistLight[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)
(**)


(* ::Chapter::Closed:: *)
(*ALP-photon*)


(* ::Section::Closed:: *)
(*ALP-photon_Pi0*)


(* ::Input:: *)
(*LLPv="ALP-photon";*)
(*proc="Pi0";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.115,0.132},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-photon_Eta*)


(* ::Input:: *)
(*LLPv="ALP-photon";*)
(*proc="Eta";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.25,0.4,0.5,MaxMass[LLPv,Facility,proc]*0.99},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-photon_Primakov*)


(* ::Input:: *)
(*LLPv="ALP-photon";*)
(*proc="Primakov";*)
(*Do[MassList[LLPv,proc,Facility]={0.02,0.05,0.1,0.25,0.5,0.75,1.,1.3,1.5,1.75,2.,2.25,2.5,2.75,3.,3.25,3.5,3.75,4.};*)
(*,{Facility,FacilitiesList}]*)
(*Zlist=NucleiList[SelectedFacility,proc];*)
(*Monitor[Do[BlockTabulatedPDFsFromPrimakov[SelectedFacility,Zlist[[l]],\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility]],{l,1,Length[Zlist],1}],Row[{ProgressIndicator[l,{1,Length[Zlist]}]," Nucleus = ",Zlist[[l]]," (",l,"/",Length[Zlist],")"}]]//AbsoluteTiming*)
(*{LLPv,proc,Zlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-photon_Photon-fusion*)


(* ::Input:: *)
(*(*Currently, it is very slow for LHC and FCC-hh. I cannot efficiently handle the singularity at the integration boundaries*)*)
(*LLPv="ALP-photon";*)
(*proc="Photon-fusion";*)
(*Do[MassList[LLPv,proc,Facility]={0.02,0.05,0.1,0.25,0.5,0.75,1.,1.3,1.5,1.75,2.};*)
(*,{Facility,FacilitiesList}]*)
(*Zlist=NucleiList[SelectedFacility,proc];*)
(*Monitor[Do[BlockTabulatedPDFsFromFusion[SelectedFacility,Zlist[[l]],\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility]],{l,1,Length[Zlist],1}],Row[{ProgressIndicator[l,{1,Length[Zlist]}]," Nucleus = ",Zlist[[l]]," (",l,"/",Length[Zlist],")"}]]//AbsoluteTiming*)
(*{LLPv,proc}//Clear*)


(* ::Chapter::Closed:: *)
(*ALP-gluon*)


(* ::Section::Closed:: *)
(*ALP-gluon_B*)


(* ::Input:: *)
(*LLPv="ALP-gluon";*)
(*proc="B";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,0.2,0.5,1,1.5,2.,2.5,3.,3.5,4.,4.8,5.13};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-gluon_Pi0*)


(* ::Input:: *)
(*LLPv="ALP-gluon";*)
(*proc="Pi0";*)
(*Do[*)
(*If[Facility!="ESS",*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.135,0.2,0.3,0.4,0.5,0.65,0.7,0.8,0.9,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.4,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,*)
(*MassList[LLPv,proc,Facility]={0.02,0.03,0.04,0.05,0.06,0.065,0.07,0.075,0.08,0.085,0.09,0.095,0.1,0.105,0.11,0.115,0.12,0.125,0.13,0.135};*)
(*]*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-gluon_Eta*)


(* ::Input:: *)
(*LLPv="ALP-gluon";*)
(*proc="Eta";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.135,0.2,0.3,0.4,0.547,0.65,0.7,0.8,0.9,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.4,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-gluon_EtaPr*)


(* ::Input:: *)
(*LLPv="ALP-gluon";*)
(*proc="EtaPr";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.7,0.95,1.5,2.,2.5,3.,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Chapter::Closed:: *)
(*ALP-fermion*)


(* ::Section::Closed:: *)
(*ALP-fermion_B*)


(* ::Input:: *)
(*LLPv="ALP-fermion";*)
(*proc="B";*)
(*(*List of masses for which the distribution will be tabulated*)*)
(*Do[*)
(*MassList[LLPv,proc,Facility]={0.02,0.05,0.1,0.2,0.3,0.5,0.7,1.2,1.5,2.,2.5,3.,3.5,4.,4.8,5.13};*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromDecaysMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc],"False"];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-fermion_Pi0*)


(* ::Input:: *)
(*LLPv="ALP-fermion";*)
(*proc="Pi0";*)
(*Do[*)
(*Do[*)
(*If[Facility!="ESS",*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.135,0.2,0.3,0.4,0.5,0.65,0.7,0.8,0.9,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.4,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,*)
(*MassList[LLPv,proc,Facility]={0.02,0.03,0.04,0.05,0.06,0.065,0.07,0.075,0.08,0.085,0.09,0.095,0.1,0.105,0.11,0.115,0.12,0.125,0.13,0.135};*)
(*]*)
(*,{Facility,FacilitiesList}];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-fermion_Eta*)


(* ::Input:: *)
(*LLPv="ALP-fermion";*)
(*proc="Eta";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.135,0.2,0.3,0.4,0.547,0.65,0.7,0.8,0.9,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.,3.1,3.2,3.3,3.4,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Section::Closed:: *)
(*ALP-fermion_EtaPr*)


(* ::Input:: *)
(*LLPv="ALP-fermion";*)
(*proc="EtaPr";*)
(*Do[*)
(*MassList[LLPv,proc,Facility]=Select[{0.02,0.05,0.1,0.3,0.5,0.7,0.95,1.5,2.,2.5,3.,3.5},0<#<MaxMass[LLPv,Facility,proc]&];*)
(*,{Facility,FacilitiesList}];*)
(*TabulatedPDF[mLLP_]:=BlockTabulatedPDFsFromMixingsMass[LLPv,SelectedFacility,mLLP,proc,nsim,\[Theta]Nlist[SelectedFacility],ENlist[SelectedFacility],\[Theta]minExtrFacility[SelectedFacility,proc]];*)
(*mlist=MassList[LLPv,proc,SelectedFacility];*)
(*filename=filenameToExport[LLPv,proc,SelectedFacility];*)
(*tabulatedblock[TabulatedPDF,mlist,filename]//AbsoluteTiming*)
(*{LLPv,proc,mlist}//Clear*)


(* ::Title::Closed:: *)
(*Deleting generated cells*)


(* ::Input:: *)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*(*deletecellsopt=dropdownDialog[{"Yes","No"},Row[{"Would you like to remove all the generated output cells?"}]]*)
(*If[deletecellsopt=="Yes",FrontEndTokenExecute["DeleteGeneratedCells"]]*)*)
(*FrontEndTokenExecute["DeleteGeneratedCells"]*)
(*FrontEndTokenExecute["SelectAll"]*)
(*FrontEndTokenExecute["SelectionCloseAllGroups"]*)
