#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title::Closed:: *)
(*Just launch the code below to run the notebook (shift+enter)*)


(* ::Input:: *)
(*ClearAll["Global`*"]*)
(*ParallelEvaluate[ClearAll["Global`*"]];*)
(*(*EnsureFreshKernels[]:=Module[{},*)
(*(*Check if the marker variable is defined in any kernel*)If[MemberQ[ParallelEvaluate[$KernelInitializationDone],True],*)
(*(*If yes,close and relaunch kernels*)*)
(*CloseKernels[];*)
(*LaunchKernels[];*)
(*];*)
(*(*Set or reset the marker variable in all kernels*)*)
(*ParallelEvaluate[$KernelInitializationDone=True];]*)
(*EnsureFreshKernels[];*)*)
(*CloseKernels[];*)
(*LaunchKernels[];*)
(*BlockEvaluation[tag_]:=Block[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,tag,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*]*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*If[(DirectoryQ[FileNameJoin[{NotebookDirectory[],"Auxiliary data"}]]//ToString)=="False",CreateDirectory[FileNameJoin[{NotebookDirectory[],"Auxiliary data"}]]];*)
(*choiceslist={"Tabulated Nevents+sensitivity","Sensitivity only (tabulated Nevents must be produced before)","Acceptance"};*)
(*taglist["Acceptance"]="Acceptance";*)
(*taglist["Tabulated Nevents+sensitivity"]="Number-of-events+sensitivity";*)
(*taglist["Sensitivity only (tabulated Nevents must be produced before)"]="Sensitivity";*)
(*computationchoice=dropdownDialog[choiceslist,"Do you want to compute the tabulated number of events and then sensitivity, or just sensitivity (if the tabulated number of events has been already produced)?"];*)
(*tagselected=taglist[computationchoice]*)
(*BlockEvaluation[tagselected]*)


(* ::Title::Closed:: *)
(*Preliminary definitions*)


(* ::Chapter::Closed:: *)
(*Various directories*)


(* ::Input:: *)
(*LLPdirName="Scalar";*)
(*(*Set the directory for the search where tabulated acceptances are located*)*)
(*directory["Acceptances"]=FileNameJoin[{NotebookDirectory[],"Acceptances"}];*)
(*(*Set the directory for the search where tabulated angle-energy distributions are located*)*)
(*directory["Distribution"]=FileNameJoin[{NotebookDirectory[],"spectra/New physics particles spectra",LLPdirName}]; *)
(*(*The directory storing production weights of the given LLP*)*)
(*directory["Production weights"]=FileNameJoin[{NotebookDirectory[],"phenomenology",LLPdirName,"Production probabilities"}]; *)
(*(*Directory to which various auxillary datasets will be stored*)*)
(*directory["Auxiliary"]=FileNameJoin[{NotebookDirectory[],"Auxiliary data",LLPdirName}]; *)
(*If[!DirectoryQ[directory["Auxiliary"]],CreateDirectory[directory["Auxiliary"]]];*)
(*(*Directory containing decay widths of the LLPs*)*)
(*directory["Decays"]=FileNameJoin[{NotebookDirectory[],"phenomenology",LLPdirName,"decay widths"}]; *)


(* ::Chapter::Closed:: *)
(*Parameters and various functions*)


(* ::Input:: *)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*selectionDialog[list_,phrase_]:=DialogInput[{choice={}},Column[{Row[{phrase}],Pane[TogglerBar[Dynamic[choice],list,Appearance->"Vertical"->{Automatic,5}],ImageSize->{Automatic,Automatic},Scrollbars->{False,True}],Button["OK",DialogReturn[choice]]}]]*)
(*(*chbar*)*)
(*chbar= 6.6*10^-25*3*10^8;*)
(*(*Masses of various SM particles*)*)
(*{mSM["Bplus"],mSM["Kplus"],mSM["PiPlus"],mSM["h"],mSM["Bs"]}={5.279,0.495,0.139,62.5,5.366};*)
(*(*Fragmentation fractions at the LHC. For the moment, the same fractions are assumed to be at the FCC-hh*)*)
(*fbtob0["LHC"]=fbtobplus["LHC"]=fbtob0["FCC-hh"]=fbtobplus["FCC-hh"]=0.324;*)
(*fbtobs["LHC"]=fbtobs["FCC-hh"]=0.09;*)
(*(*Fragmentation fractions at SPS. From SHiP physics paper*)*)
(*fbtobs["SPS"]=0.11;*)
(*fbtob0["SPS"]=fbtobplus["SPS"]=0.411;*)
(*fstokplus["SPS"]=0.5;*)
(*fstok0l["SPS"]=0.25;*)
(*(*Fraction of K^+/- decaying in-flight at SPS, from https://arxiv.org/pdf/2004.07974.pdf*)*)
(*fractionDecayInFlightKplusKminus=(0.29+0.07);*)
(*(*Fragmentation fractions at FermilabBD. Assumed to be the same as at SPS*)*)
(*fbtobs["FermilabBD"]=0.11;*)
(*fbtob0["FermilabBD"]=fbtobplus["FermilabBD"]=0.411;*)
(*(*Fragmentation fractions at Serpukhov. Assumed to be zero*)*)
(*fbtobs["Serpukhov"]=0.;*)
(*fbtob0["Serpukhov"]=fbtobplus["Serpukhov"]=0.;*)


(* ::Chapter::Closed:: *)
(*LLP phenomenology: prodution probabilities, decay widths*)


(* ::Section::Closed:: *)
(*Production weights*)


(* ::Subsection::Closed:: *)
(*Non-bremsstrahlung*)


(* ::Input:: *)
(*PmotherToLLP//Clear;*)
(*FacilitiesList={"SPS","FermilabBD","LHC","FCC-hh","Serpukhov"};*)
(*intProd[filename_,m1_,m2_]:=If[mLLP<m1-m2,Evaluate[Interpolation[Import[FileNameJoin[{directory["Production weights"],filename}],"Table"],InterpolationOrder->1][mLLP]],0.];*)
(*BrhtoSS[mLLP_,\[Alpha]_]=2*10^-2*\[Alpha]^2 Sqrt[1-4*mLLP^2/125^2];*)
(*(*Value of \[Alpha] corresponding to the given Br(h\[Rule]SS)=0.01*)*)
(*\[Alpha]valBrhToSS[mS_,BrhToSS_]=\[Alpha]/.Solve[BrhtoSS[mS,\[Alpha]]==BrhToSS,\[Alpha]][[2]];*)
(*Print["Exclusive/inclusive production of dark scalar in decays B->\!\(\*SubscriptBox[\(X\), \(s\)]\)+S:"]*)
(*SelectedBrChoice=dropdownDialog[{"Exclusive","Inclusive"},"Select the description of the scalar's production by decays of B via mixing (see 1904.10447):"]*)
(*Do[*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,"B-mixing",Facility]=\[Theta]2*(fbtob0[Facility]+fbtobplus[Facility])intProd[If[SelectedBrChoice=="Exclusive","BtoXsStotal.dat","BtoXsSinclusive.dat"],mSM["Bplus"],mSM["PiPlus"]];*)
(*(*Factors of 2 and 1/2 are due to the production of scalars in pairs. \[Alpha] is the quartic coupling defined by Subscript[L, int] = \[Alpha]/(2v)S^2H^+H*)*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,"B-quartic",Facility]=2*\[Alpha]valBrhToSS[mLLP,BrhToSS]^2*(fbtob0[Facility]+fbtobplus[Facility])*intProd["BplustoXsSStotal.dat",mSM["Bplus"]/2,mSM["PiPlus"]/2];*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,"Bs-quartic",Facility]=2*\[Alpha]valBrhToSS[mLLP,BrhToSS]^2*fbtobs[Facility]*intProd["BstoSS.dat",mSM["Bs"]/2,0.];*)
(*If[MemberQ[{"LHC","FCC-hh"},Facility],*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,"h-quartic",Facility]=2*10^-2*\[Alpha]valBrhToSS[mLLP,BrhToSS]^2 Sqrt[1-4*mLLP^2/125^2];*)
(*];*)
(*,{Facility,FacilitiesList}];*)
(*(*Production from K at beam dump experiments with thick target. Assumed to be the same independently of target's material. Also, the fraction of Subscript[(K^0), L] decaying at rest is assumed to be the same as the fraction of charged kaons*)*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,"K-mixing","SPS"]=\[Theta]2*(fstokplus["SPS"]*intProd["KplustoPiS.dat",mSM["Kplus"],mSM["PiPlus"]]+fstok0l["SPS"]*intProd["K0LtoPiS.dat",mSM["Kplus"],mSM["PiPlus"]]);*)


(* ::Subsection::Closed:: *)
(*Bremsstrahlung*)


(* ::Input:: *)
(*(*________________*)*)
(*(*Bremsstrahlung*)*)
(*(*________________*)*)
(*BremProd[Facility_]:=Module[{},*)
(*bremprobfiles=FileNames["Pbrem*_"<>Facility<>".m",directory["Production weights"]];*)
(*If[bremprobfiles!={},*)
(*(*Scanning over all available files with the bremsstrahlung probability. They describe different descriptions of the bremsstrahlung*)*)
(*(*Extract the bremsstrahlung description from the filename*)*)
(*bremprobfilenames=Last@FileNameSplit[#]&/@bremprobfiles;*)
(*bremdescription=("Bremsstrahlung-"<>(StringSplit[#,{"Pbrem_"<>LLPdirName<>"_","_"}][[1]])&/@bremprobfilenames);*)
(*Do[*)
(*datbrem[mLLP_,\[Theta]LLP_]=Import[bremprobfiles[[i]],"MX"];*)
(*If[StringContainsQ[bremdescription[[i]],"BB"],*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,bremdescription[[i]],Facility]=datbrem[mLLP,\[Theta]LLP][[1]]*\[Theta]2;*)
(*ELLPmin[bremdescription[[i]],Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[2]]];*)
(*\[Theta]maxBrem[bremdescription[[i]],Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[3]]];*)
(*ELLPmax[mLLP_,\[Theta]LLP_,bremdescription[[i]],Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[4]]];*)
(*,*)
(*Do[*)
(*Module[{bremname},*)
(*bremname=bremdescription[[i]]<>"-"<>datbrem[mLLP,\[Theta]LLP][[j]][[1]]<>"-mixing";*)
(*PmotherToLLP[mLLP_,\[Theta]2_,BrhToSS_,bremname,Facility]=datbrem[mLLP,\[Theta]LLP][[j]][[2]]*\[Theta]2;*)
(*ELLPmin[bremname,Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[j]][[3]]];*)
(*\[Theta]maxBrem[bremname,Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[j]][[4]]];*)
(*ELLPmax[mLLP_,\[Theta]LLP_,bremname,Facility]=Evaluate[datbrem[mLLP,\[Theta]LLP][[j]][[5]]];*)
(*]*)
(*,{j,1,Length[datbrem[mLLP,\[Theta]LLP]],1}]*)
(*]*)
(*,{i,1,Length[bremdescription],1}]*)
(*]*)
(*]*)
(*Do[*)
(*BremProd[Facility],{Facility,{"FCC-hh","Serpukhov","SPS","FermilabBD","LHC"}}];*)
(*(*Scaling of the lower bound: Subscript[(\[Theta]^2), lower bound] ~ ((\!\( *)
(*\*SubscriptBox[\(N\), \(ev\)]*)
(*\*SubscriptBox[\(|\), \(\[Theta]\  = \ 1\)]\))^(-\[Beta]/2))*)*)
(*WeightsCombinations=Keys[DownValues@PmotherToLLP][[All,1,#]]&/@{4,5}//Transpose//Sort;*)
(*LowerBoundScaling["B-mixing"]=LowerBoundScaling["K-mixing"]=1;*)
(*Do[*)
(*prodLowerBoundScaling[prod]=If[StringContainsQ[prod,"mixing"],1,If[StringContainsQ[prod,"quartic"],2]];*)
(*,{prod,WeightsCombinations[[All,1]]//DeleteDuplicates}]*)


(* ::Section::Closed:: *)
(*Scanning for tabulated distributions*)


(* ::Input:: *)
(*(*Define the file pattern*)*)
(*pattern="DoubleDistr_*_*_*.m";*)
(*(*Search for files matching the pattern in the directory and its subdirectories*)*)
(*matchingFiles=FileNames[pattern,{directory["Distribution"]},Infinity];*)
(*(*List of LLPs, production modes, and facilities for which the tabulated distributions have been computed at the previous stage of using SensCalc*)*)
(*ExtractedProductionParameters=Function[filename,parts=StringSplit[FileNameTake[filename],"_"];*)
(*{parts[[2]],parts[[3]],StringDrop[parts[[4]],-2]} ];*)
(*(*combinations selected LLP, production channel, facility for which the tabulated distributions are present*)*)
(*Print["List of available distributions:"]*)
(*DistrCombinations=(ExtractedProductionParameters/@matchingFiles)//Sort*)
(**)
(*If[MemberQ[DistrCombinations[[All,2]],"Bremsstrahlung-FR-mixing"]||MemberQ[DistrCombinations[[All,2]],"Bremsstrahlung-AP-mixing"],*)
(*FacilitiesFR=Select[DistrCombinations,StringContainsQ[#[[2]],{"FR"}]&][[All,3]];*)
(*FacilitiesAP=Select[DistrCombinations,StringContainsQ[#[[2]],{"AP"}]&][[All,3]];*)
(*DistrCombinationsToCheck=Select[DistrCombinations,!StringContainsQ[#[[2]],{"FR","AP"}]&];*)
(*DistrCombinationsToCheck=Join[DistrCombinationsToCheck,Flatten[Table[{LLPdirName,brem,fac},{fac,FacilitiesFR},{brem,Select[WeightsCombinations,#[[2]]==fac&&StringContainsQ[#[[1]],"FR"]&][[All,1]]}],1],Flatten[Table[{LLPdirName,brem,fac},{fac,FacilitiesAP},{brem,Select[WeightsCombinations,#[[2]]==fac&&StringContainsQ[#[[1]],"AP"]&][[All,1]]}],1]]//Sort;*)
(*,*)
(*DistrCombinationsToCheck=DistrCombinations*)
(*]*)
(*DistrCombinationsToCheck;*)
(*Print["If there are production weights to all available distributions:"]*)
(*IfCondDistrToWeights=True;*)
(*Do[*)
(*IfCondDistrToWeights=Select[WeightsCombinations,#[[1]]==DistrCombinationsToCheck[[i]][[2]]&&#[[2]]==DistrCombinationsToCheck[[i]][[3]]&]!={};*)
(*If[IfCondDistrToWeights==False,Break[]];*)
(*,{i,1,Length[DistrCombinationsToCheck],1}]*)
(*IfCondDistrToWeights*)
(*If[!IfCondDistrToWeights,infoDialog["You have not provided the production probabilities PmotherToLLP to all the generated tabulated distributions! Please do this first to avoid problems"];]*)


(* ::Section::Closed:: *)
(*LLP lifetime*)


(* ::Input:: *)
(*(*Decay length of the scalar - following Winkler*)*)
(*c\[Tau]LLP[mLLP_,\[Theta]2_]=1/\[Theta]2 Interpolation[Select[Import[FileNameJoin[{directory["Decays"],"ctaus.dat"}],"Table"],#[[1]]!=2.&],InterpolationOrder->1][mLLP];*)
(*ldecayLLP[mLLP_,\[Theta]2_,ELLP_]=c\[Tau]LLP[mLLP,\[Theta]2]*Sqrt[ELLP^2-mLLP^2]/mLLP;*)


(* ::Chapter::Closed:: *)
(*Loading necessary routines*)


(* ::Input:: *)
(*If[Length[inecessary]==0,*)
(*NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/generic.nb"}]];*)
(*NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/for-sensitivities.nb"}]];*)
(*inecessary={1,2,3};*)
(*]*)


(* ::Title::Closed:: *)
(*Specifying the experiment*)


(* ::Input:: *)
(*SetDirectory[NotebookDirectory[]];*)
(*(*Parent directory*)*)
(*NotebookDirectory[]//ParentDirectory;*)
(*ExperimentDirectoriesList=Select[FileNames["*",directory["Acceptances"],1],DirectoryQ];*)
(*(*List of available experiments (for which the geometry has been implemented)*)*)
(*ExperimentsListTemp=Table[FileNameTake[ExperimentDirectoriesList[[i]],-1],{i,1,Length[ExperimentDirectoriesList],1}];*)
(*ExperimentsListTemp2=Join[Partition[ExperimentsListTemp,1],Table[{TrueQ@FileExistsQ@FileNameJoin[{directory["Acceptances"],ExperimentsListTemp[[i]],ToString@StringForm["Acceptance_``_for_``.m",ExperimentsListTemp[[i]],LLPdirName]}]},{i,1,Length[ExperimentsListTemp]}],2];*)
(*Print["List of available experiments:"]*)
(*ExperimentsList=Select[ExperimentsListTemp2,#[[2]]==True&][[All,1]]//Sort*)
(*If[Length[ExperimentsList]==0,Print["No experiment is available, generate first the acceptance for the given experiment using module 1"]]*)
(*Print["Selected experiments:"]*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*SelectedExperimentList=If[Length[ExperimentsList]!=0,selectionDialog[ExperimentsList,"Select the experiments:"]]*)
(*icounter=1;*)


(* ::Chapter::Closed:: *)
(*Running block for next sections*)


(* ::Input:: *)
(*BlockEvaluation[tag_]:=Block[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,tag,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*]*)
(*If[tagselected=="Number-of-events+sensitivity",*)
(*Do[*)
(*BlockEvaluation["Number-of-events-computation+sensitivity"];*)
(*,{icounter,1,Length[SelectedExperimentList],1}],*)
(*If[tagselected=="Acceptance",*)
(*Do[*)
(*BlockEvaluation["Acceptance-computation"];*)
(*,{icounter,1,Length[SelectedExperimentList],1}]*)
(*]*)
(*]*)


(* ::Title::Closed:: *)
(*Number of events*)


(* ::Chapter::Closed:: *)
(*Particular experiment*)


(* ::Input:: *)
(*SelectedExperiment=SelectedExperimentList[[icounter++]];*)
(*Print[Row[{"Experiment ",icounter-1,"/",Length[SelectedExperimentList]}]]*)


(* ::Chapter::Closed:: *)
(*Cross-sections, acceptances*)


(* ::Section::Closed:: *)
(*Cross-sections, acceptances*)


(* ::Input:: *)
(*dataAcceptances=Import[FileNameJoin[{FileNameJoin[{directory["Acceptances"],SelectedExperiment,ToString@StringForm["Acceptance_``_for_``.m",Sequence@@{SelectedExperiment,LLPdirName}]}]}],"MX"];//AbsoluteTiming*)
(*{FacilityGivenExperiment,FullAcceptanceData0,BrVis[mLLP_]}=dataAcceptances[[#]]&/@{1,3,5};*)
(*LogLogPlot[Evaluate[BrVis[mLLP]],{mLLP,0.02,10},Frame->True,ImageSize->Large,FrameStyle->Directive[Black, 22],PlotStyle->{{Thickness[0.003],Blue},{Thickness[0.003],Darker@Red},{Thickness[0.003],Darker@Darker@Green},{Thickness[0.003],Black}},GridLines->Automatic,PlotRange->{{0.1,10},{0.01,1.2}},Frame->True,ImageSize->Large,FrameLabel->{"m [GeV]","\!\(\*SubscriptBox[\(Br\), \(vis\)]\)"},PlotLabel-> Style[Row[{"For ",SelectedExperiment}], 20, Black]]*)
(*(*___________________________*)*)
(*(*Interpolation of the tabulated azimuthal acceptance, extracting Subscript[\[Theta], min/max], etc.*)*)
(*(*___________________________*)*)
(*{AzimuthalAcceptanceInt[\[Theta]LLP_,zLLP_],\[Theta]minExpAll,\[Theta]maxExpAll,\[Theta]minExp,\[Theta]maxExp,zminExp,zmaxExp,zmin\[Theta][\[Theta]LLP_],zmax\[Theta][\[Theta]LLP_]}=Block\[Epsilon]Azimuthal[FullAcceptanceData0];*)
(*(*Logarithmized data with full acceptance, and also decay acceptance and full acceptance interpolations*)*)
(*{FullAcceptanceData,DecayAcceptanceInt[mLLP_,\[Theta]LLP_,ELLP_,zLLP_],FullAcceptanceInt[mLLP_,\[Theta]LLP_,ELLP_,zLLP_],InGridm\[Epsilon],InGrid\[Theta]\[Epsilon],InGridE\[Epsilon],InGridz\[Epsilon],\[Epsilon]vals,\[Epsilon]azvals,mmin\[Epsilon],mmax\[Epsilon]}=Block\[Epsilon]Decay[FullAcceptanceData0,zminExp,BrVis];*)
(*CrossSectionData=dataAcceptances[[4]]//Transpose;*)
(*NpotGivenExperiment=Select[CrossSectionData,#[[1]]=="Npot"&][[1]][[2]]//N;*)
(*(*infoDialog[Row[{"The number of proton collisions is ", NpotGivenExperiment,". You may change it at the stage of computing the sensitivities"}]]*)*)
(*(*Total number of b Overscript[b, _] and h*)*)
(*ProbMother["B-mixing"]=ProbMother["B-quartic"]=ProbMother["Bs-quartic"]=Select[CrossSectionData,#[[1]]=="Pb"&][[1]][[2]];*)
(*ProbMother["h-quartic"]=Select[CrossSectionData,#[[1]]=="Ph"&][[1]][[2]];*)
(*ProbMother["K-mixing"]=If[FacilityGivenExperiment=="SPS",fractionDecayInFlightKplusKminus,0.];*)
(*ProbMother["Bremsstrahlung-AP-mixing"]=ProbMother["Bremsstrahlung-FR-mixing"]=ProbMother["Bremsstrahlung-BB-mixing"]=1.;*)
(*{{"\!\(\*SubscriptBox[\(\[Chi]\), \(b\\\  or\\\  \*OverscriptBox[\(b\), \(_\)]\)]\)","\!\(\*SubscriptBox[\(\[Chi]\), \(h\)]\)"},{ProbMother["B-mixing"],ProbMother["h-quartic"]}}//TableForm*)
(*Row[{"Search for "<>LLPdirName<>" at ", SelectedExperiment, " located at ",FacilityGivenExperiment,". \!\(\*SubscriptBox[\(N\), \(collisions\)]\) = ",NpotGivenExperiment}]*)
(*{{"Quantity","\!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\), rad","\!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\), rad","\!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\)(\!\(\*SubscriptBox[\(\[Epsilon]\), \(dec\)]\)), rad","\!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\)(\!\(\*SubscriptBox[\(\[Epsilon]\), \(dec\)]\)), rad","\!\(\*SubscriptBox[\(z\), \(min\)]\), m","\!\(\*SubscriptBox[\(z\), \(max\)]\), m"},{"Description","Min angle covered by experiment","Max angle covered by experiment","Min angle where \!\(\*SubscriptBox[\(\[Epsilon]\), \(decay\)]\)\[NotEqual]0","Max angle where \!\(\*SubscriptBox[\(\[Epsilon]\), \(decay\)]\)\[NotEqual]0","Min long. displacement of the decay volume","Max long. displacement of the decay volume"},{"Value",\[Theta]minExpAll,\[Theta]maxExpAll,\[Theta]minExp,\[Theta]maxExp,zminExp,zmaxExp}}//TableForm*)


(* ::Input:: *)
(*Export[FileNameJoin[{NotebookDirectory[],"temp1/FACET/acc-Pre-FACET.mx"}],FullAcceptanceInt[mLLP,\[Theta]LLP,ELLP,zLLP],"MX"]*)


(* ::Chapter::Closed:: *)
(*LLP angle-energy distributions for the given experiment*)


(* ::Section::Closed:: *)
(*Importing and definitions*)


(* ::Subsection::Closed:: *)
(*Specifying production channels*)


(* ::Input:: *)
(*(*List of production channels for the selected facility*)*)
(*ProductionPatternSelectedDistr=Select[DistrCombinations,#[[3]]==FacilityGivenExperiment&];*)
(*ProductionPatternSelected=Select[DistrCombinationsToCheck,#[[3]]==FacilityGivenExperiment&];*)
(*ProductionListTemp=ProductionPatternSelected[[All,2]]//DeleteDuplicates;*)
(*(*Selecting only those bremsstrahlung channels for which the distribution is non-zero*)*)
(*BremVariantsGivenFacility=Select[WeightsCombinations[[All,{1,2}]],#[[2]]==FacilityGivenExperiment&&StringContainsQ[#[[1]],"Bremsstrahlung"]&][[All,1]];*)
(*Do[*)
(*ProbMother[channel]=1;*)
(*,{channel,Join[{"DrellYan"},BremVariantsGivenFacility,{"Mixing","Mixing-Old"}]}]*)
(*Print["Production list:"]*)
(*(*Deciding if the bremsstrahlung contributes to the production by comparing Subscript[\[Theta], max,brem] with Subscript[\[Theta], min,experiment]*)*)
(*Do[*)
(*ELLPmax[mLLP_,\[Theta]LLP_,ch]=ELLPmax[mLLP,\[Theta]LLP,ch,FacilityGivenExperiment];*)
(*ELLPmin[ch]=ELLPmin[ch,FacilityGivenExperiment];*)
(*\[Theta]maxBrem[ch]=\[Theta]maxBrem[ch,FacilityGivenExperiment]*)
(*,{ch,BremVariantsGivenFacility}]*)
(*ProdListBrem=Select[ProductionListTemp,StringContainsQ[#,"Bremsstrahlung"]&];*)
(*(*ProdListBremSelected=Select[ProdListBrem,\[Theta]maxBrem[#]>\[Theta]minExp&];*)*)
(*ProdListBremSelected=ProdListBrem;*)
(*ProductionList=Join[ProdListBremSelected,Select[ProductionListTemp,!StringContainsQ[#,"Bremsstrahlung"]&]]*)
(*(*Production list with only baseline bremsstrahlung description*)*)
(*BremSelected="Bremsstrahlung-AP-Central-mixing";*)
(*ProductionListBaseline=Select[ProductionList,!StringContainsQ[#,"Bremsstrahlung"]||#==BremSelected&];*)
(*Do[*)
(*If[!MemberQ[ProductionList,_String?(StringContainsQ[#,pattern]&)],*)
(*ProductionPatternSelectedDistr=Select[ProductionPatternSelectedDistr,!StringContainsQ[#[[2]],pattern]&]*)
(*];*)
(*,{pattern,{"AP","Fouroghi-Ritz","BB"}}]*)
(*BremVariantsGivenFacility=Select[ProductionList,StringContainsQ[#,"Bremsstrahlung"]&]*)


(* ::Subsection::Closed:: *)
(*Importing distributions*)


(* ::Input:: *)
(*Do[*)
(*Module[{prod,prodbrem},*)
(*prod=ProductionPatternSelectedDistr[[i]][[2]];*)
(*dirimp=If[StringContainsQ[prod,{"DrellYan","Mixing"}],FileNameJoin[{directory["Distribution"],"Pregenerated"}],directory["Distribution"]];*)
(*(*Importing the data with distribution*)*)
(*If[!StringContainsQ[prod,{"AP","FR"}],*)
(*DistrDataImport[prod]=Abs[Import[FileNameJoin[{dirimp,"DoubleDistr_"<>LLPdirName<>"_"<>prod<>"_"<>FacilityGivenExperiment<>".m"}],"MX"]];*)
(*If[prod=="DrellYan",*)
(*DistrDataImport[prod]=Select[DistrDataImport[prod],MinMaxMassesDrellYan[FacilityGivenExperiment][[1]]<=#[[1]]<=MinMaxMassesDrellYan[FacilityGivenExperiment][[2]]&];*)
(*];*)
(*,*)
(*(*If the selected channel is Bremsstrahlung under the description of AP or FR, then there are variants for the description parametrizing the theoretical uncertainty*)*)
(*DistrDataImportTemp[prod]=Import[FileNameJoin[{dirimp,"DoubleDistr_"<>LLPdirName<>"_"<>prod<>"_"<>FacilityGivenExperiment<>".m"}],"MX"];*)
(*Do[*)
(*prodbrem=StringReplace[prod,"-mixing"->""]<>"-"<>DistrDataImportTemp[prod][[j]][[1]]<>"-mixing";*)
(*DistrDataImport[prodbrem]=DistrDataImportTemp[prod][[j]][[2]];*)
(*mlistDistr[prodbrem]=DeleteDuplicates[DistrDataImport[prodbrem][[All,1]]];*)
(*{mLLPmin[prodbrem],mLLPmax[prodbrem]}=MinMax[mlistDistr[prodbrem]];*)
(*,{j,1,Length[DistrDataImportTemp[prod]],1}];*)
(*];*)
(*]*)
(*,{i,1,Length[ProductionPatternSelectedDistr],1}]*)
(*Do[*)
(*Module[{},*)
(*mlistDistr[prod]=DeleteDuplicates[DistrDataImport[prod][[All,1]]];*)
(*{mLLPmin[prod],mLLPmax[prod]}=MinMax[mlistDistr[prod]];*)
(*DoubleDistrLLPint[mLLP_,\[Theta]LLP_,ELLP_,prod]=10^(Interpolation[distrlogComp[DistrDataImport[prod]],InterpolationOrder->1][Log10[mLLP],Log10[\[Theta]LLP],Log10[ELLP]]);*)
(*If[StringContainsQ[prod,"Bremsstrahlung"],*)
(*DoubleDistrLLPint[mLLP_,\[Theta]LLP_,ELLP_,prod]=If[ELLP<=ELLPmax[mLLP,\[Theta]LLP,prod],Evaluate[DoubleDistrLLPint[mLLP,\[Theta]LLP,ELLP,prod]],0.]];*)
(*(*Probability to produce LLP*)*)
(*ProbLLP[mLLP_,\[Theta]2_,BrhToSS_,prod]=ProbMother[prod]*PmotherToLLP[mLLP,\[Theta]2,BrhToSS,prod,FacilityGivenExperiment]/.{Atarget->AtargetVal,Yield\[Rho]0->ProbMother["Rho0"]};*)
(*]*)
(*,{prod,ProductionList}]*)
(*Do[{GridInFinal[prod],DistrVals[prod]}=BlockGridsValsDistr[prod,DistrDataImport],{prod,ProductionList}];//AbsoluteTiming*)
(*(*____________________________*)*)
(*(*Finding Subscript[E, max](Subscript[m, LLP],Subscript[\[Theta], LLP]) for the angular range at the given experiment*)*)
(*(*____________________________*)*)
(*Do[ELLPmax[mfip_,\[Theta]fip_,prod]=EmaxBlock[prod,8,DistrDataImport,FacilityGivenExperiment],{prod,Select[ProductionList,!StringContainsQ[#,"Bremsstrahlung"]&]}]//AbsoluteTiming*)


(* ::Subsection::Closed:: *)
(*Exporting averaged distribution*)


(* ::Input:: *)
(*directory["Auxiliary-experiment"]=FileNameJoin[{directory["Auxiliary"],SelectedExperiment}];*)
(*If[!DirectoryQ[directory["Auxiliary-experiment"]],CreateDirectory[directory["Auxiliary-experiment"]]];*)
(*Export[FileNameJoin[{directory["Auxiliary-experiment"],"Double-Distr-Averaged-"<>LLPdirName<>".m"}],{Sum[If[mLLPmin[prod]<mLLP<mLLPmax[prod],Evaluate[ProbLLP[mLLP,1,0.01,prod]],0],{prod,ProductionListBaseline}],(1/Sum[If[mLLPmin[prod]<mLLP<mLLPmax[prod],Evaluate[ProbLLP[mLLP,1,0.01,prod]],0],{prod,ProductionList}])Sum[If[mLLPmin[prod]<mLLP<mLLPmax[prod],Evaluate[ProbLLP[mLLP,1,0.01,prod]*DoubleDistrLLPint[mLLP,\[Theta]LLP,ELLP,prod]],0],{prod,ProductionListBaseline}]},"MX"];*)


(* ::Section::Closed:: *)
(*Plots*)


(* ::Input:: *)
(*ptenergies=LogLogPlot[Evaluate[Table[ELLPmax[0.1,\[Theta]LLP,prod],{prod,ProductionListBaseline}]],{\[Theta]LLP,\[Theta]minExp,\[Theta]maxExp},Frame->True,ImageSize->Large,PlotLegends->Placed[Style[#,15]&/@ProductionListBaseline,Right]];*)
(*ptprodprob=LogLogPlot[Evaluate[Table[ProbLLP[ma,10^-10,0.01,prod],{prod,ProductionListBaseline}]],{ma,mmin\[Epsilon],mmax\[Epsilon]},Frame->True,ImageSize->Large,PlotLegends->Placed[Style[#,16]&/@ProductionListBaseline,{0.34,0.28}], FrameStyle->Directive[Black, 25],PlotRange->{{0.02,3},{10^-20,10^-13}},PlotStyle->{{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green},{Thick,Darker@Cyan},{Thick,Magenta},{Thick,Brown}},AspectRatio->0.66,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(m\), \(LLP\)]\) [GeV]","\!\(\*SubscriptBox[\(P\), \(prod\)]\)/\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\)"},PlotLabel->Style[Row[{"Production probabilities of ",LLPdirName," at ",SelectedExperiment}],18,Black]];*)
(*ptprodprobbrem=LogLogPlot[Evaluate[Table[ProbLLP[ma,1,0,prod],{prod,BremVariantsGivenFacility}]],{ma,mmin\[Epsilon],mmax\[Epsilon]},Frame->True,ImageSize->Large,PlotLegends->Placed[Style[#,16]&/@BremVariantsGivenFacility,Right], FrameStyle->Directive[Black, 25],PlotRange->{{0.02,2},{10^-12,0.001}},PlotStyle->{{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green},{Thick,Darker@Cyan},{Thick,Magenta},{Thick,Brown}},AspectRatio->0.66,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(m\), \(LLP\)]\) [GeV]","\!\(\*SubscriptBox[\(P\), \(prod\)]\)/\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\)"},PlotLabel->Style[Row[{"Production probabilities of ",LLPdirName," at ",SelectedExperiment}],18,Black]];*)
(*Style[Row[{ptprodprob,ptenergies,ptprodprobbrem}],ImageSizeMultipliers->{1, 1,1}]*)


(* ::Chapter::Closed:: *)
(*Number of events*)


(* ::Section::Closed:: *)
(*Number of events *)


(* ::Subsection::Closed:: *)
(*Initializing all routines*)


(* ::Input:: *)
(*Do[{OutGrid\[Theta]final[prod],\[CapitalDelta]\[Theta]vals[prod]}=OutGrid\[Theta]Temp[InGrid\[Theta]\[Epsilon],30,prod,\[Theta]maxBrem[prod]],{prod,ProductionList}]*)
(*{OutGridzfinal,\[CapitalDelta]zvals}=OutGridszTemp[InGridz\[Epsilon],30,zminExp];*)
(*(*Final energy grid. Mass- and production channel-dependent*)*)
(*If[FacilityGivenExperiment!="ESS",*)
(*StepEtemp[Efip_]=Piecewise[{{0.3,Efip<=2.5},{0.5,2.5<Efip<35},{2,35<=Efip<=50},{4,50<Efip<160},{5,160<=Efip<=400},{25,400<Efip<600},{50,600<=Efip<2000},{200,2000<=Efip<4000},{400,4000<=Efip<7000},{500,7000<=Efip<=50000}}];*)
(*OutGridEnergy[m_,ProdChannel_]:=Block[{},*)
(*emin=If[!StringContainsQ[ProdChannel,"Bremsstrahlung"],N[m],ELLPmin[ProdChannel]];*)
(*egridtemp=With[{start=emin,end=ELLPmax[m,\[Theta]minExp,ProdChannel]},*)
(*Log10[NestWhileList[#+StepEtemp[#]&,start,#<=end&,1,\[Infinity],-1]]]//N;*)
(*If[Length[egridtemp]==1,egridtemp=Join[egridtemp,{Log10[2*emin]}]];*)
(*egridtemp*)
(*]*)
(*,*)
(*StepEtemp[Efip_]=0.001;*)
(*OutGridEnergy[m_,ProdChannel_]:=Block[{},*)
(*tabt=Table[e,{e,1.0001m,ELLPmax[m,\[Theta]minExp,ProdChannel],0.001}];*)
(*If[Length[tabt]==1,tabt=Join[tabt,{ELLPmax[m,\[Theta]minExp,ProdChannel]}]//Sort//DeleteDuplicates];*)
(*Log10[tabt]//N*)
(*]*)
(*]*)
(*(*____________________________________________________*)*)
(*(*Block that computes the grid Subscript[\[Theta], S],Subscript[E, S],Subscript[z, S], Subscript[\[Epsilon], Full]\[Times]Subscript[f, Subscript[\[Theta], S],Subscript[E, S]]*)*)
(*(*____________________________________________________*)*)
(*(*The block which sets all the values of Subscript[\[Epsilon], Full]\[Times]Subscript[f, \[Theta],E] for which E < Subscript[E, max] to zero, for Bremsstrahlung*)*)
(*createCompiledFunctionBrem[BremChoice_]:=Module[{func},*)
(*func[mfip_,th_]=ELLPmax[mfip,th,BremChoice];*)
(*Hold@Compile[{{angleenergy,_Real,1},{mfip,_Real}},Module[{angles,energies,distrvals,d},*)
(*angles=Compile`GetElement[angleenergy,1];*)
(*energies=Compile`GetElement[angleenergy,2];*)
(*distrvals=Compile`GetElement[angleenergy,3];*)
(*d=If[energies<func[mfip,angles],distrvals,10^-90.];*)
(*d],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/. DownValues@func//ReleaseHold*)
(*];*)
(*(*Generate a dictionary of compiled functions for each variant*)compiledBremCutter=AssociationThread[BremVariantsGivenFacility,createCompiledFunctionBrem/@BremVariantsGivenFacility];*)
(*BremCut[OutGrid\[Theta]final_,OutGridEfinal_,distr_,mLLP_,bremChoice_]:=Block[{},*)
(*angleenergy=Join[10^Tuples[{OutGrid\[Theta]final,OutGridEfinal}],Partition[distr,1],2];*)
(*compiledFunc=compiledBremCutter[bremChoice];*)
(*compiledFunc[angleenergy,mLLP]*)
(*];*)
(*TableIntegrandDiscret[m_,ProdChannel_,\[Epsilon]DecOp_]:=TableIntegrandDiscretTemp[m,ProdChannel,\[Epsilon]DecOp,\[Epsilon]vals,\[Epsilon]azvals,OutGrid\[Theta]final[ProdChannel],OutGridzfinal,OutGridEnergy,InGridm\[Epsilon],InGrid\[Theta]\[Epsilon],InGridE\[Epsilon],InGridz\[Epsilon],\[CapitalDelta]\[Theta]vals[ProdChannel],\[CapitalDelta]zvals,zminExp,GridInFinal,DistrVals,FacilityGivenExperiment,ELLPmax,\[Theta]minExp]*)


(* ::Subsection::Closed:: *)
(*Generalized acceptances*)


(* ::Input:: *)
(*(*Tabulated acceptance*)*)
(*FactorANUBISceiling=If[SelectedExperiment=="ANUBIS-ceiling",2,1];*)
(*AcceptanceDiscret[m_,ProdChannel_,\[Epsilon]decOp_,decProb_]:=AcceptanceDiscretTemp[m,ProdChannel,\[Epsilon]decOp,decProb,mLLPmin,mmin\[Epsilon],mLLPmax,mmax\[Epsilon],ELLPmax,\[Theta]minExp,TableIntegrandDiscret,BrVis,zmaxExp,zminExp,FactorANUBISceiling,0.]*)
(*Do[mlistAcceptance[prod]=Select[Join[{1.01Max[mLLPmin[prod],mmin\[Epsilon]]},10^InGridm\[Epsilon],{Min[mLLPmax[prod],mmax\[Epsilon]]}],mLLPmin[prod]<=#<=mLLPmax[prod]&]//Sort//DeleteDuplicates;*)
(*,{prod,ProductionList}];*)
(*Do[*)
(*\[Epsilon]GeomTabs[prod]=ParallelTable[{m,AcceptanceDiscret[m,prod,"False",0],AcceptanceDiscret[m,prod,"True",0],AcceptanceDiscret[m,prod,"False",1],AcceptanceDiscret[m,prod,"True",1]},{m,mlistAcceptance[prod]}];*)
(*,{prod,ProductionList}];//AbsoluteTiming*)
(*PlotAcc[ProdChannel_]:=ListLogPlot[Evaluate[{\[Epsilon]GeomTabs[ProdChannel][[All,{1,2}]],\[Epsilon]GeomTabs[ProdChannel][[All,{1,3}]],\[Epsilon]GeomTabs[ProdChannel][[All,{1,4}]],\[Epsilon]GeomTabs[ProdChannel][[All,{1,5}]]}],FrameStyle->Directive[Black, 22],PlotStyle->{{Thickness[0.003],Blue},{Thickness[0.003],Darker@Red},{Thickness[0.003],Darker@Darker@Green},{Thickness[0.003],Black}},GridLines->Automatic,PlotRange->{MinMax[\[Epsilon]GeomTabs[ProdChannel][[All,1]]],{Max[0.9Min[Min[\[Epsilon]GeomTabs[ProdChannel][[All,4]]],Min[\[Epsilon]GeomTabs[ProdChannel][[All,3]]]],10^-5],1.1Max[Max[\[Epsilon]GeomTabs[ProdChannel][[All,2]]],Max[\[Epsilon]GeomTabs[ProdChannel][[All,4]]]]}},Joined->True,Frame->True,ImageSize->Large,FrameLabel->{"m [GeV]","Acceptance"},PlotLabel-> Style[Row[{"From ",ProdChannel}], 20, Black],PlotLegends->Placed[{Style[#, 18]&/@{"<\!\(\*SubscriptBox[\(\[Epsilon]\), \(LLP\)]\)>","<\!\(\*SubscriptBox[\(\[Epsilon]\), \(LLP\)]\)\!\(\*SubscriptBox[\(\[Epsilon]\), \(decay\)]\)>","c\[Tau]<\!\(\*SubscriptBox[\(\[Epsilon]\), \(LLP\)]\)\!\(\*SubscriptBox[\(P\), \(decay\)]\)>","c\[Tau]<\!\(\*SubscriptBox[\(\[Epsilon]\), \(LLP\)]\)\!\(\*SubscriptBox[\(P\), \(decay\)]\)\!\(\*SubscriptBox[\(\[Epsilon]\), \(decay\)]\)>"}},{0.75,0.2}]]*)
(*Style[Row[Evaluate[Table[PlotAcc[prod],{prod,ProductionList}]]],ImageSizeMultipliers->{1,1,1,1}]*)
(*(*Do[FilenameAcceptance[prod]=ToString@StringForm["Acceptance_ALP-fermion_at_``_From_``.dat",Sequence@@{SelectedExperiment,ExportList[prod]}];*)
(*Export[FileNameJoin[{NotebookDirectory[],"Auxiliary data/ALPs with fermion coupling",SelectedExperiment,FilenameAcceptance[prod]}],\[Epsilon]GeomTabs[prod][[All,{1,2,4,5}]],"Table"]*)
(*,{prod,ProductionList}]*)*)
(*AccAveraged[mLLP_,\[Theta]2_,BrhToSS_]=NpotGivenExperiment{Sum[If[mLLPmin[prod]<mLLP<mLLPmax[prod],Evaluate[ProbLLP[mLLP,\[Theta]2,BrhToSS,prod]],0],{prod,ProductionListBaseline}],Sum[If[Max[mLLPmin[prod],mmin\[Epsilon]]<mLLP<Min[mLLPmax[prod],mmax\[Epsilon]],Evaluate[ProbLLP[mLLP,\[Theta]2,BrhToSS,prod]*Interpolation[\[Epsilon]GeomTabs[prod][[All,{1,2}]],InterpolationOrder->1][mLLP]],0],{prod,ProductionListBaseline}],Sum[If[Max[mLLPmin[prod],mmin\[Epsilon]]<mLLP<Min[mLLPmax[prod],mmax\[Epsilon]],Evaluate[ProbLLP[mLLP,\[Theta]2,BrhToSS,prod]/c\[Tau]acc*Interpolation[\[Epsilon]GeomTabs[prod][[All,{1,4}]],InterpolationOrder->1][mLLP]],0],{prod,ProductionListBaseline}],Sum[If[Max[mLLPmin[prod],mmin\[Epsilon]]<mLLP<Min[mLLPmax[prod],mmax\[Epsilon]],Evaluate[ProbLLP[mLLP,\[Theta]2,BrhToSS,prod]/c\[Tau]acc*Interpolation[\[Epsilon]GeomTabs[prod][[All,{1,5}]],InterpolationOrder->1][mLLP]],0],{prod,ProductionListBaseline}]};*)
(*Export[FileNameJoin[{directory["Auxiliary-experiment"],"AcceptanceAveraged-"<>LLPdirName<>".m"}],AccAveraged[mLLP,\[Theta]2,BrhToSS],"MX"];*)


(* ::Subsection::Closed:: *)
(*Rough estimates of the upper and lower bounds*)


(* ::Input:: *)
(**)
(*BrhToSSreference=0.15;*)
(*Do[*)
(*factorLowerBound=If[StringContainsQ[prod,"mixing"],1/2,1];*)
(*LowerBoundEstimate[mLLP_,prod]=((NpotGivenExperiment*ProbLLP[mLLP,1,BrhToSSreference,prod]*Interpolation[\[Epsilon]GeomTabs[prod][[All,{1,5}]],InterpolationOrder->1][mLLP])/(2.3ldecayLLP[mLLP,1,ELLP] mLLP/Sqrt[ELLP^2-mLLP^2]))^-factorLowerBound;*)
(*UpperBoundEstimate[mLLP_,prod]=(Abs[Re[Evaluate[-(ProductLog[-1,-2.3*b/a]/b)/.{a-> NpotGivenExperiment*ProbLLP[mLLP,1,BrhToSSreference,prod]*Interpolation[\[Epsilon]GeomTabs[prod][[All,{1,3}]],InterpolationOrder->1][mLLP],b->zminExp/ldecayLLP[mLLP,1,ELLPmax[0.5,\[Theta]minExp,prod]]}]]]),{prod,ProductionList}]*)
(*ProdTest=ProductionList[[1]]*)
(*LogLogPlot[Evaluate[{0.3LowerBoundEstimate[mLLP,ProdTest],1.8UpperBoundEstimate[mLLP,ProdTest]}],{mLLP,Max[mLLPmin[ProdTest],mmin\[Epsilon]],Min[mLLPmax[ProdTest],mmax\[Epsilon]]},Frame->True,ImageSize->Large]*)


(* ::Subsection::Closed:: *)
(*Number of events - fast*)


(* ::Input:: *)
(*FactorLowerBound=If[MemberQ[{"ANUBIS-shaft-volume-1","ANUBIS-shaft-volume-2","ANUBIS-shaft-volume-3"},SelectedExperiment]==True,0.1,0.3];*)
(*NeventsDiscret[m_,ProdChannel_,BrhToSS_,\[Theta]2list_]:=Module[{NevDiscret(*,NpotTimes\[Chi]val*)},*)
(*If[Max[mmin\[Epsilon],mLLPmin[ProdChannel]]<m<Min[mLLPmax[ProdChannel],mmax\[Epsilon]],*)
(*integrandtab=TableIntegrandDiscret[m,ProdChannel,"True"];*)
(*NpotTimes\[Chi]val[\[Theta]2_]=FactorANUBISceiling*NpotGivenExperiment*ProbLLP[m,\[Theta]2,BrhToSS,ProdChannel];*)
(*{lowerbound,upperbound}={LowerBoundEstimate[m,ProdChannel],UpperBoundEstimate[m,ProdChannel]};*)
(*brvis=BrVis[m];*)
(*NevDiscret[\[Theta]2_]:=If[brvis!=0,If[FactorLowerBound*lowerbound<\[Theta]2<2upperbound,NpotTimes\[Chi]val[\[Theta]2]*brvis*sumcompile[tableprefac[integrandtab,m,c\[Tau]LLP[m,\[Theta]2],1,0.]],0.],0.];*)
(*Table[{m,\[Theta]2list[[i]],NevDiscret[\[Theta]2list[[i]]]},{i,1,Length[\[Theta]2list],1}],Table[{m,\[Theta]2list[[i]],0.},{i,1,Length[\[Theta]2list],1}]]*)
(*]*)


(* ::Subsection::Closed:: *)
(*Number of events - slow (using built-in Mathematica functions Interpolation, NIntegrate)*)


(* ::Input:: *)
(*(*Differential decay probability 1/ldecayExp[-l/ldecay], where l is expressed in terms of the longitudinal displacement z and polar angle \[Theta] as z/cos\[Theta]*)*)
(*(*Differential decay probability (1/ldecay)Exp[-l/ldecay], where l is expressed in terms of the longitudinal displacement z and polar angle \[Theta] as z/cos\[Theta]*)*)
(*PdecayDensity[mLLP_,coupling_,\[Theta]LLP_,ELLP_,zLLP_]=Exp[-zLLP/(Cos[\[Theta]LLP]*ldecayLLP[mLLP,coupling,ELLP])]/(Abs[Cos[\[Theta]LLP]]*ldecayLLP[mLLP,coupling,ELLP]);*)
(*(*The integrand determining the differential rate for events*)*)
(*Do[IntegrandLLP[mLLP_,coupling_,\[Theta]LLP_,ELLP_,zLLP_,prod]=DoubleDistrLLPint[mLLP,\[Theta]LLP,ELLP,prod]*PdecayDensity[mLLP,coupling,\[Theta]LLP,ELLP,zLLP]*AzimuthalAcceptanceInt[\[Theta]LLP,zLLP]*DecayAcceptanceInt[mLLP,\[Theta]LLP,ELLP,zLLP],{prod,ProductionList}]*)
(*IntegralLLP[mLLP_,coupling_,ProdChannel_]:=NIntegrate[Abs[IntegrandLLP[mLLP,coupling,\[Theta]LLP,Exp[ELLP],zLLP,ProdChannel]Exp[ELLP]],{\[Theta]LLP,\[Theta]minExp,\[Theta]maxExp},{ELLP,Log[mLLP],Log[ELLPmax[mLLP,\[Theta]LLP,ProdChannel]]},{zLLP,zmin\[Theta][\[Theta]LLP],zmax\[Theta][\[Theta]LLP]},Method->"AdaptiveMonteCarlo"]*)
(*(*IntegralLLP[mLLP_,finv_,ProdChannel_]:=NIntegrate[Abs[IntegrandLLP[mLLP,finv,Exp[\[Theta]LLP],Exp[ELLP],Exp[zLLP],ProdChannel]]Exp[\[Theta]LLP+ELLP+zLLP],{\[Theta]LLP,Log[\[Theta]minExp],Log[\[Theta]maxExp]},{ELLP,Log[mLLP],Log[ELLPmax[mLLP,Exp[\[Theta]LLP],ProdChannel]]},{zLLP,Log[zmin\[Theta][Exp[\[Theta]LLP]]],Log[zmax\[Theta][Exp[\[Theta]LLP]]]},Method\[Rule]"AdaptiveMonteCarlo"]*)*)
(*NeventsInt[mLLP_,\[Theta]2_,BrhToSS_,ProdChannel_]:=FactorANUBISceiling*If[mLLPmin[ProdChannel]<=mLLP<=mLLPmax[ProdChannel]&&BrVis[mLLP]!=0,If[FactorLowerBound*LowerBoundEstimate[mLLP,ProdChannel]<\[Theta]2<2UpperBoundEstimate[mLLP,ProdChannel],NpotGivenExperiment*ProbLLP[mLLP,\[Theta]2,BrhToSS,ProdChannel]*IntegralLLP[mLLP,\[Theta]2,ProdChannel],0.],0.]*)
(*IntegralLLPE[mLLP_,\[Theta]2_,ProdChannel_,ELLP_]:=NIntegrate[Abs[IntegrandLLP[mLLP,\[Theta]2,\[Theta]LLP,ELLP,zLLP,ProdChannel]],{\[Theta]LLP,\[Theta]minExp,\[Theta]maxExp},{zLLP,zmin\[Theta][\[Theta]LLP],zmax\[Theta][\[Theta]LLP]},Method->"AdaptiveMonteCarlo"]*)
(*NeventsDiffIntE[mLLP_,\[Theta]2_,BrhToSS_,ProdChannel_,ELLP_]:=If[mLLPmin[ProdChannel]<=mLLP<=mLLPmax[ProdChannel]&&BrVis[mLLP]!=0&&mLLP<ELLP<=ELLPmax[mLLP,\[Theta]minExp,ProdChannel],If[0.1LowerBoundEstimate[mLLP,ProdChannel]<\[Theta]2<2UpperBoundEstimate[mLLP,ProdChannel],NpotGivenExperiment*ProbLLP[mLLP,\[Theta]2,BrhToSS,ProdChannel]*IntegralLLPE[mLLP,\[Theta]2,ProdChannel,ELLP],0.],0.]*)
(*IntegralLLPz[mLLP_,\[Theta]2_,ProdChannel_,zLLP_]:=NIntegrate[Abs[IntegrandLLP[mLLP,\[Theta]2,\[Theta]LLP,Exp[ELLP],zLLP,ProdChannel]]Exp[ELLP],{\[Theta]LLP,\[Theta]minExp,\[Theta]maxExp},{ELLP,Log[mLLP],Log[Evaluate[ELLPmax[mLLP,\[Theta]LLP,ProdChannel]]]},Method->"AdaptiveMonteCarlo"]*)
(*NeventsDiffIntz[mLLP_,\[Theta]2_,BrhToSS_,ProdChannel_,zLLP_]:=If[mLLPmin[ProdChannel]<=mLLP<=mLLPmax[ProdChannel]&&BrVis[mLLP]!=0&&zminExp<=zLLP<=zmaxExp,If[0.1LowerBoundEstimate[mLLP,ProdChannel]<\[Theta]2<2UpperBoundEstimate[mLLP,ProdChannel],NpotGivenExperiment*ProbLLP[mLLP,\[Theta]2,BrhToSS,ProdChannel]*IntegralLLPz[mLLP,\[Theta]2,ProdChannel,zLLP],0.],0.]*)


(* ::Section::Closed:: *)
(*Tests*)


(* ::Subsection::Closed:: *)
(*Total number of events*)


(* ::Input:: *)
(*(*This is a comparison between the slow and fast integration methods. For the selected mass and production channel, the numbers of events obtained using the methods should agree within 10%*)*)
(*(*If the agreement is worse, there may be a few reasons*)*)
(*(*1) The grid for the fast method is not dense enough. Try to increase the grid density (OutGrid\[Theta]final, OutGridEfinal, OutGridzfinal) to see whether the agreement improves. Sometimes, even a slightly denser grid for e.g. z may lead to a significant improvement in the agrement*)*)
(*(*2) The Monte-Carlo integrator for the slow method fails to evaluate properly; this may happen if the range of the integration over energies is too large compared to the domain where most of the events actually are (off-axis experiments such as MATHUSLA and ANUBIS). Another symptom is that for the given mass and coupling the integral "jumps", i.e., returns values with large error*)*)
(*(*A separate discussion should be made for the couplings belong to the domain c\[Tau] \[Gamma] << Subscript[z, experiment]. The discrepancy may be significant, and the reason is insufficient grid density for the fast integration method. However, due to the exponential suppression of the number of events, this may be compensated by a tiny shift in the coupling, so the discrepancy should be considered as appropriate.*)*)
(*mtest=If[MemberQ[{"LHC","FCC-hh"},FacilityGivenExperiment]==True,5,0.5];*)
(*ProdTest=If[MemberQ[{"LHC","FCC-hh"},FacilityGivenExperiment]==True,"h-quartic","B-mixing"];*)
(*couplinglist=(*{10^-12,3*10^-12,5*10^-12,10^-11,5*10^-11,10^-10,5*10^-10,10^-9,5*10^-9,10^-8,2*10^-8,4*10^-8,10^-7,5*10^-7,6*10^-7,7*10^-7,8*10^-7,9*10^-7,10^-6,2*10^-6}//N*)Table[10^x,{x,-17.,-3.,0.3}];*)
(*dat1=NeventsDiscret[mtest,ProdTest,BrhToSSreference,couplinglist];//AbsoluteTiming*)
(*dat2=ParallelTable[{couplinglist[[i]],c\[Tau]LLP[mtest,couplinglist[[i]]],Quiet[NeventsInt[mtest,couplinglist[[i]],BrhToSSreference,ProdTest]]},{i,1,Length[couplinglist],1}];//AbsoluteTiming*)
(*Join[{{"\!\(\*FractionBox[SubscriptBox[\(m\), \(LLP\)], \(GeV\)]\)","coupling","\!\(\*FractionBox[\(c\[Tau]\), SubscriptBox[\(z\), \(min\)]]\)","\!\(\*SubscriptBox[\(N\), \(events, fast\)]\)","\!\(\*SubscriptBox[\(N\), \(events, slow\)]\)"}},Join[dat1[[All,{1,2}]],{#[[2]]/zminExp}&/@dat2,dat1[[All,{3}]],dat2[[All,{3}]],2]]//TableForm*)


(* ::Subsection::Closed:: *)
(*Differential number of events*)


(* ::Input:: *)
(*(*Variable = "Subscript[E, X]","Subscript[z, X]","Subscript[\[Theta], X]". The number belongs to the column in the tabulated data*)*)
(*iVal:=Association[{"\!\(\*SubscriptBox[\(E\), \(X\)]\)" ->2,"\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\)"->1,"\!\(\*SubscriptBox[\(z\), \(X\)]\)"->3}]*)
(*Do[*)
(*\[CapitalDelta]xvals["\!\(\*SubscriptBox[\(E\), \(X\)]\)",prod]:=\[CapitalDelta]Evals;*)
(*\[CapitalDelta]xvals["\!\(\*SubscriptBox[\(z\), \(X\)]\)",prod]=\[CapitalDelta]zvals;*)
(*\[CapitalDelta]xvals["\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\)",prod]=\[CapitalDelta]\[Theta]vals[prod]*)
(*,{prod,ProductionList}];*)
(*LegendX:=Association[{"\!\(\*SubscriptBox[\(E\), \(X\)]\)"->"\!\(\*SubscriptBox[\(E\), \(X\)]\) [GeV]","\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\)"->"\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\) [rad]","\!\(\*SubscriptBox[\(z\), \(X\)]\)"-> "\!\(\*SubscriptBox[\(z\), \(X\)]\) [m]"}]*)
(*LegendY:=Association[{"\!\(\*SubscriptBox[\(E\), \(X\)]\)"->"\!\(\*SubscriptBox[\(dN\), \(ev\)]\)/\!\(\*SubscriptBox[\(dE\), \(X\)]\) [\!\(\*SuperscriptBox[\(GeV\), \(-1\)]\)]","\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\)"->"\!\(\*SubscriptBox[\(dN\), \(ev\)]\)/\!\(\*SubscriptBox[\(d\[Theta]\), \(X\)]\) [\!\(\*SuperscriptBox[\(rad\), \(-1\)]\)]","\!\(\*SubscriptBox[\(z\), \(X\)]\)"-> "\!\(\*SubscriptBox[\(dN\), \(ev\)]\)/\!\(\*SubscriptBox[\(dz\), \(X\)]\) [\!\(\*SuperscriptBox[\(m\), \(-1\)]\)]"}]*)
(*(*Differential number of events*)*)
(*NeventsDifferentialDiscretProd[m_,ProdChannel_,coupling_,BrhToSS_,Variable_]:=Module[{NpotTimes\[Chi]val},*)
(*ival=iVal[Variable];*)
(*NpotTimes\[Chi]val=NpotGivenExperiment*ProbLLP[m,coupling,BrhToSS,ProdChannel];*)
(*tablegrid0=TableIntegrandDiscret[m,ProdChannel,"True"];*)
(*OutGridEfinalTemp=OutGridEnergy[N[m],ProdChannel];*)
(*\[CapitalDelta]Evals=(Rest[10^OutGridEfinalTemp]-Most[10^OutGridEfinalTemp]);*)
(*\[CapitalDelta]xval=\[CapitalDelta]xvals[Variable,ProdChannel];*)
(*c\[Tau]Val=c\[Tau]LLP[m,coupling];*)
(*brvis=BrVis[m];*)
(*ilist=DeleteDuplicates[{ival,1,2,3}];*)
(*tablegrid1=SortBy[{#[[ilist[[1]]]],#[[ilist[[2]]]],#[[ilist[[3]]]],#[[4]]}&/@tableGridPrefac[tablegrid0,m,c\[Tau]Val,0.],{#[[1]],#[[2]],#[[3]]}&];*)
(*GridQuantity=tablegrid1[[All,1]]//DeleteDuplicates;*)
(*LengthPerVariable=Length[tablegrid1]/Length[GridQuantity];*)
(*tab1=NdiffCompiled[tablegrid1,GridQuantity,LengthPerVariable,NpotTimes\[Chi]val*brvis];*)
(*Join[tab1[[All,{1}]],Partition[tab1[[All,2]]*\[CapitalDelta]xval^-1,1],2]*)
(*]*)
(*NeventsDifferentialDiscret[m_,coupling_,BrhToSS_,Variable_]:=Module[{NdiffInt,LegendList,QuantityMinMax,ValueMinMax},*)
(*prodlisttemp={};*)
(*Do[If[Max[mLLPmin[prod],mmin\[Epsilon]]<m<Min[mLLPmax[prod],mmax\[Epsilon]],*)
(*prodlisttemp=Join[prodlisttemp,{prod}];*)
(*NdiffData[prod]=NeventsDifferentialDiscretProd[m,prod,coupling,BrhToSS,Variable];*)
(*XvalminmaxNdiff=Select[NdiffData[prod],#[[2]]>10^-40&][[All,1]]//MinMax;*)
(*NdiffInt[X_,prod]=If[XvalminmaxNdiff[[1]]<X<XvalminmaxNdiff[[2]],Evaluate[10^Interpolation[{Log10[#[[1]]],Log10[#[[2]]+10^-90]}&/@NdiffData[prod],InterpolationOrder->1][Log10[X]]],0]],{prod,ProductionListBaseline}];*)
(*NdiffInt[X_,"Total"]=Sum[NdiffInt[X,prod],{prod,prodlisttemp}];*)
(*LegendList=Join[{"Total"},prodlisttemp];*)
(*QuantityMinMax=Flatten[Table[MinMax[NdiffData[prod][[All,1]]],{prod,prodlisttemp}],1]//MinMax;*)
(*ValueMinMax=Max[Max[NdiffData[#][[All,2]]]&/@prodlisttemp];*)
(*{Table[NdiffInt[X,prod],{prod,LegendList}],LegendList,QuantityMinMax,ValueMinMax}*)
(*]*)
(*mvaltest=If[FacilityGivenExperiment=="ESS",0.04,3];*)
(*couplingvaltest=1.4LowerBoundEstimate[mvaltest,"B-mixing"];*)
(*BrhToSStest=0.0;*)
(*quantity="\!\(\*SubscriptBox[\(\[Theta]\), \(X\)]\)";*)
(*{NdiffTab[X_],LegendList,QuantityMinMax,ValueMinMax}=NeventsDifferentialDiscret[mvaltest,couplingvaltest,BrhToSStest,quantity];*)
(*Do[*)
(*prch=LegendList[[i]];*)
(*NdiffInt[X_,prch]=NdiffTab[X][[i]];*)
(*,{i,1,Length[LegendList]}];*)
(*plotdiff=LogLogPlot[Evaluate[Table[NdiffInt[X,prod],{prod,LegendList}]],{X,QuantityMinMax[[1]],QuantityMinMax[[2]]},Frame->True,ImageSize->Large,PlotRange->{All,{10^-5,2ValueMinMax}},PlotStyle->{{Thick,Black},{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green},{Thick,Darker@Cyan},{Thick,Magenta},{Thick,Blue,Dashing[0.02]},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green,Dashing[0.02]}},PlotLegends->Placed[Style[#,20]&/@LegendList,Right],FrameLabel->{LegendX[quantity] ,LegendY[quantity]},FrameStyle->Directive[Black, 18],PlotLabel->Style[Row[{SelectedExperiment,". \!\(\*SubscriptBox[\(m\), \(S\)]\) = ",mvaltest," GeV, \!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\) = ",couplingvaltest//N,", \!\(\*SubscriptBox[\(Br\), \(h -> SS\)]\) = ",BrhToSStest}],14,Black]]*)


(* ::Title::Closed:: *)
(*Exporting tabulated number of events*)


(* ::Chapter::Closed:: *)
(*Definitions*)


(* ::Input:: *)
(*directory["Nevents"]=FileNameJoin[{NotebookDirectory[],"Tabulated Nevents"}];*)
(*directory["Nevents-LLP"]=FileNameJoin[{NotebookDirectory[],"Tabulated Nevents",LLPdirName}];*)
(*directory["Nevents-LLP-experiment"]=FileNameJoin[{NotebookDirectory[],"Tabulated Nevents",LLPdirName,SelectedExperiment}];*)
(*If[!DirectoryQ[directory[#]],CreateDirectory[directory[#]]]&/@{"Nevents","Nevents-LLP","Nevents-LLP-experiment"};*)
(*Print["Filenames with tabulated \!\(\*SubscriptBox[\(N\), \(events\)]\):"]*)
(*Do[FilenameNeventsInt[prod]=ToString@StringForm["Nevents_``_``_at_``_Npot=``.dat",Sequence@@{LLPdirName,prod,SelectedExperiment,NpotGivenExperiment//CForm//ToString}],{prod,ProductionList}]*)
(*FilenameNeventsInt[#]&/@ProductionList*)
(*Do[mRangeExport[brem]={0.021,0.031,0.041,0.051,0.06,0.07,0.08,0.09,0.1,0.13,0.15,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.225,0.23,0.24,0.25,0.26,0.27,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.4,0.45,0.5,0.6,0.7,0.8,0.85,0.9,0.95,0.99,1.,1.01,1.02,1.025,1.03,1.05,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.99,2.1,2.2,2.3,2.4,2.5};*)
(*,{brem,BremVariantsGivenFacility}];*)
(*mRangeExport["K-mixing"]={0.021,0.051,0.1,0.13,0.15,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.23,0.24,0.25,0.26,0.27,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.995(mSM["Kplus"]-mSM["PiPlus"])};*)
(*mRangeExport["B-quartic"]={0.021,0.051,0.1,0.13,0.15,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.23,0.24,0.25,0.26,0.27,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.8,0.85,0.9,0.95,0.99,1.02,1.05,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.99,2.05,2.1,2.2,2.3,2.4,2.5,2.55};*)
(*mRangeExport["B-mixing"]={0.021,0.051,0.1,0.13,0.15,0.17,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.23,0.24,0.25,0.26,0.27,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.8,0.85,0.9,0.95,0.99,1.02,1.05,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.99,2.1,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,3.1,3.2,3.3,3.5,3.6,3.7,3.8,3.9,4,4.1,4.2,4.3,4.4,4.5,4.6,4.65,4.7,4.75,4.77,4.8,4.83,4.85,4.87,4.9,4.93,4.95,4.97,5,5.03,5.05,5.07,5.1};*)
(*mRangeExport["Bs-quartic"]={0.021,0.051,0.1,0.13,0.15,0.17,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.23,0.25,0.26,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.5,0.55,0.6,0.65,0.7,0.8,0.85,0.9,0.95,0.99,1.02,1.05,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.99,2.05,2.1,2.2,2.3,2.4,2.5,2.55,2.6,2.65};*)
(*mRangeExport["h-quartic"]={0.021,0.051,0.1,0.13,0.15,0.17,0.2,0.205,0.21,0.212,0.214,0.216,0.218,0.22,0.23,0.24,0.25,0.26,0.27,0.275,0.28,0.285,0.289,0.3,0.32,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.8,0.85,0.9,0.95,0.99,1.02,1.05,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.99,2.1,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9,4,4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9,5,5.1,7.,10.,10.6,12.,15.,20.,30.,40.,45.,50.,55.,60.,61.,62.,62.49};*)
(*couplingsRangeExport=Table[10^x,{x,-20,-3,0.02}]//N;*)


(* ::Chapter::Closed:: *)
(*Exporting*)


(* ::Input:: *)
(*BlockExport[ProdChannel_]:=Block[{},*)
(*mlist=mRangeExport[ProdChannel];*)
(*TabFrom=ParallelTable[Quiet[NeventsDiscret[mlist[[k]],ProdChannel,BrhToSSreference,couplingsRangeExport]],{k,1,Length[mlist],1}];*)
(*Export[FileNameJoin[{directory["Nevents-LLP-experiment"],FilenameNeventsInt[ProdChannel]}],Flatten[TabFrom,1],"Table"]*)
(*]*)
(*Monitor[*)
(*Do[*)
(*prod=ProductionList[[j]];*)
(*BlockExport[prod],{j,1,Length[ProductionList],1}],*)
(*Row[{ProgressIndicator[j,{1,Length[ProductionList]}]," Production mode = ",ProductionList[[j]]," (", j,"/",Length[ProductionList],")"}]]//AbsoluteTiming*)
(*If[icounter>Length[SelectedExperimentList],BlockEvaluation["Sensitivity"]]*)


(* ::Title::Closed:: *)
(*Computing sensitivities*)


(* ::Chapter::Closed:: *)
(*Basic definitions*)


(* ::Input:: *)
(*BrhToSSreference=0.15;*)
(*LLPdirName="Scalar";*)
(*directory["Sensitivity"]=FileNameJoin[{NotebookDirectory[],"Sensitivity domains"}];*)
(*directory["Sensitivity-LLP"]=FileNameJoin[{directory["Sensitivity"],LLPdirName}];*)
(*If[!DirectoryQ[directory[#]],CreateDirectory[directory[#]]]&/@{"Sensitivity","Sensitivity-LLP"};*)
(*directory["Nevents-LLP"]=FileNameJoin[{NotebookDirectory[],"Tabulated Nevents",LLPdirName}];*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*selectionDialog[list_,phrase_]:=DialogInput[{choice={}},Column[{Row[{phrase}],Pane[TogglerBar[Dynamic[choice],list,Appearance->"Vertical"->{Automatic,5}],ImageSize->{Automatic,Automatic},Scrollbars->{False,True}],Button["OK",DialogReturn[choice]]}]]*)
(*ExperimentDirectoriesListNevents=Select[FileNames["*",directory["Nevents-LLP"],1],DirectoryQ];*)
(*Print["List of available experiments with tabulated \!\(\*SubscriptBox[\(N\), \(events\)]\) for " <>LLPdirName<>":"]*)
(*ExperimentsListNevents=Table[FileNameTake[ExperimentDirectoriesListNevents[[i]],-1],{i,1,Length[ExperimentDirectoriesListNevents],1}]//Sort;*)
(*ExperimentsListNevents//TableForm*)
(*If[Length[ExperimentsListNevents]==0,Print["No experiment is available, generate first the acceptance for the given experiment using module 1"],*)
(*SelectedExperimentList=If[Length[ExperimentsListNevents]!=0,selectionDialog[ExperimentsListNevents,"Select the experiments for which the sensitivity will be computed:"]];*)
(*icounter=1;*)
(*BlockEvaluation[tag_]:=Block[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,tag,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*];*)
(*Do[*)
(*BlockEvaluation["Sensitivity-computation"];*)
(*,{icounter,1,Length[SelectedExperimentList],1}]*)
(*]*)


(* ::Input:: *)
(**)


(* ::Chapter::Closed:: *)
(*Importing data and interpolations*)


(* ::Section::Closed:: *)
(*Selecting experiment*)


(* ::Input:: *)
(*Print["Selected experiment:"]*)
(*GivenExperimentForSensitivityComputation=SelectedExperimentList[[icounter++]]*)
(*CondANUBIS=MemberQ[{"ANUBIS-shaft-volume-1","ANUBIS-shaft-volume-2","ANUBIS-shaft-volume-3"},GivenExperimentForSensitivityComputation];*)
(*If[CondANUBIS==True,infoDialog[Row[{"One of the modules of ANUBIS-shaft is chosen. The full sensitivity includes three modules. The importing will be over all modules, so for all ot the the sensitivity has to be computed"}]]]*)
(*If[CondANUBIS==False,GivenExperimentForSensitivityComputationList={GivenExperimentForSensitivityComputation},GivenExperimentForSensitivityComputationList={"ANUBIS-shaft-volume-1","ANUBIS-shaft-volume-2","ANUBIS-shaft-volume-3"}];*)
(*PathsNeventsSelected={};*)
(*Do[PathsNeventsSelected=Join[PathsNeventsSelected,FileNames["*.dat",FileNameJoin[{directory["Nevents-LLP"],exp}]]],{exp,GivenExperimentForSensitivityComputationList}];*)
(*(*Filenames=Table[{StringReplace[Last@FileNameSplit@files[[i]],{"e+0"\[RuleDelayed]"*^","e-0"\[RuleDelayed]"*^-"}]},{i,1,Length[files],1}];*)*)
(*(*Creating the directory for exporting sensitivity curves*)*)
(*ExperimentFolder=If[CondANUBIS==True,"ANUBIS",GivenExperimentForSensitivityComputation];*)
(*directory["Sensitivity-LLP-exp"]=FileNameJoin[{directory["Sensitivity-LLP"],ExperimentFolder}];*)
(*If[!DirectoryQ[directory["Sensitivity-LLP-exp"]],CreateDirectory[directory["Sensitivity-LLP-exp"]]]*)
(**)


(* ::Section::Closed:: *)
(*Importing and interpolations*)


(* ::Input:: *)
(*Print["List of production channels:"]*)
(*FilenamesNevents=Table[Last@FileNameSplit@PathsNeventsSelected[[i]],{i,1,Length[PathsNeventsSelected],1}];*)
(*FilenameParameters[i_]:=StringCases[FilenamesNevents[[i]],"Nevents_Scalar_"~~mother__~~"_at_"~~experiment__~~"_Npot="~~Npot__~~".dat":>{mother,experiment,Npot}][[1]]*)
(*(*______________________________________________________*)*)
(*(*Importing and interpolation*)*)
(*(*______________________________________________________*)*)
(*ProductionInfoList=Table[FilenameParameters[i],{i,1,Length[FilenamesNevents],1}];*)
(*Join[{{"Mother","Experiment","\!\(\*SubscriptBox[\(N\), \(PoT\)]\)"}},ProductionInfoList]//TableForm*)
(*ProductionChannelsList=ProductionInfoList[[All,1]];*)
(*NpotDefault=Interpreter["Number"][ProductionInfoList[[1]][[3]]];*)
(*NeventsTabulated//Clear;*)
(*\[Epsilon]reco[mLLP_]=If[StringContainsQ[GivenExperimentForSensitivityComputation,"LHCb-downstream"]==True,0.4,If[StringContainsQ[GivenExperimentForSensitivityComputation,"CHARM-lepton"]==True,If[mLLP<0.105*2,0.51,0.85],1]];*)
(*Do[*)
(*Module[{prod},*)
(*prod=ProductionChannelsList[[i]];*)
(*(*The condition if one sums the number of events for the same production mode over several experiments*)*)
(*IfprodExists=MemberQ[Keys[DownValues@NeventsTabulated][[All,1,1]],prod];*)
(*NeventsTabulated[prod]=If[!IfprodExists,Import[PathsNeventsSelected[[i]],"Table"],Join[NeventsTabulated[prod][[All,{1,2}]],NeventsTabulated[prod][[All,{3}]]+Import[PathsNeventsSelected[[i]],"Table"][[All,{3}]]]];*)
(*{mminmax[prod],couplingminmax[prod]}=(NeventsTabulated[prod][[All,#]]//MinMax)&/@{1,2};*)
(*NevMax[prod]=NeventsTabulated[prod][[All,3]]//Max;*)
(*NevInt[mLLP_,\[Theta]2_,BrhToSS_,prod]=If[StringContainsQ[prod,"quartic"],BrhToSS/BrhToSSreference,1]*\[Epsilon]reco[mLLP]*If[mminmax[prod][[1]]<= mLLP<=mminmax[prod][[2]]&&couplingminmax[prod][[1]]<=\[Theta]2<=couplingminmax[prod][[2]],Evaluate[10^(Interpolation[{Log10[#[[1]]],Log10[#[[2]]],Log10[#[[3]]+10^-90]}&/@NeventsTabulated[prod],InterpolationOrder->1][Log10[mLLP],Log10[\[Theta]2]])],0];*)
(*]*)
(*,{i,1,Length[ProductionInfoList],1}]*)
(*{mminmaxOverall,couplingminmaxOverall}=MinMax[Table[#[prod],{prod,ProductionChannelsList}]//Flatten]&/@{mminmax,couplingminmax};*)
(*NevMaxOverall=Max[NeventsTabulated[#][[All,3]]&/@ProductionChannelsList]*)


(* ::Subsection::Closed:: *)
(*Accounting for various bremsstrahlung descriptions*)


(* ::Input:: *)
(*Print["List of various bremsstrahlung channels:"]*)
(*BremChannelsList=Select[ProductionChannelsList,StringContainsQ[#,"Bremsstrahlung"]&]//Sort*)
(*(*Defining the baseline bremsstrahlung setup*)*)
(*BremChannelBaseline="Bremsstrahlung-AP-Central-mixing";*)
(*If[BremChannelsList=={},*)
(*ProductionChannelsListUnified=ProductionChannelsBaseline=ProductionChannelsList;*)
(*,*)
(*If[MemberQ[BremChannelsList,BremChannelBaseline],*)
(*ProductionChannelsBaseline=Join[Select[ProductionChannelsList,!StringContainsQ[#,"Bremsstrahlung"]&],{BremChannelBaseline}];*)
(*,*)
(*ProductionChannelsBaseline=Join[Select[ProductionChannelsList,!StringContainsQ[#,"Bremsstrahlung"]&],{BremChannelsList[[1]]}]*)
(*];*)
(*ProductionChannelsListUnified=Join[Select[ProductionChannelsList,!StringContainsQ[#,"Bremsstrahlung"]&],{"Bremsstrahlung"}];*)
(*];*)
(*MapThread[(BremNameExportPattern[#1]=#2)&,{("Bremsstrahlung-"<>#<>"-mixing")&/@{"FR-Upper","FR-Central","FR-Lower","BB","AP-Upper","AP-Central","AP-Lower"},{"FR-Upper-mixing","FR-Central-mixing","FR-Lower-mixing","BB-mixing","AP-Upper-mixing","AP-Central-mixing","AP-Lower-mixing"}}];*)
(*NevIntOverall[mLLP_,\[Theta]2_,BrhToSS_]=Sum[NevInt[mLLP,\[Theta]2,BrhToSS,prod],{prod,ProductionChannelsBaseline}];*)
(*pt[mLLP_,BrhToSS_]:=LogLogPlot[Evaluate[Table[NevInt[mLLP,y,BrhToSS,prod],{prod,ProductionChannelsBaseline}]],{y,couplingminmaxOverall[[1]],couplingminmaxOverall[[2]]},PlotLegends->Placed[Style[#,15]&/@ProductionChannelsBaseline,Right],PlotRange->{couplingminmaxOverall,{10^-2,NevMaxOverall}},Frame->True,ImageSize->Large,FrameLabel->{"\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\)" , "\!\(\*SubscriptBox[\(N\), \(events\)]\)[\!\(\*SubscriptBox[\(m\), \(S\)]\),\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\),\!\(\*SubscriptBox[\(Br\), \(h -> SS\)]\)]"},FrameStyle->Directive[Black, 23],PlotStyle->{{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green},{Thick,Black},{Thick,Blue,Dashing[0.02]},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green,Dashing[0.02]},{Thick,Black,Dashing[0.02]}},PlotLabel->Style[Row[{ExperimentFolder,". \!\(\*SubscriptBox[\(m\), \(S\)]\) = ",mLLP, " GeV, \!\(\*SubscriptBox[\(Br\), \(h -> SS\)]\) = ",BrhToSS}],20,Black]]*)
(*pt[0.7,0.01]*)


(* ::Chapter::Closed:: *)
(*Sensitivity computation*)


(* ::Section::Closed:: *)
(*Density plot for number of events*)


(* ::Input:: *)
(*BrhToSSval=0.01;*)
(*(*If the plot is not as smooth as it is desired, increase the value of PlotPoints option*)*)
(*plot=DensityPlot[Evaluate[Log10[NevIntOverall[mLLP,\[Theta]2,BrhToSSval]]],{mLLP,mminmaxOverall[[1]],mminmaxOverall[[2]]},{\[Theta]2,couplingminmaxOverall[[1]],couplingminmaxOverall[[2]]},ScalingFunctions->{"Log","Log"},AspectRatio->0.78,PlotRange->{All,All,{Log10[2.3],Log10[NevMaxOverall]}},ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(m\), \(S\)]\) [GeV]","\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\)"}, Frame-> True, FrameStyle->Directive[Black, 25],PlotPoints->100,PlotLegends->Placed[BarLegend[{Automatic,{Log10[2.3],Log10[NevMaxOverall]}},LegendMarkerSize->340,LegendLabel->Placed["\!\(\*SubscriptBox[\(Log\), \(10\)]\)[\!\(\*SubscriptBox[\(N\), \(ev\)]\)]",Bottom],LabelStyle->{FontSize->22},Method->{FrameStyle->Black,AxesStyle->None,TicksStyle->Black}],Right],PlotLabel->Style[Row[{ExperimentFolder,", Br(h\[Rule]SS) = ",BrhToSSval}],20,Black](*,FrameTicks->{{Automatic,Automatic},{TicksPlotx,None}}*)]*)
(*(*Exporting. "AllowRasterization"->False option reduces the size of the output. Without this option, the file may be very large, depending on the value of PlotPoints*)*)
(*(*Export[FileNameJoin[{NotebookDirectory[],"NeventsDensityPlotExample.pdf"}],plot,"AllowRasterization"->False]*)*)


(* ::Section::Closed:: *)
(*Importing excluded region*)


(* ::Input:: *)
(*importformat["txt"]=importformat["dat"]="Table";*)
(*importformat["m"]=importformat["mx"]="MX";*)
(*importformat["xls"]="XLS";*)
(*dir=FileNameJoin[{NotebookDirectory[],"contours",LLPdirName}];*)
(*If[DirectoryQ[dir],*)
(*filenames=FileNames[LLPdirName<>"-excluded*",dir,Infinity];*)
(*ExcludedRegions[LLPdirName]=Import[#,importformat[FileExtension[#]]]&/@FileNames[LLPdirName<>"-excluded*",dir,Infinity];*)
(*];*)
(*If[!DirectoryQ[dir],*)
(*ExcludedRegions[LLPdirName]={{{10.,10.}}};*)
(*]*)


(* ::Section::Closed:: *)
(*Sensitivity*)


(* ::Subsection::Closed:: *)
(*Sensitivity calculator block*)


(* ::Input:: *)
(*SensitivityExtractor[SelectedProduction_,Npot_,BrhToSSval_,NevMin_]:=Module[{RegSens,SensTemp},*)
(*NevTot[mLLP_,\[Theta]2_]=Sum[NevInt[mLLP,\[Theta]2,BrhToSSval,prod],{prod,SelectedProduction}];*)
(*RegSens=RegionPlot[Npot/NpotDefault NevTot[10^mLLP,10^\[Epsilon]2]>=NevMin,{mLLP,Log10[mminmaxOverall[[1]]],Log10[mminmaxOverall[[2]]]},{\[Epsilon]2,Log10[couplingminmaxOverall[[1]]],Log10[couplingminmaxOverall[[2]]]},PlotPoints->300];*)
(*SensTemp=Cases[Normal@RegSens,Line[x_]:>x,Infinity];*)
(*Table[{10^#[[1]],10^#[[2]]}&/@SensTemp[[i]],{i,1,Length[SensTemp],1}]*)
(*]*)
(*SensitivityExtractorBrem[SelectedProduction_,i_,Npot_,BrhToSSval_,NevMin_]:=Module[{bremch,selprod},*)
(*bremch=BremChannelsList[[i]];*)
(*selprod=Join[Select[SelectedProduction,#!="Bremsstrahlung"&],{bremch}];*)
(*{i,selprod,BremNameExportPattern[bremch],SensitivityExtractor[selprod,Npot,BrhToSSval,NevMin]}*)
(*]*)
(*SensitivityBlock[NevMin_,BrhToSSval_,Npot_,SelectedProduction_]:=Block[{},*)
(*If[!MemberQ[SelectedProduction,"Bremsstrahlung"],*)
(*TabSens={{1,SelectedProduction,"None",SensitivityExtractor[SelectedProduction,Npot,BrhToSSval,NevMin]}};*)
(*,*)
(*TabSens=Table[SensitivityExtractorBrem[SelectedProduction,i,Npot,BrhToSSval,NevMin],{i,1,Length[BremChannelsList],1}];*)
(*];*)
(*filenameexport=FileNameJoin[{directory["Sensitivity-LLP-exp"],ToString@StringForm["Sensitivity_``_at_``_BrhToSS=``_Nev=``_Npot=``.",Sequence@@{LLPdirName,ExperimentFolder,BrhToSSval//ToString,NevMin//ToString,N[Npot]//CForm//ToString}]}];*)
(*assocData=Map[Association["Index"->#[[1]],"Production modes"->#[[2]],"Bremsstrahlung description"->#[[3]],"Sensitivity domains"->#[[4]]]&,TabSens];*)
(*Export[filenameexport<>"mx",TabSens,"MX"];*)
(*Export[filenameexport<>"json",assocData,"JSON"];*)
(*(*TabSens*)*)
(*Import[filenameexport<>"mx","MX"]*)
(*]*)


(* ::Subsection::Closed:: *)
(*Sensitivity setup and plot*)


(* ::Input:: *)
(*productionlist=Join[{"All"},ProductionChannelsListUnified];*)
(*DynamicModule[{input0=0.,input1=NpotDefault,input2=2.3,choice={"All"},list,phrase},*)
(*DialogInput[Column[{Style[ExperimentFolder,Bold],TextCell["Enter Br(h->SS):"],InputField[Dynamic[input0],Expression],TextCell["Enter the number of proton collisions:"],InputField[Dynamic[input1],Expression],TextCell["Enter the value of N_ev,min for which the sensitivity will be computed:"],InputField[Dynamic[input2],Expression],Row[{"Select the production channels to be used for the sensitivity calculation:"}],Pane[TogglerBar[Dynamic[choice],productionlist,Appearance->"Vertical"->{Automatic,1}],ImageSize->{Automatic,Automatic},Scrollbars->{False,True}],Button["Submit",DialogReturn[{BrhToSSval,NpotVal,NevMinVal,SelectedProduction}={input0,input1,input2,choice}//N],ImageSize->Automatic]}]]];*)
(*If[MemberQ[SelectedProduction,"All"],SelectedProduction=ProductionChannelsListUnified;]*)
(*{{"Br(h->SS)","\!\(\*SubscriptBox[\(N\), \(PoT\)]\) for computation","\!\(\*SubscriptBox[\(N\), \(ev, min\)]\)","Selected production modes"},{BrhToSSval,NpotVal,NevMinVal,SelectedProduction}}//TableForm*)
(*sens=SensitivityBlock[NevMinVal,BrhToSSval,NpotVal,SelectedProduction];*)
(*legends=sens[[All,-2]];*)
(*sensregions=sens[[All,-1]];*)
(*ColorsForPlot={{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green},{Thick,Darker@Cyan},{Thick,Magenta},{Thick, Black},{Thick,Lighter@Brown},{Thick,Lighter@Blue},{Thick,Lighter@Red},{Thick,Lighter@Green},{Thick,Blue,Dashing[0.02]},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green,Dashing[0.02]},{Thick,Darker@Cyan,Dashing[0.02]},{Thick,Magenta,Dashing[0.02]},{Thick,Black,Dashing[0.02]},{Thick,Lighter@Brown,Dashing[0.02]},{Thick,Lighter@Blue,Dashing[0.02]},{Thick,Lighter@Red,Dashing[0.02]},{Thick,Lighter@Green,Dashing[0.02]}};*)
(*plotstylelist=Flatten[Table[ConstantArray[ColorsForPlot[[i]],If[MatrixQ[sensregions[[i]]],1,Length@sensregions[[i]]]],{i,1,Length[sensregions],1}],1];*)
(*Show[ListLogLogPlot[Cases[ExcludedRegions[LLPdirName],_?MatrixQ,All],Joined->{True,True,True,True},Frame-> True,FrameLabel->{"\!\(\*SubscriptBox[\(m\), \(S\)]\) [GeV]" , "\!\(\*SuperscriptBox[\(\[Theta]\), \(2\)]\)"},FrameStyle->Directive[Black, 23],PlotStyle->{{Thick,Gray}},Filling->{1->{True,Directive[Gray,Opacity[0.3]]},2->{True,Directive[Gray,Opacity[0.3]]},3->{True,Directive[Gray,Opacity[0.3]]},4->{True,Directive[Gray,Opacity[0.3]]}},ImageSize->Large,PlotRange->{{1.01mminmaxOverall[[1]],1.1mminmaxOverall[[2]]},{0.3Min[Flatten[sensregions]],0.99couplingminmaxOverall[[2]]}},PlotLabel->Style[Row[{GivenExperimentForSensitivityComputation,", \!\(\*SubscriptBox[\(N\), \(events\)]\) \[GreaterEqual] ",NevMinVal,", \!\(\*SubscriptBox[\(Br\), \(h -> SS\)]\) = ",BrhToSSval}],18,Black]],*)
(*ListLogLogPlot[Cases[sensregions,_?MatrixQ,All],Joined->{True,True,True,True},PlotStyle->plotstylelist,ImageSize->Large,PlotRange->{{1.01mminmaxOverall[[1]],1.1mminmaxOverall[[2]]},{couplingminmaxOverall[[1]],Max[0.2,0.99couplingminmaxOverall[[2]]]}}],LogLogPlot[{1,1,1,1,1,1},{x,1,10},PlotStyle->DeleteDuplicates[plotstylelist],ImageSize->Large,PlotRange->{{1.01mminmaxOverall[[1]],1.1mminmaxOverall[[2]]},{couplingminmaxOverall[[1]],Max[0.2,0.99couplingminmaxOverall[[2]]]}},PlotLegends->Placed[Style[#,15]&/@legends,{0.2,0.15}]],Graphics[{Text[Style["Excluded",24,Black],Scaled[{0.7,0.95}]]}]]*)
(*(*Show[ListLogLogPlot[Cases[ExcludedRegions[LLPdirName],_?MatrixQ,All],Joined\[Rule]{True,True,True,True},Frame\[Rule] True,FrameLabel\[Rule]{"Subscript[m, S] [GeV]" , "\[Theta]^2"},FrameStyle\[Rule]Directive[Black, 23],PlotStyle\[Rule]{{Thick,Gray}},Filling\[Rule]{1\[Rule]{True,Directive[Gray,Opacity[0.3]]},2\[Rule]{True,Directive[Gray,Opacity[0.3]]},3\[Rule]{True,Directive[Gray,Opacity[0.3]]},4\[Rule]{True,Directive[Gray,Opacity[0.3]]}},ImageSize\[Rule]Large,PlotRange\[Rule]{{1.01mminmaxOverall[[1]],1.1mminmaxOverall[[2]]},{0.3*Min[Flatten[Sens]],couplingminmaxOverall[[2]]}},PlotLabel\[Rule]Style[Row[{"Subscript[N, events] \[GreaterEqual] ",NevMinVal}],18,Black]],*)
(*ListLogLogPlot[Cases[sens,_?MatrixQ,All],Joined\[Rule]{True,True,True,True},PlotStyle\[Rule]Flatten[{ConstantArray[{Thick,Blue},If[MatrixQ[sens],1,Length@sens]]},1],ImageSize\[Rule]Large,PlotRange\[Rule]{{1.01mminmaxOverall[[1]],1.1mminmaxOverall[[2]]},{0.3*Min[Flatten[Sens]],0.99couplingminmaxOverall[[2]]}},PlotLabel\[Rule]Style[Row[{"Subscript[N, events] \[GreaterEqual] ",NevMinVal}],18,Black],PlotLegends\[Rule]Placed[Style[#,15]&/@{ExperimentFolder},{0.2,0.15}]],Graphics[{Text[Style["Excluded",24,Black],Scaled[{0.7,0.95}]]}]]*)*)


(* ::Title::Closed:: *)
(*Deleting generated cells*)


(* ::Input:: *)
(*FrontEndTokenExecute["DeleteGeneratedCells"];*)
(*FrontEndTokenExecute["SelectAll"];*)
(*FrontEndTokenExecute["SelectionCloseAllGroups"];*)
