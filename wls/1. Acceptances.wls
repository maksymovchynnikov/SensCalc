#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Title::Closed:: *)
(*Just launch the code below to run the notebook (shift+enter)*)


(* ::Input:: *)
(*ClearAll["Global`*"]*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,"Evaluation",All,CellTags];*)
(*SelectionEvaluate[nb]*)


(* ::Title::Closed:: *)
(*Definitions*)


(* ::Chapter::Closed:: *)
(*Critical definitions required to launch this notebook*)


(* ::Input:: *)
(*SetAttributes[ruleDown,HoldAll];*)
(*ruleDown[list_]:=Flatten[DownValues/@(Unevaluated@list)]*)
(*SetAttributes[ruleOwn,HoldAll];*)
(*ruleOwn[list_]:=Flatten[OwnValues/@(Unevaluated@list)]*)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*choicesDialog[LLP_,spec_List]:=DialogInput[{choice=spec[[All,2,1]]},Column[Flatten@{{LLP},Table[With[{i=i},Column[{TextCell[spec[[i,1]]],PopupMenu[Dynamic[choice[[i]]],spec[[i,-1]]]}]],{i,Length@spec}],Button["OK",DialogReturn[choice]]}]]*)
(*selectionDialog[list_,phrase_]:=DialogInput[{choice={}},Column[{Row[{phrase}],Pane[TogglerBar[Dynamic[choice],list,Appearance->"Vertical"->{Automatic,5}],ImageSize->{Automatic,Automatic},Scrollbars->{False,True}],Button["OK",DialogReturn[choice]]}]]*)
(*infoDialog[phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],Button["Proceed",DialogReturn[choice]]}]]*)
(*SetOptions[$FrontEnd,"DynamicEvaluationTimeout"->300]*)
(*SetSystemOptions["SimplificationOptions"->"AutosimplifyTrigs"->False]*)
(*<<FeynCalc`*)


(* ::Chapter::Closed:: *)
(*Properties of SM particles*)


(* ::Input:: *)
(*(*Properties of SM particles*)*)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/SensCalc/SM particles.nb"}]]];*)
(*Print["Full information about decay products:"]*)
(*Join[{{"Product"},{"PDG ID"},{"Stability"},{"Mass"},{"Electric charge"}},{ListSMparticlesSymbols,ParamProductToPDGid[#]&/@ListSMparticlesSymbols//IntegerPart,ParamProductStability[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols),ParamProductMass[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols),ParamProductCharge[#]&/@(ParamProductToPDGid[#]&/@ListSMparticlesSymbols)},2]//TableForm*)
(*Print["List of recognizable decay products:"]*)
(*Keys[DownValues@ParamProductToPDGid][[All,1,1]]*)
(*Print["List of PDG ids that may be detected:"]*)
(*detectablepdgs={1.,-1.,2.,-2.,3.,-3.,4.,-4.,5.,-5.,21.,-21.,22.,11.,-11.,13.,-13.,211.,-211.,130.,321.,-321.,2112.,-2112.,2212.,-2212.}//Sort;*)
(*detectablepdgs//IntegerPart*)


(* ::Chapter::Closed:: *)
(*Importing experiments*)


(* ::Input:: *)
(*(*Geometry of different experiments and cross-sections*)*)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/experiments.nb"}]]]*)
(*Print["List of experiments with implemented geometry:"]*)
(*experimentlist;*)
(*Join[Table[{i},{i,1,Length[experimentlist],1}],{experimentlist}//Transpose,2]//TableForm*)


(* ::Title::Closed:: *)
(*Choosing the experiments*)


(* ::Chapter::Closed:: *)
(*Selecting the experiments*)


(* ::Input:: *)
(*SetDirectory[NotebookDirectory[]];*)
(*(**)
(*Print["Selected experiment:"]*)
(*DynamicModule[{choice=None,options,rows,cols,gridButtons,maxWidth,paneHeight},*)
(*options=experimentlist;*)
(*cols=3;(*Number of columns in the grid*)*)
(*rows=Ceiling[Length[options]/cols];(*Number of rows*)*)
(*gridButtons=Partition[PadRight[options,rows*cols,""],cols];*)
(*(*Estimate the width of the widest button*)*)
(*maxWidth=Max[StringLength/@ToString/@options]*5;(*Adjust multiplier as needed*)*)
(*(*Set the height of the pane*)*)
(*paneHeight=300;(*Adjust this value based on desired height*)GivenExperiment=DialogInput[Column[{TextCell["Choose the experiment:"],Pane[Dynamic@Grid[Table[With[{opt=gridButtons[[i,j]]},Button[opt,choice=opt,Background->If[choice===opt,LightBlue,None],ImageSize->{maxWidth,Automatic} (*Set width to maxWidth*)]],{i,rows},{j,cols}],Spacings->{2,2}],{Automatic,paneHeight},Scrollbars->{False,True}],Button["OK",DialogReturn[choice],ImageSize->Automatic]}]]]*)
(*If[MemberQ[explistanub,GivenExperiment]==True,*)
(*infoDialog["One of the decay volumes of ANUBIS-shaft has been selected. The full sensitivity requires calculating the acceptances for all the three volumes. You need to generate them afterwards"]]*)*)
(*Print["Selected experiments:"]*)
(*SelectedExperimentList=If[Length[experimentlist]!=0,selectionDialog[experimentlist,"Select the experiments:"]]*)
(*icounter=1;*)
(*Do[*)
(*experimentBoundaries[exp]=\[Theta]minmaxBlock[exp]*)
(*,{exp,SelectedExperimentList}]*)


(* ::Chapter::Closed:: *)
(*Importing LLP decay data*)


(* ::Input:: *)
(*Block[{Print=Identity},Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/llp-decays.nb"}]]]]*)
(*Print["List of implemented LLPs:"]*)
(*LLPlist*)


(* ::Chapter::Closed:: *)
(*Launching iterations over selected experiments*)


(* ::Input:: *)
(*BlockEvaluation[tag_]:=Block[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,tag,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*];*)
(*Do[*)
(*BlockEvaluation["Acceptance-computation"];*)
(*,{icounter,1,Length[SelectedExperimentList],1}]*)


(* ::Title::Closed:: *)
(*Given experiment (do not launch it manually)*)


(* ::Chapter::Closed:: *)
(*Setting geometry and cuts parameters*)


(* ::Input:: *)
(*GivenExperiment=SelectedExperimentList[[icounter++]]*)
(*FacilityGivenExperiment=FacilityExperiment[GivenExperiment];*)
(*EmaxGivenExperiment=EmaxFacility[FacilityGivenExperiment];*)
(*ECALoptionGivenExperiment=ECALoptionExperiment[GivenExperiment];*)
(*DipoleMagnetOptionGivenExperiment=DipoleMagnetOptionExperiment[GivenExperiment];*)
(*(*Decay volume as detector: True, False*)*)
(*DecayVolumeAsDetectorGivenExperiment=DecayVolumeAsDetectorExperiment[GivenExperiment];*)
(*(*Default list of detectable decay products at the given experiment*)*)
(*DetectablePDGsGivenExperiment=DetectablePDGsExperiment[GivenExperiment]//Sort;*)
(*(*___________________________________________________________*)*)
(*(*Box, Cylinder, Annular cylinder*)*)
(*GeometryGivenExperiment=GeometryExperiment[GivenExperiment];*)
(*(*Beam, Transverse*)*)
(*DetectorPlaneOrientationGivenExperiment=DetectorPlaneOrientationExperiment[GivenExperiment];*)
(*(*Decay volume parameters*)*)
(*xToDecayVolumeCenterGivenExperiment[z_]=xToDecayVolumeCenterExperiment[z,GivenExperiment];*)
(*yToDecayVolumeCenterGivenExperiment[z_]=yToDecayVolumeCenterExperiment[z,GivenExperiment];*)
(*dxDecayVolumeGivenExperiment[z_]=dxDecayVolumeExperiment[z,GivenExperiment];*)
(*dyDecayVolumeGivenExperiment[z_]=dyDecayVolumeExperiment[z,GivenExperiment];*)
(*zToDecayVolumeGivenExperiment=zToDecayVolumeExperiment[GivenExperiment];*)
(*dzFidGivenExperiment=dzDecayVolumeExperiment[GivenExperiment];*)
(*zMaxDecayVolumeGivenExperiment=zMaxDecayVolumeExperiment[GivenExperiment];*)
(*xLongMaxDetectorGivenExperiment=xLongMaxDetectorExperiment[GivenExperiment];*)
(*dxDecayVolumeGivenExperimentMax=dxDecayVolumeGivenExperiment[zMaxDecayVolumeGivenExperiment];*)
(*dyDecayVolumeGivenExperimentMax=dyDecayVolumeGivenExperiment[zMaxDecayVolumeGivenExperiment];*)
(*RinnerDecayVolumeGivenExperiment[z_]=RinnerDecayVolumeExperiment[GivenExperiment,z];*)
(*RouterDecayVolumeGivenExperiment[z_]=RouterDecayVolumeExperiment[GivenExperiment,z];*)
(*DecayVolumeGeometryGivenExperiment=DecayVolumeGeometry[GivenExperiment];*)
(*(*Detector parameters*)*)
(*dxDetectorGivenExperiment[z_]=dxDetectorExperiment[GivenExperiment,z];*)
(*dyDetectorGivenExperiment[z_]=dyDetectorExperiment[GivenExperiment,z];*)
(*dzDetectorGivenExperiment=dzDetectorExperiment[GivenExperiment];*)
(*dx2PerpDetectorGivenExperiment[z_]=If[DetectorPlaneOrientationGivenExperiment=="Transverse",dyDetectorGivenExperiment[z],dzDetectorGivenExperiment];*)
(*{xToDetectorCenterGivenExperiment,yToDetectorCenterGivenExperiment,zToDetectorCenterGivenExperiment}=(Symbol[#<>"ToDetectorCenterExperiment"][GivenExperiment]//N)&/@{"x","y","z"};*)
(*x2PerpToDetectorCenterGivenExperiment=If[DetectorPlaneOrientationGivenExperiment=="Transverse",yToDetectorCenterGivenExperiment,zToDetectorCenterGivenExperiment];*)
(*{RinnerDetectorGivenExperiment[z_],RouterDetectorGivenExperiment[z_]}={RinnerDetectorExperiment[GivenExperiment,z],RouterDetectorExperiment[GivenExperiment,z]};*)
(*(*____________________________________________________*)*)
(*(*Given experiment boundaries*)*)
(*(*____________________________________________________*)*)
(*GivenExperimentBoundaries=experimentBoundaries[GivenExperiment];*)
(*(*Min/max polar angles of the decay volume and detector, and the corresponding points*)*)
(*{ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax}={GivenExperimentBoundaries[[1]][[2]][[1]],GivenExperimentBoundaries[[1]][[2]][[2]]}//N;*)
(*{R\[Theta]minDecayVolume,R\[Theta]maxDecayVolume}={GivenExperimentBoundaries[[1]][[1]][[1]],GivenExperimentBoundaries[[1]][[1]][[2]]};*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",*)
(*{ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}={GivenExperimentBoundaries[[2]][[2]][[1]],GivenExperimentBoundaries[[2]][[2]][[2]]}//N;*)
(*{R\[Theta]minEndDetector,R\[Theta]maxEndDetector}={GivenExperimentBoundaries[[2]][[1]][[1]],GivenExperimentBoundaries[[2]][[1]][[2]]}//N;*)
(*DetectorGeometryGivenExperiment=DetectorGeometry[GivenExperiment],*)
(*{ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}={ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax}*)
(*];*)
(*FinalPlaneGivenExperiment=PlaneEndOfDetectorExperiment[GivenExperiment];*)
(*(*Parameters of the dipole magnet in the spectrometer (if present)*)*)
(*zMagnetMinGivenExperiment=zMagnetMinExperiment[GivenExperiment];*)
(*zMagnetMaxGivenExperiment=zMagnetMaxExperiment[GivenExperiment];*)
(*Bval=If[DipoleMagnetOptionGivenExperiment=="False",0,MagneticFieldExperiment[GivenExperiment]];*)
(*(*ECAL position*)*)
(*ECALpositionGivenExperiment=zECALminExperiment[GivenExperiment];*)
(*(*FinalPlaneGivenExperiment=If[finalPlaneGivenExperiment\[Equal]"EndOfDetector",EndOfDetectorGivenExperiment,PlaneDetectorGivenExperiment];*)*)
(*TableParticlesNumbersGivenExperiment=TableNumbersParticlesExperiment[GivenExperiment];*)
(*xLongMuonPlaneGivenExperiment=xLongMuonPlaneExperiment[GivenExperiment];*)
(*xLongNonMuonPlaneGivenExperiment=xLongNonMuonPlaneExperiment[GivenExperiment];*)
(*(*Geometric conditions*)*)
(*IfLLPinsideDecVol[zLLP_,xLLP_,yLLP_]=IfLLPinsideDecVol[zLLP,xLLP,yLLP,GivenExperiment];*)
(*{IfLLPtoDet[x1LLPproj_,x2LLPproj_,xLongProj_],IfLLPnotToDet[x1LLPproj_,x2LLPproj_,xLongProj_]}={IfLLPtoDet[x1LLPproj,x2LLPproj,xLongProj,GivenExperiment],IfLLPnotToDet[x1LLPproj,x2LLPproj,xLongProj,GivenExperiment]};*)
(*IfLLPdecVolToDet[zLLP_,xLLP_,yLLP_,x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPdecVolToDet[zLLP,xLLP,yLLP,x1LLPproj,x2LLPproj,xLongProj,GivenExperiment];*)
(*IfLLPdecVolNotToDet[zLLP_,xLLP_,yLLP_,x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPdecVolNotToDet[zLLP,xLLP,yLLP,x1LLPproj,x2LLPproj,xLongProj,GivenExperiment];*)
(*DecayAcceptanceGeometry[x1LLPproj_,x2LLPproj_,xLongProj_]=IfLLPtoDet[x1LLPproj,x2LLPproj,xLongProj];*)


(* ::Chapter::Closed:: *)
(*Specifying cuts on the decay products*)


(* ::Input:: *)
(*dropdownDialog[list_,phrase_]:=DialogInput[{choice=""},Column[{TextCell[phrase],PopupMenu[Dynamic[choice],list],Button["OK",DialogReturn[choice]]}]]*)
(*(*filenameGivenExperiment=filenameExperiment[finalPlaneGivenExperiment,GivenExperiment];*)
(*filenameGivenExperimentzN=filenameExperimentzN[finalPlaneGivenExperiment,GivenExperiment]*)*)
(*{{"Experiment","Facility","Decay volume as detector","If ECAL is present","If dipole magnet is present","\!\(\*SubscriptBox[\(E\), \(LLP, max\)]\)"},{GivenExperiment,FacilityGivenExperiment,DecayVolumeAsDetectorGivenExperiment,ECALoptionGivenExperiment,DipoleMagnetOptionGivenExperiment,EmaxGivenExperiment}}//TableForm*)
(*(*WhetherCutsTemp=dropdownDialog[{"Yes","No"},"Would you like to impose any cuts on acceptance of decay products other than geometric?"];*)
(*WhetherCuts=If[WhetherCutsTemp\[Equal]"Yes",1,0];*)*)
(*(*____________________________________________________*)*)
(*(*Imposing cuts on decay products*)*)
(*(*____________________________________________________*)*)
(*pTcutLowerZero=0.;*)
(*pTcutUpperZero=10^10.;*)
(*eCutLowerZero=0.;*)
(*eCutUpperZero=10^10.;*)
(*IPcutZero=10^10.;*)
(*AngSepCutZero=0.;*)
(*SScutZero=0.;*)
(*minvCutLowerZero=0.;*)
(*minvCutUpperZero=10^10.;*)
(*eTotCutLowerZero=0.;*)
(*eTotCutUpperZero=10^10.;*)
(*{pTelCutLower,pTelCutUpper,pT\[Mu]CutLower,pT\[Mu]CutUpper,pThadrCutLower,pThadrCutUpper,eElCutLower,eElCutUpper,e\[Mu]CutLower,e\[Mu]CutUpper,eHadrCutLower,eHadrCutUpper,EtotElCutLower,EtotElCutUpper,Etot\[Mu]CutLower,Etot\[Mu]CutUpper,EtotHadrCutLower,EtotHadrCutUpper,EtotMixedCutLower,EtotMixedCutUpper,e\[Gamma]CutLower,e\[Gamma]CutUpper,eh0CutLower,eh0CutUpper,Etot\[Gamma]\[Gamma]CutLower,Etot\[Gamma]\[Gamma]CutUpper,Etoth0h0CutLower,Etoth0h0CutUpper,EtotMixedNeutralCutLower,EtotMixedNeutralCutUpper,IPcut,AngSepCut,AngSepCutCharged,SScutCharged,SScutNeutral,minvElCutLower,minvElCutUpper,minv\[Mu]CutLower,minv\[Mu]CutUpper,minvHadrCutLower,minvHadrCutUpper,minvMixedCutLower,minvMixedCutUpper,minv\[Gamma]\[Gamma]CutLower,minv\[Gamma]\[Gamma]CutUpper,minvh0h0CutLower,minvh0h0CutUpper,minvMixedNeutralCutLower,minvMixedNeutralCutUpper}//Clear;*)
(*choice={"All"};*)
(*DynamicModule[{inputValues,labels,symbols,inputFields,submitButton},*)
(*labels={"Min/max \!\(\*SubscriptBox[\(p\), \(T\)]\) range of each charged decay product, in the form {\!\(\*SubscriptBox[\(p\), \(T, min\)]\), \!\(\*SubscriptBox[\(p\), \(T, max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\(\(/\)\(-\)\)\)]\), (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\(\(/\)\(-\)\)\)]\) (2nd), hadrons \!\(\*SuperscriptBox[\(h\), \(+\(\(/\)\(-\)\)\)]\) (3rd)","Min/max energy of each charged decay product, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\(\(/\)\(-\)\)\)]\) (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\(\(/\)\(-\)\)\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\(\(/\)\(-\)\)\)]\) (3rd)","Min/max total energy of two charged products, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\)]\)\!\(\*SuperscriptBox[\(e\), \(-\)]\) (1st bracket), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\)]\)\!\(\*SuperscriptBox[\(h\), \(-\)]\) (3rd), and mixed (4th)","Min/max energy of each neutral product, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \[Gamma] (1st bracket) and neutral hadrons \!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd)","Min/max total energy of a neutral pair, in the form {\!\(\*SubscriptBox[\(E\), \(min\)]\), \!\(\*SubscriptBox[\(E\), \(max\)]\)}, for \[Gamma]\[Gamma] (1st), \!\(\*SuperscriptBox[\(h\), \(0\)]\)\!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd), mixed (3rd)","Transerse impact parameter cut from above for charged tracks (in m)","Angular cut from below for photons/charged particles at the beginning of the calorimeter (in radians)",*)
(*"Transverse spatial separation cut from below at the beginning of the calorimeter (in m), {\!\(\*SubscriptBox[\(SS\), \(min, charged\)]\),\!\(\*SubscriptBox[\(SS\), \(min, photons\)]\)}","Invariant mass cut for the two charged products, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, for \!\(\*SuperscriptBox[\(e\), \(+\)]\)\!\(\*SuperscriptBox[\(e\), \(-\)]\) (1st), \!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\) (2nd), \!\(\*SuperscriptBox[\(h\), \(+\)]\)\!\(\*SuperscriptBox[\(h\), \(-\)]\) (3rd), mixed (4th)","Invariant mass cut for the two neutral products, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, in the form {\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\), \!\(\*SubscriptBox[\(m\), \(inv, upper\)]\)}, for \[Gamma]\[Gamma] (1st), \!\(\*SuperscriptBox[\(h\), \(0\)]\)\!\(\*SuperscriptBox[\(h\), \(0\)]\) (2nd), mixed (3rd)"};*)
(*inputValues=zeros={{{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}},-999,{-999,-999},{-999,-999},{{-999,-999},{-999,-999},{-999,-999},{-999,-999}},{{-999,-999},{-999,-999},{-999,-999}}}; *)
(*symbols={{{pTelCutLower,pTelCutUpper},{pT\[Mu]CutLower,pT\[Mu]CutUpper},{pThadrCutLower,pThadrCutUpper}},{{eElCutLower,eElCutUpper},{e\[Mu]CutLower,e\[Mu]CutUpper},{eHadrCutLower,eHadrCutUpper}},{{EtotElCutLower,EtotElCutUpper},{Etot\[Mu]CutLower,Etot\[Mu]CutUpper},{EtotHadrCutLower,EtotHadrCutUpper},{EtotMixedCutLower,EtotMixedCutUpper}},{{e\[Gamma]CutLower,e\[Gamma]CutUpper},{eh0CutLower,eh0CutUpper}},{{Etot\[Gamma]\[Gamma]CutLower,Etot\[Gamma]\[Gamma]CutUpper},{Etoth0h0CutLower,Etoth0h0CutUpper},{EtotMixedNeutralCutLower,EtotMixedNeutralCutUpper}},IPcut,{AngSepCut,AngSepCutCharged},{SScutCharged,SScutNeutral},{{minvElCutLower,minvElCutUpper},{minv\[Mu]CutLower,minv\[Mu]CutUpper},{minvHadrCutLower,minvHadrCutUpper},{minvMixedCutLower,minvMixedCutUpper}},{{minv\[Gamma]\[Gamma]CutLower,minv\[Gamma]\[Gamma]CutUpper},{minvh0h0CutLower,minvh0h0CutUpper},{minvMixedNeutralCutLower,minvMixedNeutralCutUpper}}};*)
(*zerosvalues={{{pTcutLowerZero,pTcutUpperZero},{pTcutLowerZero,pTcutUpperZero},{pTcutLowerZero,pTcutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},{{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero},{eCutLowerZero,eCutUpperZero}},IPcutZero,{AngSepCutZero,AngSepCutZero},{SScutZero,SScutZero},{{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero}},{{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero},{minvCutLowerZero,minvCutUpperZero}}};*)
(*If[Length[inputValues]!=Length[labels]!=Length[symbols],MessageDialog["Error: The number of initial values does not match the number of labels."];*)
(*Abort[]];*)
(*productionSelector=Column[{Style["Select the particles that are detectable at " <>GivenExperiment<>":",Bold],TogglerBar[Dynamic[choice],Join[{"All"},ParamPDGidToProduct[#]&/@(Abs[DetectablePDGsGivenExperiment]//DeleteDuplicates)],Appearance->"Horizontal"->{5,20}]}];*)
(*inputFields=Table[With[{i=i},Column[{labels[[i]]<>":",InputField[Dynamic[inputValues[[i]]],Expression,FieldSize->{40,Automatic}]}]],{i,Length[labels]}];*)
(*introphr={Style["Impose the cuts on decay products. If the given cut should not be imposed enter -999 for each value (default choice). All the energy/\!\(\*SubscriptBox[\(p\), \(T\)]\) cuts are in GeV",Bold]};*)
(*submitButton=Button["Submit",Evaluate[Sequence@@Flatten[MapThread[Set,{Flatten[symbols],MapThread[If[#1===#2,#3,#1]&,{Flatten[inputValues],Flatten[zeros],Flatten[zerosvalues]}]}]]]; DialogReturn[Null],ImageSize->Automatic];*)
(*(*submitButton=Button["Submit",Evaluate[Sequence@@Flatten[MapThread[Set,{Flatten[symbols,1],Flatten[inputValues,1]}]]]; DialogReturn[Null],ImageSize->Automatic];*)*)
(*DialogInput[Column[Flatten[{productionSelector,introphr," ",inputFields,submitButton}]]]*)
(*];*)
(*If[choice=={}||MemberQ[choice,"All"],choice={"All"}];*)
(*If[choice!={"All"},*)
(*DetectablePDGsGivenExperimentTemp=Join[ParamProductToPDGid[#]&/@choice,-ParamProductToPDGid[#]&/@choice];*)
(*DetectablePDGsGivenExperiment=Select[DetectablePDGsGivenExperimentTemp,FreeQ[ParamPDGidToProduct[#],Missing]&]//N//Sort;*)
(*];*)
(*Print["List of PDGs of detectable particles:"]*)
(*DetectablePDGsGivenExperiment*)


(* ::Section::Closed:: *)
(*Displaying cuts*)


(* ::Subsection::Closed:: *)
(*Creating functions with cuts*)


(* ::Input:: *)
(*createCompiledFunctionpT[zeroValue_,elcut_,\[Mu]cut_,hadrcut_]:=Hold@Compile[{{id,_Real},{charge,_Real}},Module[{cut,absid},*)
(*cut=zeroValue;*)
(*absid=Abs[id];*)
(*If[charge!=0.,*)
(*cut=If[absid==11.,elcut,If[absid==13.,\[Mu]cut,hadrcut]];*)
(*];*)
(*cut*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]//ReleaseHold*)
(*pTcutLowerID=createCompiledFunctionpT[pTcutLowerZero,pTelCutLower,pT\[Mu]CutLower,pThadrCutLower];//AbsoluteTiming*)
(*pTcutUpperID=createCompiledFunctionpT[pTcutUpperZero,pTelCutUpper,pT\[Mu]CutUpper,pThadrCutUpper];//AbsoluteTiming*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@pTcutLowerID;*)
(*createCompiledFunctionE[zeroValue_,\[Gamma]cut_,h0cut_,elcut_,\[Mu]cut_,hadrcut_]:=Hold@Compile[{{id,_Real},{charge,_Real}},Module[{cut,absid},*)
(*cut=zeroValue;*)
(*absid=Abs[id];*)
(*If[charge==0.,*)
(*cut=If[absid==22.,\[Gamma]cut,h0cut];*)
(*];*)
(*If[charge!=0.,*)
(*cut=If[absid==11.,elcut,If[absid==13.,\[Mu]cut,hadrcut]];*)
(*];*)
(*cut*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]//ReleaseHold*)
(*ecutLowerID=createCompiledFunctionE[eCutLowerZero,e\[Gamma]CutLower,eh0CutLower,eElCutLower,e\[Mu]CutLower,eHadrCutLower];//AbsoluteTiming*)
(*ecutUpperID=createCompiledFunctionE[eCutUpperZero,e\[Gamma]CutUpper,eh0CutUpper,eElCutUpper,e\[Mu]CutUpper,eHadrCutUpper];//AbsoluteTiming*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@ecutLowerID;*)
(*createCompiledFunction[zeroValue_,h0h0Cut_,gammaGammaCut_,mixedNeutralCut_,hadrCut_,muCut_,elCut_,mixedCut_]:=Hold@Compile[{{id1,_Real},{charge1,_Real},{id2,_Real}},Module[{cut,absid1,absid2,condel1,condel2,condMu1,condMu2},cut=zeroValue;*)
(*absid1=Abs[id1];*)
(*absid2=Abs[id2];*)
(*If[charge1==0.,*)
(*cut=If[id2!=id1,mixedNeutralCut,If[id1==22.,gammaGammaCut,h0h0Cut]];*)
(*];*)
(*If[charge1!=0.,*)
(*{condel1,condel2}={If[absid1==11.,1.,0.],If[absid2==11.,1.,0.]};*)
(*{condMu1,condMu2}={If[absid1==13.,1.,0.],If[absid2==13.,1.,0.]};*)
(*cut=If[condel1+condel2+condMu1+condMu2==0.,hadrCut,If[Max[condel1*condel2,condMu1*condMu2]==0.,mixedCut,If[condel1*condel2==1.,elCut,muCut]]];*)
(*];*)
(*cut],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True](*/. ruleOwn[{zeroValue,h0h0Cut,gammaGammaCut,mixedNeutralCut,hadrCut,muCut,elCut,mixedCut}]*)//ReleaseHold;*)
(*EtotCutLowerID=createCompiledFunction[eTotCutLowerZero,Etoth0h0CutLower,Etot\[Gamma]\[Gamma]CutLower,EtotMixedNeutralCutLower,EtotHadrCutLower,Etot\[Mu]CutLower,EtotElCutLower,EtotMixedCutLower];//AbsoluteTiming*)
(*EtotCutUpperID=createCompiledFunction[eTotCutUpperZero,Etoth0h0CutUpper,Etot\[Gamma]\[Gamma]CutUpper,EtotMixedNeutralCutUpper,EtotHadrCutUpper,Etot\[Mu]CutUpper,EtotElCutUpper,EtotMixedCutUpper];//AbsoluteTiming*)
(*minvCutLowerID=createCompiledFunction[minvCutLowerZero,minvh0h0CutLower,minv\[Gamma]\[Gamma]CutLower,minvMixedNeutralCutLower,minvHadrCutLower,minv\[Mu]CutLower,minvElCutLower,minvMixedCutLower];//AbsoluteTiming*)
(*minvCutUpperID=createCompiledFunction[minvCutUpperZero,minvh0h0CutUpper,minv\[Gamma]\[Gamma]CutUpper,minvMixedNeutralCutUpper,minvHadrCutUpper,minv\[Mu]CutUpper,minvElCutUpper,minvMixedCutUpper];//AbsoluteTiming*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@EtotCutUpperID;*)
(*AngSepCutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1==22.||id1==130.,AngSepCut,AngSepCutCharged],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{AngSepCut,AngSepCutZero,AngSepCutCharged}]//ReleaseHold;//AbsoluteTiming*)
(*SScutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1==22.||id1==130.,SScutNeutral,SScutCharged],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{SScutNeutral,SScutZero,SScutCharged}]//ReleaseHold;//AbsoluteTiming*)
(*IPcutID=Hold@Compile[{{id1,_Real},{id2,_Real}},*)
(*If[id1!=22.&&id1!=2112.&&id1!=130.,IPcut,IPcutZero],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleOwn[{IPcut,IPcutZero}]//ReleaseHold;//AbsoluteTiming*)


(* ::Subsection::Closed:: *)
(*Visualization of the cuts*)


(* ::Input:: *)
(*tabbcuts=SortBy[Select[Flatten[Table[{id1,id2,ParamPDGidToProduct[id1],ParamPDGidToProduct[id2],ParamProductCharge[id1],ParamProductCharge[id2],ecutLowerID[id1//N,ParamProductCharge[id1]//N],ecutUpperID[id1//N,ParamProductCharge[id1]//N],pTcutLowerID[id1//N,ParamProductCharge[id1]],pTcutUpperID[id1//N,ParamProductCharge[id1]//N],EtotCutLowerID[id1//N,ParamProductCharge[id1]//N,id2//N],EtotCutUpperID[id1//N,ParamProductCharge[id1]//N,id2//N],IPcutID[id1//N,id2//N],AngSepCutID[id1//N,id2//N],SScutID[id1//N,id2//N],minvCutLowerID[id1//N,ParamProductCharge[id1]//N,id2//N],minvCutUpperID[id1//N,ParamProductCharge[id1]//N,id2//N]},{id1,detectablepdgs},{id2,detectablepdgs}],1],#[[5]]+#[[6]]==0&&#[[1]]<=#[[2]]&],{#[[1]],#[[2]]}&];*)
(*cutsmeaning={"\!\(\*SubscriptBox[\(pdg\), \(1\)]\)","\!\(\*SubscriptBox[\(pdg\), \(2\)]\)","\!\(\*SubscriptBox[\(id\), \(1\)]\)","\!\(\*SubscriptBox[\(id\), \(2\)]\)","\!\(\*SubscriptBox[\(Q\), \(prod, 1\)]\)","\!\(\*SubscriptBox[\(Q\), \(prod, 2\)]\)","\!\(\*SubscriptBox[\(E\), \(min, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(E\), \(max, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(p\), \(T, min, 1\)]\) (GeV)","\!\(\*SubscriptBox[\(p\), \(T, max, 1\)]\) (GeV)","\!\(\*FractionBox[SubscriptBox[\(E\), \(min, 1 + 2\)], \(GeV\)]\)","\!\(\*FractionBox[SubscriptBox[\(E\), \(max, 1 + 2\)], \(GeV\)]\)","IP cut (m)","angular separation cut (rad)","Transverse spatial separation cut (m)","\!\(\*SubscriptBox[\(m\), \(inv, min\)]\) (GeV)","\!\(\*SubscriptBox[\(m\), \(inv, max\)]\) (GeV)"};*)
(*Join[{Range[1,Length[cutsmeaning]],cutsmeaning},tabbcuts]//TableForm*)
(*IfEcuts=If[Length[Select[tabbcuts,#[[7]]!=eCutLowerZero||#[[8]]!=eCutUpperZero||#[[11]]!=eTotCutLowerZero||#[[12]]!=eTotCutUpperZero&]]==0,0,1];*)
(*IfEtotLowercuts=If[Length[Select[tabbcuts,#[[11]]!=eTotCutLowerZero&]]==0,0,1];*)
(*IfEtotUppercuts=If[Length[Select[tabbcuts,#[[12]]!=eTotCutUpperZero&]]==0,0,1];*)
(*IfpTcuts=If[Length[Select[tabbcuts,#[[9]]!=pTcutLowerZero||#[[10]]!=pTcutUpperZero&]]==0,0,1];*)
(*IfAngSepCuts=If[Length[Select[tabbcuts,#[[14]]!=AngSepCutZero&]]==0,0,1];*)
(*IfSScuts=If[Length[Select[tabbcuts,#[[15]]!=AngSepCutZero&]]==0,0,1];*)
(*IfIPcuts=If[Length[Select[tabbcuts,#[[13]]!=IPcutZero&]]==0,0,1];*)
(*IfminvCuts=If[Length[Select[tabbcuts,#[[16]]!=minvCutLowerZero||#[[17]]!=minvCutUpperZero&]]==0,0,1];*)
(*IfminvLowerCuts=If[Length[Select[tabbcuts,#[[16]]!=minvCutLowerZero&]]==0,0,1];*)
(*IfminvUpperCuts=If[Length[Select[tabbcuts,#[[17]]!=minvCutUpperZero&]]==0,0,1];*)
(*WhetherCuts=If[Total[{IfEcuts,IfEtotLowercuts,IfEtotUppercuts,IfpTcuts,IfAngSepCuts,IfIPcuts,IfminvCuts,IfminvLowerCuts,IfminvUpperCuts}]==0,0.,1.];*)
(*{{"Any E cut","Tot \!\(\*SubscriptBox[\(E\), \(lower\)]\) cut","Tot \!\(\*SubscriptBox[\(E\), \(upper\)]\) cut","\!\(\*SubscriptBox[\(p\), \(T\)]\) cut","Angular cut","SS cut","IP cuts","Any \!\(\*SubscriptBox[\(m\), \(inv\\\  cut\)]\)","\!\(\*SubscriptBox[\(m\), \(inv, lower\)]\) cuts","\!\(\*SubscriptBox[\(m\), \(inv, upper\)]\) cuts"},{IfEcuts,IfEtotLowercuts,IfEtotUppercuts,IfpTcuts,IfAngSepCuts,IfSScuts,IfIPcuts,IfminvCuts,IfminvLowerCuts,IfminvUpperCuts}}//TableForm*)


(* ::Chapter::Closed:: *)
(*Azimuthal acceptance calculation*)


(* ::Section::Closed:: *)
(*Geometry visualization*)


(* ::Input:: *)
(*Print["List of geometric parameters:"]*)
(*If[GeometryGivenExperiment=="Cylinder"||GeometryGivenExperiment=="Annular cylinder",{{"Orientation of the detector cross section wrt beamline","Decay volume geometry type","\!\(\*FractionBox[SubscriptBox[\(l\), \(to\\\  fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid + det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(inner, dec\\\  vol\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(outer, dec\\\  vol\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(inner, det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(R\), \(outer, det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, det\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, det\)], \(rad\)]\)"},{DetectorPlaneOrientationGivenExperiment,GeometryGivenExperiment,zToDecayVolumeGivenExperiment,dzFidGivenExperiment,xLongMaxDetectorGivenExperiment,RinnerDecayVolumeGivenExperiment[z],RouterDecayVolumeGivenExperiment[z],RinnerDetectorGivenExperiment,RouterDetectorGivenExperiment,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}}//TableForm,{{"Orientation of the detector cross section wrt beamline","Decay volume geometry type","\!\(\*FractionBox[SubscriptBox[\(l\), \(to\\\  fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(l\), \(fid + det\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(1\\\  dec . vol . \)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(2\\\  dec . vol . \)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(1 \( \(det\)\(.\)\)\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[CapitalDelta]x\), \(2 \( \(det\)\(.\)\)\)], \(m\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, decay\\\  volume\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(min, det\)], \(rad\)]\)","\!\(\*FractionBox[SubscriptBox[\(\[Theta]\), \(max, det\)], \(rad\)]\)"},{DetectorPlaneOrientationGivenExperiment,GeometryGivenExperiment,zToDecayVolumeGivenExperiment,dzFidGivenExperiment,xLongMaxDetectorGivenExperiment,dxDecayVolumeGivenExperiment[z],dyDecayVolumeGivenExperiment[z],dxDetectorGivenExperimentMax,dyDetectorGivenExperimentMax,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax}}//TableForm]*)
(*Print["Experiment geometry. Black point - collision point. The blue domain - decay volume. The red domain - detector. The green plane - final plane:"]*)
(*(*Block defining relevant plots*)*)
(*ExperimentPlots:=Block[{},*)
(*BoxRatioz=3;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes->True,AxesLabel->{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin->{0,0,0},ViewProjection->"Orthographic",ViewCenter->{0,0,0},ViewPoint->{-0.7,0.25,-2},ViewVertical->{0,1,0},BoxRatios->{1,1,BoxRatioz},AxesStyle->{Thickness[0.03]},LabelStyle->{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment=="False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2],EdgeForm[{Thick,Blue}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]];*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",*)
(*PlotDetector=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3],EdgeForm[{Thick,Red}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotFinalPlane,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]];*)
(*Plot\[Theta]minmaxDecayVolume=Show[PlotOrigin,PlotDecayVolume,Graphics3D[{Thick,Black,Arrowheads[Large],Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]minDecayVolume}],Thick,Darker@Darker@Green,Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]maxDecayVolume}]},ViewPoint->Right]];*)
(*Plot\[Theta]minmaxDetector=If[DecayVolumeAsDetectorGivenExperiment=="False",Show[PlotOrigin,PlotDetector,Graphics3D[{Thick,Black,Arrowheads[Large],Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]minEndDetector}],Thick,Darker@Darker@Green,Arrow[{{0,0,0},{x,y,z}@@@R\[Theta]maxEndDetector}]},ViewPoint->Right]]];*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",{PlotFullGeometry,Plot\[Theta]minmaxDecayVolume,Plot\[Theta]minmaxDetector},{PlotFullGeometry,Plot\[Theta]minmaxDecayVolume}]*)
(*]*)
(*expplots=ExperimentPlots;*)
(*expplots[[1]]*)
(*Print["Plots checking the correctness of evaluation of \!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\), \!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\) of detector and decay volume. The coordinates defining these angles are shown by arrows (black - \!\(\*SubscriptBox[\(\[Theta]\), \(min\)]\), green - \!\(\*SubscriptBox[\(\[Theta]\), \(max\)]\)):"]*)
(*expplots[[2]]*)
(*If[DecayVolumeAsDetectorGivenExperiment=="False",expplots[[3]]]*)


(* ::Input:: *)
(*(*BoxRatioz=5;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment\[Equal]"Annular cylinder",Show[Region[Style[finAnnular,White,Opacity[1](*,EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 1]]*)]],Region[Style[foutAnnular,Blue,Opacity[0.3](*,EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 0.1]]*)]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2](*,EdgeForm[{Thick,Blue}]*)],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",If[GeometryGivenExperiment\[Equal]"Annular cylinder"&&GivenExperiment!="LHCb-downstream-SciFi",Show[Region[Style[finDetAnnular,White,Opacity[1](*,EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 1]]*)]],Region[Style[foutDetAnnular,Red,Opacity[0.2](*,EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 0.1]]*)]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3](*,EdgeForm[{Thick,Red}]*)],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Show[PlotOrigin(*,PlotFinalPlane*),PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]]*)*)


(* ::Input:: *)
(*(*BoxRatioz=3;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,0.75,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}];*)
(*UT=Polygon[{{-1,-1,2.5},{-1,1,2.5},{1,1,2.5},{1,-1,2.5}}];*)
(*PlotUT=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Graphics3D[{Green,Opacity[0.2],UT}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment\[Equal]"Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2]],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",If[GeometryGivenExperiment\[Equal]"Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3]],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Show[PlotOrigin,PlotUT,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]]*)*)


(* ::Subsection::Closed:: *)
(*Adjustable plot*)


(* ::Input:: *)
(*(*BoxRatioz=10;*)
(*PlotOrigin=(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",*)Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1.8,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}](*,Graphics3D[{PointSize[0.05],Black,Point[{0,0,0}]},Axes\[Rule]True,AxesLabel\[Rule]{Style["x",24,Bold,Black],Style["y",24,Bold,Black],Style["z",24,Bold,Black]},AxesOrigin\[Rule]{0,0,0},ViewProjection\[Rule]"Orthographic",ViewCenter\[Rule]{0,0,0},ViewPoint\[Rule]{-0.7,0.25,-2},ViewVertical\[Rule]{0,1,0},BoxRatios\[Rule]{1,1,BoxRatioz},AxesStyle\[Rule]{Thickness[0.03]},LabelStyle\[Rule]{Directive[Black,20]}]]*);*)
(*PlotFinalPlane=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Graphics3D[{Green,Opacity[0.2],FinalPlaneGivenExperiment}]];*)
(*PlotDecayVolume=If[GeometryGivenExperiment\[Equal]"Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.3],EdgeForm[Directive[Thickness[0.01],Blue,Opacity\[Rule] 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.2],EdgeForm[{Thick,Blue}]],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]];*)
(*PlotDetector=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",If[GeometryGivenExperiment\[Equal]"Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.2],EdgeForm[Directive[Thickness[0.01],Red,Opacity\[Rule] 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.3],EdgeForm[{Thick,Red}]],BoxRatios\[Rule]{1,1,BoxRatioz},Boxed\[Rule]True,Axes\[Rule]True]]];*)
(*PlotFullGeometry=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Show[PlotOrigin,PlotDecayVolume,PlotDetector],Show[PlotOrigin,PlotDecayVolume]];*)
(*PlotFullGeometry*)*)


(* ::Section::Closed:: *)
(*Defining \[Theta],E,z grid for the tabulation*)


(* ::Input:: *)
(*(*Grid of energies for which the decay products acceptance will be generated*)*)
(*ELLPvaluesFacility["FermilabBD"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["FermilabBD"]],(Log10[EmaxFacility["FermilabBD"]]-Log10[5.5])/50}]]//N;*)
(*ELLPvaluesFacility["ESS"]=Join[Table[e,{e,0.00501,0.14001,0.001}],{0.141,0.145,0.15,16,0.17,0.18,0.19,0.2,0.23,0.25,0.27,0.3,0.35,0.4,0.45,0.5,0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.,1.1,1.3,1.5,2.,2.4}]//N;*)
(*ELLPvaluesFacility["Serpukhov"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["Serpukhov"]],(Log10[EmaxFacility["Serpukhov"]]-Log10[5.5])/40}]]//N;*)
(*ELLPvaluesFacility["SPS"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[EmaxFacility["SPS"]],(Log10[EmaxFacility["SPS"]]-Log10[5.5])/50}]]//N;*)
(*ELLPvaluesFacility["LHC"]=Join[{0.005,0.01,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[1000],(Log10[1000]-Log10[5.5])/50}],Table[10^ELLP,{ELLP,Log10[1100.],Log10[EmaxFacility["LHC"]],(Log10[EmaxFacility["LHC"]]-Log10[1100.])/30}]]//N;*)
(*ELLPvaluesFacility["FCC-hh"]=Join[{0.005,0.011,0.021,0.05,0.1,0.25,0.5,0.75,1.,1.5,2.,2.5,3.,3.5,4.,4.5,5.},Table[10^ELLP,{ELLP,Log10[5.5],Log10[1000],(Log10[1000]-Log10[5.5])/30}],Table[10^ELLP,{ELLP,Log10[1100.],Log10[10000.],(Log10[10000.]-Log10[1100.])/30}],Table[10^ELLP,{ELLP,Log10[11000.],Log10[EmaxFacility["FCC-hh"]],(Log10[EmaxFacility["FCC-hh"]]-Log10[11000.])/30}]]//N;*)
(*(*Grid of Subscript[\[Theta], LLP],Subscript[z, LLP]*)*)
(*\[Theta]LLPrange=\[Theta]grid[DecayVolumeAsDetectorGivenExperiment,ThetaDecVolGivenExperimentMin,ThetaDecVolGivenExperimentMax,ThetaDetGivenExperimentMin,ThetaDetGivenExperimentMax];*)
(*\[CapitalDelta]zVal[\[CapitalDelta]z_]=Min[\[CapitalDelta]z/10,Max[0.5,\[CapitalDelta]z/45.]];*)
(*zLLPrangeTemp=Table[zLLP,{zLLP,zToDecayVolumeGivenExperiment,zMaxDecayVolumeGivenExperiment,\[CapitalDelta]zVal[zMaxDecayVolumeGivenExperiment-zToDecayVolumeGivenExperiment]}]//N;*)
(*zLLPrange=If[zLLPrangeTemp[[-1]]!=zMaxDecayVolumeGivenExperiment,Join[zLLPrangeTemp,{zMaxDecayVolumeGivenExperiment}],zLLPrangeTemp];*)
(*TableLLPgrid\[Theta]z=Flatten[Table[{\[Theta]LLP,zLLP},{\[Theta]LLP,\[Theta]LLPrange},{zLLP,zLLPrange}],{1,2}];*)
(*(*List of Subscript[E, LLP]*)*)
(*ELLPvalues=ELLPvaluesFacility[FacilityGivenExperiment];*)


(* ::Section::Closed:: *)
(*Azimuthal acceptance calculations*)


(* ::Input:: *)
(*NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/azimuthal-acceptance.nb"}]];*)
(*TableAzimuthalAcceptancesToDet=Table[Block\[Theta]zLLP\[Epsilon]Az\[Phi][EpsilonAzPhiListToDet,j],{j,1,Length[TableLLPgrid\[Theta]z],1}];//AbsoluteTiming*)
(*TableAzimuthalAcceptancesNotToDet=If[DecayVolumeAsDetectorGivenExperiment=="False",Table[Block\[Theta]zLLP\[Epsilon]Az\[Phi][EpsilonAzPhiListNotToDet,j],{j,1,Length[TableLLPgrid\[Theta]z],1}]];//AbsoluteTiming*)
(*TableLLPgridWithELLPtemp[dat_]:=Flatten[Table[{dat[[i]][[1]],ELLPvalues[[k]],dat[[i]][[2]],dat[[i]][[3]],dat[[i]][[4]][[j]]},{i,1,Length[dat],1},{k,1,Length[ELLPvalues],1},{j,1,NofPhiVals,1}],{1,2,3}];//AbsoluteTiming*)
(*(*Grid Subscript[E, LLP], Subscript[\[Theta], LLP], Subscript[x, long,LLP],Subscript[\[Epsilon], azimuthal,LLP],Subscript[\[Phi], LLP] within the decay volume, assuming that LLP points to the end of detector, or not points to the end of detector*)*)
(*gridLLPtoDet=TableLLPgridWithELLPtemp[TableAzimuthalAcceptancesToDet];//AbsoluteTiming*)
(*gridLLPnotToDet=If[DecayVolumeAsDetectorGivenExperiment=="False",TableLLPgridWithELLPtemp[TableAzimuthalAcceptancesNotToDet],gridLLPtoDet];//AbsoluteTiming*)
(*(*The same but without the column Subscript[\[Phi], LLP]*)*)
(*{gridReducedLLPtoDet,gridReducedLLPnotToDet}={DeleteDuplicatesBy[gridLLPtoDet,{#[[1]],#[[2]],#[[3]],#[[4]]}&][[All,{1,2,3,4}]],If[DecayVolumeAsDetectorGivenExperiment=="False",DeleteDuplicatesBy[gridLLPnotToDet,{#[[1]],#[[2]],#[[3]],#[[4]]}&][[All,{1,2,3,4}]]]};*)
(*(*Meaning of columns in the tables gridLLPtoDet,gridLLPnotToDet*)*)
(*index\[Theta]LLP=1;*)
(*indexELLP=2;*)
(*indexzLLP=3;*)
(*indexLLPazAcc=4;*)
(*index\[Phi]LLP=5;*)
(*Print["\[Theta] grid:"]*)
(*thgrid=DeleteDuplicates[gridLLPtoDet[[All,1]]]*)
(*Print["E grid:"]*)
(*egrid=DeleteDuplicates[gridLLPtoDet[[All,2]]]*)
(*Print["z grid:"]*)
(*zgrid=DeleteDuplicates[gridLLPtoDet[[All,3]]]*)
(*azaccdata=Join[gridReducedLLPtoDet[[All,{1,3}]],If[DecayVolumeAsDetectorGivenExperiment=="False",gridReducedLLPtoDet[[All,{4}]]+gridReducedLLPnotToDet[[All,{4}]],gridReducedLLPtoDet[[All,{4}]]],2];*)
(*Print["The volume of the decay volume (in \!\(\*SuperscriptBox[\(m\), \(3\)]\)) calculated by the azimuthal acceptance (compare with the true volume obtained using simple formulas):"]*)
(*azacc[th_,z_]=Interpolation[DeleteDuplicatesBy[azaccdata,{#[[1]],#[[2]]}&],InterpolationOrder->1][th,z];*)
(*{{"Meaning","Volume - computed as \[Integral]2\!\(\*SubscriptBox[\(\[Pi]\[Epsilon]\), \(az\)]\)(\[Theta],z)sin(\[Theta]) \!\(\*SuperscriptBox[\(r\), \(2\)]\)(z)d\[Theta]dr", "Volume - computed internally as Volume[Decay Volume]", "Volume - computed as \[Integral]IfLLPinsideDecVol dx dy dz"},{"Comment","","Must match the 2nd column with O(few %) precision","Must match the 2nd column with O(few %) precision"},{"Value",NIntegrate[2*Pi*azacc[th,z]*Sin[th] z^2/Cos[th]^3,{th,thgrid[[1]],thgrid[[-1]]},{z,zgrid[[1]],zgrid[[-1]]}],Volume[DecayVolumeGeometryGivenExperiment],VolumeFromIf[GivenExperiment]}}//TableForm*)


(* ::Subsubsection::Closed:: *)
(*Visualization of the generated acceptance points*)


(* ::Input:: *)
(*(*_______________________________________________________*)*)
(*(*Visualization of the generated LLP decay points. Uncomment if needed*)*)
(*(*_______________________________________________________*)*)
(*AzimuthalAcceptanceVisualizationChoice="No";*)
(*(*AzimuthalAcceptanceVisualizationChoice=dropdownDialog[{"Yes","No"},"Do you want to visualize the generated grid of the LLP decay points inside the decay volume?"];*)*)
(*If[AzimuthalAcceptanceVisualizationChoice=="Yes",Print["Green points - the decay points of the LLPs pointing to the end of the detector. Cyan points - for the LLPs that do not point to the detector (less dense grid)"]]*)
(*If[AzimuthalAcceptanceVisualizationChoice=="Yes",*)
(*anglestocart=Compile[{{tab,_Real,2}},{#[[3]]/Cos[#[[1]]] Sin[#[[1]]]Cos[#[[5]]],#[[3]]/Cos[#[[1]]] Sin[#[[1]]]Sin[#[[5]]],#[[3]]}&/@tab,CompilationTarget->"C",RuntimeOptions->"Speed"];*)
(*pointstodet=anglestocart[Select[gridLLPtoDet,#[[4]]!=0&]];*)
(*pointsnottodet=If[Length[gridLLPnotToDet]!=0,anglestocart[Select[gridLLPnotToDet,#[[4]]!=0&]]];*)
(*(*The commented code explicitly checks whether the generate point ivall belongs to the decay volume. The result must always be "True"*)*)
(*(*ivall=3;*)
(*RegionMember[DecayVolumeGeometryGivenExperiment,pointstodet[[3]]]*)*)
(*PlotDetector1=If[DecayVolumeAsDetectorGivenExperiment=="False",If[GeometryGivenExperiment=="Annular cylinder"&&StringContainsQ[GivenExperiment,"LHCb-downstream-SciFi"]==True,Show[Region[Style[finDetAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 1]]]],Region[Style[foutDetAnnular,Red,Opacity[0.1],EdgeForm[Directive[Thickness[0.01],Red,Opacity-> 0.1]]]]],Region[Style[DetectorGeometryGivenExperiment,Red,Opacity[0.1],EdgeForm[{Thick,Red}]],BoxRatios->{1,1,BoxRatioz},Boxed->True,Axes->True]]];*)
(*PlotDecayVolume1=If[GeometryGivenExperiment=="Annular cylinder"&&MemberQ[explistlhcb,GivenExperiment]==False,Show[Region[Style[finAnnular,White,Opacity[1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 1]]]],Region[Style[foutAnnular,Blue,Opacity[0.1],EdgeForm[Directive[Thickness[0.01],Blue,Opacity-> 0.1]]]]],Region[Style[DecayVolumeGeometryGivenExperiment,Blue,Opacity[0.1],EdgeForm[{Thick,Blue}]],BoxRatios->{1,0.2,1},Boxed->True,Axes->True]];*)
(*fig=Show[PlotOrigin,PlotDecayVolume1,PlotDetector,ListPointPlot3D[{pointstodet},PlotStyle->{{PointSize[0.005],Darker@Green},{PointSize[0.02],Darker@Green},{Black}},BoxRatios->{1,1,1},Boxed->True,Axes->True],ListPointPlot3D[{pointsnottodet},PlotStyle->{{PointSize[0.005],Cyan},{PointSize[0.03],Darker@Red},{PointSize[0.02],Darker@Green},{Black}}]]*)
(*(*Export[FileNameJoin[{NotebookDirectory[],"temp1/mathusla-points.pdf"}],fig]*)]*)


(* ::Title::Closed:: *)
(*Computing the decay products acceptance (do not launch it manually)*)


(* ::Chapter::Closed:: *)
(*Definitions*)


(* ::Section::Closed:: *)
(*Initializing decay acceptance routines*)


(* ::Input:: *)
(*Quiet[NotebookEvaluate[FileNameJoin[{NotebookDirectory[],"codes/decay-acceptance.nb"}]]];*)


(* ::Section::Closed:: *)
(*Refining possible decay channels*)


(* ::Input:: *)
(*Do[*)
(*ProcessesListRefined[LLP,ECALoptionGivenExperiment]=ProcessesList[LLP,ECALoptionGivenExperiment];*)
(*,{LLP,LLPlist}]*)
(*If[MemberQ[{"CHARM-lepton","CHARM-approx-lepton","BEBC"},GivenExperiment]==True,*)
(*relevantprocesses={{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null"}};*)
(*If[MemberQ[{"BEBC"},GivenExperiment]==True,relevantprocesses=Join[relevantprocesses,{{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(e\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Mu]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[\(\[Nu]\), \(\[Tau]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(e\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Mu]\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\!\(\*SubscriptBox[OverscriptBox[\(\[Nu]\), \(_\)], \(\[Tau]\)]\)","Null","Null"}{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Nu]","Null","Null"},{"\[Gamma]","\[Gamma]","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Pi]\), \(0\)]\)","\[Gamma]","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(e\), \(+\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(-\)]\)","Null","Null"},{"\!\(\*SuperscriptBox[\(e\), \(-\)]\)","\!\(\*SuperscriptBox[\(\[Pi]\), \(+\)]\)","Null","Null"}}]];*)
(*Do[*)
(*ProcessesListRefined[LLP,ECALoptionGivenExperiment]=Select[ProcessesList[LLP,ECALoptionGivenExperiment],MemberQ[Sort/@relevantprocesses,Sort[ListDecayProducts[LLP,#]]]==True&];*)
(*,{LLP,LLPlist}]*)
(*]*)


(* ::Section::Closed:: *)
(*Mass range for the acceptance computation*)


(* ::Input:: *)
(*(*Mass range for scalars. If the facility is not FCC-hh/LHC (where scalars heavier than B may be produced), then the mass range is bounded by Subscript[m, B] - Subscript[m, \[Pi]]. Otherwise, it is up to Subscript[m, h]/2*)*)
(*mLLPlistTemp["Scalar"]=Join[{0.02,0.05,0.1,0.2,0.22,0.3,0.4,0.5,0.7,0.9,1.05,1.3,1.6,1.99},mjetsrange["Scalar"]];*)
(*mLLPlist["Scalar"]=If[MemberQ[{"LHC","FCC-hh"},FacilityGivenExperiment]==False,Select[mLLPlistTemp["Scalar"],#<=5.1&],mLLPlistTemp["Scalar"]];*)
(*(*For HNLs - similarly*)*)
(*Do[*)
(*mLLPlistTemp[LLP]=Join[Select[{0.02,0.05,0.1,0.17,0.35,0.5,0.75,1.,1.19,1.5},#<Min[mjetsrange[LLP]]&],mjetsrange[LLP],{1.75}]//Sort//DeleteDuplicates;*)
(*mLLPlist[LLP]=If[MemberQ[{"LHC","FCC-hh"},FacilityGivenExperiment]==False,Select[mLLPlistTemp[LLP],#<=5.3&],mLLPlistTemp[LLP]];*)
(*,{LLP,{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"}}]*)
(*(*ALPs coupled to gluons*)*)
(*mLLPlistTemp["ALP-gluon"]=Join[Select[{0.02,0.05,0.1,0.25,0.3,0.5,0.75,1.,1.25,1.5,1.8,2.3},#<Min[mjetsrange["ALP-gluon"]]&],mjetsrange["ALP-gluon"]];*)
(*mLLPlist["ALP-gluon"]=If[ECALoptionGivenExperiment=="False",Select[mLLPlistTemp["ALP-gluon"],#>0.14*2&],mLLPlistTemp["ALP-gluon"]];*)
(*(*ALPs coupled to fermions*)*)
(*mLLPlist["ALP-fermion"]=Join[Select[{0.02,0.05,0.1,0.22,0.3,0.5,0.6,0.7,0.8,0.9,1.1,1.5,1.8,2.3},#<Min[mjetsrange["ALP-fermion"]]&],mjetsrange["ALP-fermion"]];*)
(*(*ALPs coupled to photons*)*)
(*mLLPlist["ALP-photon"]={0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.25,0.5,0.75,1.,1.25,1.5,1.75,2.25,2.75,3.,3.5,4.,4.5}//N//Sort;*)
(*mLLPlist["DP"]=Join[Select[{0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.2,0.22,0.35,0.5,0.75,1.,1.25,1.75,2.25},#<Min[mjetsrange["DP"]]&],mjetsrange["DP"]];*)
(*mLLPlist["B-L"]=mLLPlist["B-3Le-Lmu+Ltau"]=mLLPlist["B-Le-3Lmu+Ltau"]=Join[Select[{0.02,0.03,0.04,0.05,0.06,0.07,0.1,0.2,0.22,0.35,0.5,0.75,1.,1.25,1.75,2.25},#<Min[mjetsrange["B-L"]]&],mjetsrange["B-L"]];*)
(*mLLPlist["B-3Lmu"]=Join[{0.215,0.25},Select[mLLPlist["B-L"],#>0.22&]];*)
(*If[FacilityGivenExperiment=="ESS",*)
(*Do[mLLPlist[LLP]=Join[Select[mLLPlist[LLP],#<2.&],{0.01,0.02,0.03,0.04,0.06,0.07,0.08,0.09,0.1,0.105,0.11,0.115,0.12,0.125,0.13,0.135,0.15,0.18,0.2,0.22,0.3,0.35,0.4,0.45,0.55}]//DeleteDuplicates//Sort,{LLP,{"ALP-gluon","ALP-fermion","ALP-photon","DP","B-L","Scalar"}}];*)
(*Do[mLLPlist[LLP]={0.005,0.01,0.015,0.02,0.025,0.03,0.035,0.04,0.045,0.05,0.055,0.06,0.065,0.07,0.075,0.08,0.085,0.09,0.095,0.1,0.103,0.105,0.11,0.115,0.12,0.125,0.13,0.135,0.14},{LLP,{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau"}}];*)
(*]*)


(* ::Section::Closed:: *)
(*Final block*)


(* ::Input:: *)
(*phr0="Use old phenomenology from 1901.09966, or the new one from 2310.03524?";*)
(*a0={"New","Old"};*)
(*phr1[LLP_]:=Row[{"Default decay chanels: ",ProcessesListRefined[LLP,ECALoptionGivenExperiment],". Keep them?"}];*)
(*a1={"Yes","No"};*)
(*phr2="How many decay products that in principle may be detected must pass all the criteria?";*)
(*a2={">=2",">=n","All detectable"};*)
(*phr3="Heavy LLPs decay into partons. Would you like to use the phase space of hadronized decay products of the LLPs, or use partons instead?";*)
(*a3={"Hadronized products","Partons"};*)
(*FinalBlock[LLP_,isim_]:=Block[{},*)
(*masslist=mLLPlist[LLP];*)
(*(*If[LLP=="ALP-fermion",*)
(*alpfermionselection=dropdownDialog[{"New","Old"},Row[{"Use old phenomenology from 1901.09966, or the new one from 2310.03524?"}]];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"],*)
(*LLPchoiceForComputation=LLP;*)
(*];*)*)
(*If[LLP=="ALP-fermion",*)
(*{alpfermionselection}=choicesDialog[Style[LLP,Bold],{{phr0,a0}}];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"];*)
(*If[GivenExperiment!="CHARM-photon",*)
(*{decaychannelschoice,acceptancetypechoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr2,a2},{phr3,a3}}],{decaychannelschoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr3,a3}}]];*)
(*,*)
(*LLPchoiceForComputation=LLP;*)
(*If[GivenExperiment!="CHARM-photon",*)
(*{decaychannelschoice,acceptancetypechoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr2,a2},{phr3,a3}}],*)
(*{decaychannelschoice,HadronizationOptionChoice}=choicesDialog[Style[LLP,Bold],{{phr1[LLPchoiceForComputation],a1},{phr3,a3}}]];*)
(*];*)
(*hadropt=If[HadronizationOptionChoice=="Hadronized products","True","False"];*)
(*If[acceptancetypechoice==">=n",DynamicModule[{input1=2,list,phrase},*)
(*DialogInput[Column[{TextCell["Enter the minimal number of detectable tracks:"],InputField[Dynamic[input1],Expression],Button["Submit",DialogReturn[{ntracksmin}={input1}],ImageSize->Automatic]}]]];];*)
(*(*decaychannelschoice=dropdownDialog[{"Yes","No"},Row[{"Default decay chanels: ",ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],". Keep them?"}]];*)*)
(*(*List of decay processes considered as visible for the given calculation*)*)
(*proclist=If[decaychannelschoice=="No", selectionDialog[ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],"Select decay channels:"],ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment]];*)
(*(*The total branching ratio of the selected visible channels*)*)
(*BrVisibleExport[mLLP_]=BrVisibleGivenSetup[LLPchoiceForComputation,mLLP,proclist,ECALoptionGivenExperiment];*)
(*(*Redefining the mass list such that it matches the domain where the br ratio of selected channels is non-zero*)*)
(*tabbrvis=Table[{mLLP,BrVisibleExport[mLLP]},{mLLP,masslist[[1]],masslist[[-1]],(masslist[[-1]]-masslist[[1]])/100}];*)
(*{mminnonzero,mmaxnonzero}=Select[tabbrvis,#[[2]]>10^-15.&][[All,1]]//MinMax;*)
(*masslist=Join[{mminnonzero},Select[masslist,mminnonzero<#<mmaxnonzero&],{mmaxnonzero}]//N;*)
(*(*Calculation of the decay products acceptance for the selected visible channels*)*)
(*If[Length[proclist]*Length[masslist]!=0,*)
(*(*tabcomp=Monitor[Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice],{l,1,Length[masslist],1}],Row[{ProgressIndicator[l,{1,Length[masslist]}],"i = ",l,"/",Length[masslist]," (Subscript[m, LLP] = ",masslist[[l]]," GeV)"}," "]];*)*)
(*tabcomp=ResourceFunction["MonitorProgress"]@Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice,ntracksmin],{l,1,Length[masslist],1}];*)
(*GivenExperimentNameFin=If[hadropt=="True",GivenExperimentName,GivenExperimentName<>"-no-hadronization"];*)
(*filenameexport=ToString@StringForm["Acceptance_``_for_``.m",Sequence@@{GivenExperimentNameFin,LLP}];*)
(*Flatten[tabcomp,1],*)
(*Print["No processes for the given LLP/ECAL availability!"]]*)
(*]*)
(*BlockExport[LLP_,isim_]:=Block[{},*)
(*datatemp=FinalBlock[LLP,isim];*)
(*Export[FileNameJoin[{NotebookDirectory[],"Acceptances",GivenExperimentNameFin,filenameexport}],{FacilityGivenExperiment,ECALoptionGivenExperiment,datatemp,TableParticlesNumbersGivenExperiment,BrVisibleExport[mLLP]},"MX"]*)
(*]*)


(* ::Subsection::Closed:: *)
(*Silent run*)


(* ::Input:: *)
(*SilentOption=0;*)
(*If[SilentOption!=0,*)
(*alpfermionselection="New";*)
(*acceptancetypechoice=">=n";*)
(*decaychannelschoice="Yes";*)
(*HadronizationOptionChoice="Hadronized products";*)
(*ntracksmin=4;*)
(*FinalBlock[LLP_,isim_]:=Block[{},*)
(*masslist=mLLPlist[LLP];*)
(*(*If[LLP=="ALP-fermion",*)
(*alpfermionselection=dropdownDialog[{"New","Old"},Row[{"Use old phenomenology from 1901.09966, or the new one from 2310.03524?"}]];*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"],*)
(*LLPchoiceForComputation=LLP;*)
(*];*)*)
(*If[LLP=="ALP-fermion",*)
(*LLPchoiceForComputation=If[alpfermionselection=="New","ALP-fermion","ALP-fermion-no-hadronic-decays"];*)
(*,*)
(*LLPchoiceForComputation=LLP;*)
(*];*)
(*hadropt=If[HadronizationOptionChoice=="Hadronized products","True","False"];*)
(*(*decaychannelschoice=dropdownDialog[{"Yes","No"},Row[{"Default decay chanels: ",ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],". Keep them?"}]];*)*)
(*(*List of decay processes considered as visible for the given calculation*)*)
(*proclist=If[decaychannelschoice=="No", selectionDialog[ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment],"Select decay channels:"],ProcessesListRefined[LLPchoiceForComputation,ECALoptionGivenExperiment]];*)
(*(*The total branching ratio of the selected visible channels*)*)
(*BrVisibleExport[mLLP_]=BrVisibleGivenSetup[LLPchoiceForComputation,mLLP,proclist,ECALoptionGivenExperiment];*)
(*(*Redefining the mass list such that it matches the domain where the br ratio of selected channels is non-zero*)*)
(*tabbrvis=Table[{mLLP,BrVisibleExport[mLLP]},{mLLP,masslist[[1]],masslist[[-1]],(masslist[[-1]]-masslist[[1]])/100}];*)
(*{mminnonzero,mmaxnonzero}=Select[tabbrvis,#[[2]]>10^-15.&][[All,1]]//MinMax;*)
(*masslist=Join[{mminnonzero},Select[masslist,mminnonzero<#<mmaxnonzero&],{mmaxnonzero}]//N;*)
(*(*Calculation of the decay products acceptance for the selected visible channels*)*)
(*If[Length[proclist]*Length[masslist]!=0,*)
(*(*tabcomp=Monitor[Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice],{l,1,Length[masslist],1}],Row[{ProgressIndicator[l,{1,Length[masslist]}],"i = ",l,"/",Length[masslist]," (Subscript[m, LLP] = ",masslist[[l]]," GeV)"}," "]];*)*)
(*tabcomp=ResourceFunction["MonitorProgress"]@Table[FinalBlockMass[LLPchoiceForComputation,masslist[[l]],proclist,isim,hadropt,acceptancetypechoice,ntracksmin],{l,1,Length[masslist],1}];*)
(*GivenExperimentNameFin=If[hadropt=="True",GivenExperimentName,GivenExperimentName<>"-no-hadronization"];*)
(*filenameexport=ToString@StringForm["Acceptance_``_for_``.m",Sequence@@{GivenExperimentNameFin,LLP}];*)
(*Flatten[tabcomp,1],*)
(*Print["No processes for the given LLP/ECAL availability!"]]*)
(*];*)
(*BlockExport[LLP_,isim_]:=Block[{},*)
(*datatemp=FinalBlock[LLP,isim];*)
(*Export[FileNameJoin[{NotebookDirectory[],"Acceptances",GivenExperimentNameFin,filenameexport}],{FacilityGivenExperiment,ECALoptionGivenExperiment,datatemp,TableParticlesNumbersGivenExperiment,BrVisibleExport[mLLP]},"MX"]*)
(*]*)
(*]*)


(* ::Input:: *)
(*fdf=FinalBlockMass["DP",0.01,proclist,100,"True",">=2",2];*)


(* ::Input:: *)
(*Select[fdf,#[[3]]>350&][[All,-1]]//Mean*)


(* ::Chapter::Closed:: *)
(*Actual computation of the decay acceptance*)


(* ::Input:: *)
(*BlockAcceptanceComputation[LLP_]:=Module[{},*)
(*nb=EvaluationNotebook[];*)
(*NotebookFind[nb,LLP,All,CellTags];*)
(*SelectionEvaluate[nb]*)
(*]*)
(*Print["List of LLPs:"]*)
(*LLPlistReduced=Join[Select[LLPlist,!MemberQ[{"HNL-mixing-e","HNL-mixing-mu","HNL-mixing-tau","ALP-fermion-no-hadronic-decays"},#]&],{"HNL"}]//Sort*)
(*selectionDialog[list_,phrase_]:=DialogInput[{choice={}},Column[{Row[{phrase}],TogglerBar[Dynamic[choice],list,Appearance->"Vertical"],Button["OK",DialogReturn[choice]]}]]*)
(*Print["List of LLPs for which the acceptance will be computed:"]*)
(*SelectedLLPlistTemp=selectionDialog[Join[LLPlistReduced]//Sort,"Select LLPs for which acceptances will be computed:"]*)
(*SelectedLLPlist=Join[SelectedLLPlistTemp(*,{"Technical"}*)];*)
(*GivenExperimentName=DialogInput[{cut=GivenExperiment},Column[{"Enter the name of the experiment for exporting:",InputField[Dynamic[cut],String],Button["Proceed",DialogReturn[cut],ImageSize->Automatic]}]];*)
(*If[(DirectoryQ["Acceptances"]//ToString)=="False",CreateDirectory["Acceptances"]];*)
(*If[(DirectoryQ[FileNameJoin[{"Acceptances",GivenExperimentName}]]//ToString)=="False",CreateDirectory[FileNameJoin[{"Acceptances",GivenExperimentName}]]];*)
(*(*ChoiceDialog["Choose the LLP for which acceptances will be computed:",Join[LLPlistReduced,{"All"}],Appearance\[Rule]"Vertical"\[Rule]{Automatic,3}]*)*)
(*ivaltest=If[GivenExperiment=="SHiNESS",10^4,1000];*)
(*(*Do[BlockAcceptanceComputation[SelectedLLPlist[[i]]],{i,1,Length[SelectedLLPlist],1}]*)*)


(* ::Title::Closed:: *)
(*Chapter to be automatically launched by the previous chapter. No need to launch it manually*)


(* ::Chapter::Closed:: *)
(*Scalar*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"Scalar"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["Scalar",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*HNL*)


(* ::Section::Closed:: *)
(*e mixing*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"HNL"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["HNL-mixing-e",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Section::Closed:: *)
(*\[Mu] mixing*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"HNL"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["HNL-mixing-mu",10^3];//AbsoluteTiming*)
(*]*)


(* ::Section::Closed:: *)
(*\[Tau] mixing*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"HNL"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["HNL-mixing-tau",10^3];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*Dark photon*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"DP"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["DP",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*ALP-fermion*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"ALP-fermion"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["ALP-fermion",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*ALP-gluon*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"ALP-gluon"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["ALP-gluon",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*ALP-photon*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"ALP-photon"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["ALP-photon",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*B-L mediator*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"B-L"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["B-L",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*B-3Subscript[L, \[Mu]] mediator*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"B-3Lmu"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["B-3Lmu",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*B-3Subscript[L, e]-Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"B-3Le-Lmu+Ltau"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["B-3Le-Lmu+Ltau",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Chapter::Closed:: *)
(*B-Subscript[L, e]-3Subscript[L, \[Mu]]+Subscript[L, \[Tau]] mediator*)


(* ::Input:: *)
(*If[MemberQ[SelectedLLPlist,"B-Le-3Lmu+Ltau"]||MemberQ[SelectedLLPlist,"All"],*)
(*dataS=BlockExport["B-Le-3Lmu+Ltau",ivaltest];//AbsoluteTiming*)
(*]*)


(* ::Title::Closed:: *)
(*Deleting generated cells*)


(* ::Input:: *)
(*FrontEndTokenExecute["DeleteGeneratedCells"];*)
(*FrontEndTokenExecute["SelectAll"];*)
(*FrontEndTokenExecute["SelectionCloseAllGroups"];*)


(* ::Title::Closed:: *)
(*Some tests*)


(* ::Section::Closed:: *)
(*Some tests*)


(* ::Subsection::Closed:: *)
(*SHiNESS*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


(* ::Input:: *)
(*ENdistrFrom\[Mu][mN_,EN_]=(1/(1.*EN - 4.761904761904762*mN^2 - 0.05249999999999999)^3)**)
(*  (Sqrt[(EN^2 - mN^2)*(0.04409999999999999*EN^2 + EN*(-(0.42*mN^2) - 0.004630394999999999) + mN^4 + 0.022049499999999996*mN^2 + 0.00012154511256249997)]**)
(*   (2.2399999999999998*EN^4 + EN^3*(-(37.33333333333331*mN^2) - 0.4115986666666664) + EN^2*(203.17460317460308*mN^4 + 5.599993650793649*mN^2 + 0.024695929998412688) + *)
(*    EN*(-(362.8117913832198*mN^6) - 22.666666666666657*mN^4 - 0.24990133331065745*mN^2 - 0.00048620249974999755) + 25.396825396825378*mN^6 + 0.5600063492063486*mN^4 + 0.0030870699968253965*mN^2 - *)
(*    3.825065264528859*^-20));*)
(*ENmaxFrom\[Mu][mN_]=(0.105^2+mN^2-(0.5*10^-3)^2)/(0.105*2);*)
(*energysampling=Hold@Compile[{{mN,_Real},{nevents,_Integer}},Module[{enrand,weights},*)
(*enrand=RandomReal[{mN,ENmaxFrom\[Mu][mN]},Max[10^6,nevents]];*)
(*weights=ENdistrFrom\[Mu][mN,enrand];*)
(*RandomChoice[weights->enrand,nevents]*)
(*],CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{ENdistrFrom\[Mu],ENmaxFrom\[Mu]}]//ReleaseHold;*)
(*<<CompiledFunctionTools`*)
(*CompilePrint@energysampling;*)
(*EnergySampling[prod_,mN_,Nevents_]:=If[prod=="\[Mu]",energysampling[mN,Nevents],If[prod=="Fake \[Mu]",ConstantArray[(0.105^2+mN^2)/(2*0.105),Nevents],ConstantArray[(0.135^2+mN^2-0.105^2)/(2*0.135),Nevents]]]*)
(*boosting=Hold@Compile[{{energies,_Real},{momenta,_Real,1},{phasespace,_Real,1},{mass,_Real}},Module[{pxm,pym,pzm,pxd1,pyd1,pzd1,ed1,pxd2,pyd2,pzd2,ed2,px1lab,py1lab,pz1lab,e1lab,px2lab,py2lab,pz2lab,e2lab,mass1,mass2},*)
(*pxm=Compile`GetElement[momenta,1];*)
(*pym=Compile`GetElement[momenta,2];*)
(*pzm=Compile`GetElement[momenta,3];*)
(*pxd1=Compile`GetElement[phasespace,indexpx1];*)
(*pyd1=Compile`GetElement[phasespace,indexpy1];*)
(*pzd1=Compile`GetElement[phasespace,indexpz1];*)
(*ed1=Compile`GetElement[phasespace,indexE1];*)
(*mass1=Compile`GetElement[phasespace,indexm1];*)
(*pxd2=Compile`GetElement[phasespace,LengthDataProduct+indexpx1];*)
(*pyd2=Compile`GetElement[phasespace,LengthDataProduct+indexpy1];*)
(*pzd2=Compile`GetElement[phasespace,LengthDataProduct+indexpz1];*)
(*ed2=Compile`GetElement[phasespace,LengthDataProduct+indexE1];*)
(*mass2=Compile`GetElement[phasespace,LengthDataProduct+indexm1];*)
(*px1lab=pproductLab1Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*py1lab=pproductLab2Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*pz1lab=pproductLab3Cart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*e1lab=EproductLabCart[pxm,pym,pzm,energies,mass,pxd1,pyd1,pzd1,ed1];*)
(*px2lab=pproductLab1Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*py2lab=pproductLab2Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*pz2lab=pproductLab3Cart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*e2lab=EproductLabCart[pxm,pym,pzm,energies,mass,pxd2,pyd2,pzd2,ed2];*)
(*{px1lab,py1lab,pz1lab,e1lab,mass1,px2lab,py2lab,pz2lab,e2lab,mass2}*)
(*],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleDown[{pproductLab1Cart,pproductLab2Cart,pproductLab3Cart,EproductLabCart}]/.ruleOwn[{LengthDataProduct,indexpx1,indexpy1,indexpz1,indexE1,indexm1}]//ReleaseHold;*)
(*\[Alpha]Smearing=Hold@Compile[{{daughtermomenta,_Real,1}},Module[{energy1,energy2,mass1,mass2,px1,px2,py1,py2,pz1,pz2,\[Theta]1,\[Theta]2,\[Phi]1,\[Phi]2,\[Theta]smeared1,\[Theta]smeared2,\[Alpha]Kelly,\[Alpha]My,u1,u2,z1,z2,\[Alpha]Unsmeared},*)
(*energy1=Compile`GetElement[daughtermomenta,indexE1];*)
(*energy2=Compile`GetElement[daughtermomenta,indexm1+indexE1];*)
(*mass1=Compile`GetElement[daughtermomenta,indexm1];*)
(*mass2=Compile`GetElement[daughtermomenta,indexm1+indexm1];*)
(*px1=Compile`GetElement[daughtermomenta,indexpx1];*)
(*py1=Compile`GetElement[daughtermomenta,indexpy1];*)
(*pz1=Compile`GetElement[daughtermomenta,indexpz1];*)
(*px2=Compile`GetElement[daughtermomenta,indexm1+indexpx1];*)
(*py2=Compile`GetElement[daughtermomenta,indexm1+indexpy1];*)
(*pz2=Compile`GetElement[daughtermomenta,indexm1+indexpz1];*)
(*\[Theta]1=\[Theta]Val[px1,py1,pz1];*)
(*\[Theta]2=\[Theta]Val[px2,py2,pz2];*)
(*\[Phi]1=\[Phi]Val[px1,py1];*)
(*\[Phi]2=\[Phi]Val[px1,py1];*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z1=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Theta]smeared1=\[Theta]1+Pi/180.*10*z1;*)
(*\[Theta]smeared2=\[Theta]2+Pi/180.*10*z2;*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Alpha]Kelly=ArcCos[Cos[\[Phi]2-\[Phi]1]Sin[\[Theta]smeared1]Sin[\[Theta]smeared2]+Cos[\[Theta]smeared1]*Cos[\[Theta]smeared2]];*)
(*(*\[Alpha]Kelly=ArcCos[Cos[\[Phi]2-\[Phi]1+Pi/180.*10*z2]Sin[\[Theta]smeared1]Sin[\[Theta]smeared2]+Cos[\[Theta]smeared1]*Cos[\[Theta]smeared2]];*)*)
(*u1=RandomReal[{0,1}];*)
(*u2=RandomReal[{0,1}];*)
(*z2=Sqrt[-2. Log[u1]] Cos[2. Pi u2];*)
(*\[Alpha]Unsmeared=ArcCos[Cos[\[Phi]2-\[Phi]1]Sin[\[Theta]1]Sin[\[Theta]2]+Cos[\[Theta]1]*Cos[\[Theta]2]];*)
(*\[Alpha]My=(*Min[Pi,Max[0.,\[Alpha]Unsmeared+Pi/180.*10*z2]]*)ArcCos[Cos[\[Alpha]Unsmeared+Pi/180.*10*z2]];*)
(*{\[Alpha]Unsmeared,\[Alpha]My,\[Alpha]Kelly}*)
(*],CompilationTarget->"C",RuntimeAttributes->{Listable},RuntimeOptions->"Speed",Parallelization->True]/.ruleDown[{\[Theta]Val,\[Phi]Val}]/.ruleOwn[{indexm1,indexE1,indexpx1,indexpy1,indexpz1}]//ReleaseHold;*)
(*selection=Hold@Compile[{{finaldata,_Real,2},{Ecut,_Real},{\[Theta]cut,_Real},{index,_Integer}},Module[{datasel,len},*)
(*datasel=Select[finaldata,#[[indexE1]]>Ecut&&#[[indexE1+indexm1]]>Ecut&&#[[-index]]>\[Theta]cut&];*)
(*Total[datasel[[All,-4]]]/Total[finaldata[[All,-4]]]*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleOwn[{indexE1,indexm1}]//ReleaseHold*)
(*(*\[Theta]\[Phi]Vals=Select[gridLLPtoDet//N//Developer`ToPackedArray,#[[4]]!=0.&][[All,{1,-1}]];*)*)
(*(*\[Theta]\[Phi]Vals={ArcCos[RandomReal[{-1,1},5*10^5]],RandomReal[{-Pi,Pi},5*10^5]}//Transpose;*)*)
(*pts=RandomPoint[DecayVolumeGeometryGivenExperiment,3*10^5];//AbsoluteTiming*)
(*\[Theta]\[Phi]ValsRand=Hold@Compile[{{ptscyl,_Real,1}},Module[{},*)
(*{\[Theta]Val[Compile`GetElement[ptscyl,1],Compile`GetElement[ptscyl,2],Compile`GetElement[ptscyl,3]],\[Phi]Val[Compile`GetElement[ptscyl,1],Compile`GetElement[ptscyl,2]]}*)
(*]*)
(*,CompilationTarget->"C",RuntimeOptions->"Speed",RuntimeAttributes->{Listable},Parallelization->True]/.ruleDown[{\[Theta]Val,\[Phi]Val}]//ReleaseHold*)
(*\[Theta]\[Phi]Vals=\[Theta]\[Phi]ValsRand[pts];//AbsoluteTiming*)


(* ::Subsubsection::Closed:: *)
(*Phase space: HNLs, decay products*)


(* ::Input:: *)
(*nn=Length[\[Theta]\[Phi]Vals];*)
(*mass=0.02;*)
(*phasespace=PhaseSpacePerDecayChannel["HNL-mixing-mu",mass,"ee\[Nu]",nn,"True"];*)
(*(*\[Theta],\[Phi] for which HNLs would fly to the detector*)*)
(*angles=Take[\[Theta]\[Phi]Vals,{1,nn}];*)
(*(*HNL energies*)*)
(*prod="Fake \[Mu]";*)
(*energies=EnergySampling[prod,mass,nn];*)
(*momenta=Sqrt[energies^2-mass^2]*({Sin[angles[[All,1]]]Cos[angles[[All,2]]],Sin[angles[[All,1]]]Sin[angles[[All,2]]],Cos[angles[[All,1]]]}//Transpose);*)
(*daughtermomenta=boosting[energies,momenta,phasespace,mass];*)
(*Histogram[{daughtermomenta[[All,indexE1]],daughtermomenta[[All,indexE1+indexm1]],daughtermomenta[[All,indexE1]]+daughtermomenta[[All,indexE1+indexm1]]}]*)
(**)


(* ::Subsubsection::Closed:: *)
(*Smearing*)


(* ::Input:: *)
(*\[Alpha]Vals=\[Alpha]Smearing[daughtermomenta];*)
(*Histogram[{\[Alpha]Vals[[All,1]],\[Alpha]Vals[[All,2]],\[Alpha]Vals[[All,3]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\[Alpha] [rad]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"Unsmeared","Smeared \[Alpha]","Smeared \!\(\*SubscriptBox[\(\[Theta]\), \(1, 2\)]\)"},{0.2,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]]*)
(*weights=1/Sqrt[energies^2-mass^2](*Sin[angles[[All,1]]]/(Abs[Cos[angles[[All,1]]]]Sqrt[energies^2-mass^2])*)(*Table[1.,Length[angles]]*);*)
(*finaldata=Join[daughtermomenta,Partition[weights,1],\[Alpha]Vals,2];*)
(*{selection[finaldata,0.017,15*Pi/180.,3],selection[finaldata,0.017,15*Pi/180.,2],selection[finaldata,0.017,15*Pi/180.,1],*)
(*selection[finaldata,0.017,0.,3]}*)
(*{selection[finaldata,0.01,15*Pi/180.,3],selection[finaldata,0.01,15*Pi/180.,2],selection[finaldata,0.01,15*Pi/180.,1],*)
(*selection[finaldata,0.01,0.,3]}*)


(* ::Subsubsection::Closed:: *)
(*Comparing with Soleti*)


(* ::Input:: *)
(*phasespaceSoleti={#[[2]],#[[3]],#[[4]],#[[1]],0.5*10^-3,#[[4+2]],#[[4+3]],#[[4+4]],#[[4+1]],0.5*10^-3}&/@Import[FileNameJoin[{"temp1/shiness/phasespace_0.02.txt"}],"Table"];*)


(* ::Input:: *)
(*pt1=Histogram[{daughtermomenta[[All,indexE1]],phasespaceSoleti[[All,indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e1\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.8,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*pt2=Histogram[{daughtermomenta[[All,indexm1+indexE1]],phasespaceSoleti[[All,indexm1+indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e2\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.8,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*pt3=Histogram[{daughtermomenta[[All,indexE1]]+daughtermomenta[[All,indexm1+indexE1]],phasespaceSoleti[[All,indexm1+indexE1]]+phasespaceSoleti[[All,indexE1]]},100,"ProbabilityDensity",Frame-> True,FrameStyle->Directive[Black, 22],PlotRange->All,ImageSize->Large,FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(e1\)]\)+\!\(\*SubscriptBox[\(E\), \(e2\)]\) [GeV]","Fraction"},ChartLegends->Placed[Style[#,18]&/@{"SensCalc","Roberto"},{0.15,0.8}],ChartStyle->{Opacity[.15,Red],Opacity[.15,Blue],Opacity[.3,Darker@Green]},PlotLabel->Style[Row[{prod<>"->N+X, N->ee\[Nu]"}],18,Black]];*)
(*Style[Row[{pt1,pt2,pt3}],ImageSizeMultipliers->{1, 1,1}]*)
(**)
(**)


(* ::Subsection::Closed:: *)
(*Final state multiplicity*)


(* ::Input:: *)
(*(*(*Multiplicity per given particle*)*)
(*mtp[mt_]:=Switch[mt,111.,2,310.,2,221.,(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),113.,2,213.,3,331.,2+(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),223.,4,12.,0.,-12.,0,14.,0,-14.,0,16.,0,-16.,0,_,1]*)
(*mtpNoECAL[mt_]:=Switch[mt,111.,2,310.,2,221.,(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),113.,2,213.,3,331.,2+(2*0.4+6*0.32+4*0.23)/(0.4+0.32+0.23),223.,4,12.,0.,-12.,0,14.,0,-14.,0,16.,0,-16.,0,22.,0,130.,0,_,1]*)
(*mtp[210.]*)
(*listphasespaces[LLP_,mLLP_]:=Block[{},procslist=Table[{proc,ListBrRatios[LLP,mLLP,proc],If[ListBrRatios[LLP,mLLP,proc]>10^-3.,If[JetsPresence[LLP,proc]=="Yes",TakingHadronizedPhaseSpace[PhaseSpaceDecaysRestJets[LLP,proc,mLLP],30],{PhaseSpaceDecaysRest[LLP,proc,mLLP,30,"True"]}],{0}]},{proc,ProcessesList[LLP,"True"]}];*)
(*procslist=Select[procslist,#[[2]]>10^-3&];*)
(*multiplicity[i_]:=Module[{},*)
(*Do[*)
(*DATA[j]=procslist[[i]][[3]][[j]];*)
(*len[j]=Length[DATA[j]];*)
(*numparts=Length[DATA[j][[1]]]/8;*)
(*pdgpos=Table[8*(m-1)+6,{m,1,numparts,1}];*)
(*pdgs=DATA[j][[All,pdgpos]][[1]];*)
(*mtpval[j]=Sum[mtp[pdgs[[m]]],{m,1,Length[pdgs],1}];*)
(*mtpNoECALval[j]=Sum[mtpNoECAL[pdgs[[m]]],{m,1,Length[pdgs],1}];*)
(*,{j,1,Length[procslist[[i]][[3]]],1}];*)
(*{Sum[len[j]*mtpval[j],{j,1,Length[procslist[[i]][[3]]],1}]/Sum[len[j],{j,1,Length[procslist[[i]][[3]]],1}],Sum[len[j]*mtpNoECALval[j],{j,1,Length[procslist[[i]][[3]]],1}]/Sum[len[j],{j,1,Length[procslist[[i]][[3]]],1}]}*)
(*];*)
(*list=Sum[procslist[[i]][[2]]multiplicity[i],{i,1,Length[procslist],1}]/Sum[procslist[[i]][[2]],{i,1,Length[procslist],1}]*)
(*]*)
(*mulslist[LLP_]:=Block[{},*)
(*ttt2=Table[{mLLPlist[LLP][[k]],listphasespaces[LLP,mLLPlist[LLP][[k]]]},{k,1,Length[mLLPlist[LLP]],1}];*)
(*{Table[{ttt2[[i]][[1]],ttt2[[i]][[2]][[1]]},{i,1,Length[ttt2],1}],Table[{ttt2[[i]][[1]],ttt2[[i]][[2]][[2]]},{i,1,Length[ttt2],1}]}*)
(*]*)
(*fipsformult={"Scalar","HNL-mixing-e","ALP-gluon"};*)
(*multlist=Table[mulslist[LLP],{LLP,fipsformult}];*)
(*Show[ListPlot[{multlist[[1]][[1]],multlist[[1]][[2]],multlist[[2]][[1]],multlist[[2]][[2]],multlist[[3]][[1]],multlist[[3]][[2]]},Joined->True,PlotStyle->{{Thick,Blue},{Thick,Blue,Dashing[0.02]},{Thick,Darker@Red},{Thick,Darker@Red,Dashing[0.02]},{Thick,Darker@Darker@Green},{Thick,Darker@Darker@Green,Dashing[0.02]}},Frame\[Rule] True,FrameLabel\[Rule]{"Subscript[m, LLP] [GeV]" , "Subscript[n, per decay]"},FrameStyle\[Rule]Directive[Black, 23],ImageSize->Large,PlotRange\[Rule]{{0.05,4.5},{1,12}},PlotLabel\[Rule]Style[Row[{"Dashed: charged only. Solid: incl. \[Gamma],Subscript[K^0, L]"}],18,Black]],Plot[{0.9,0.9,0.9,0.9,0.9},{x,0,1},PlotStyle->{{Thick,Blue},{Thick,Darker@Red},{Thick,Darker@Darker@Green}},PlotLegends\[Rule]Placed[Style[#,18]&/@fipsformult,{0.24,0.8}]]]*)*)


(* ::Subsection::Closed:: *)
(*In the limit Subscript[E, LLP]/Subscript[m, LLP] >> 1 and in absence of energy cut and magnetic field etc ., Subscript[\[Epsilon], decay] must tend to 1 for the LLPs pointing to the detector and to 0 for those that do not point to the detector*)


(* ::Input:: *)
(*(*mtest=1.9;*)
(*LLPtest="Scalar";*)
(*test1=FinalBlockMass[LLPtest,mtest,ProcessesListRefined[LLPtest,ECALoptionGivenExperiment],1000,"True",">=2"];//AbsoluteTiming*)
(*{TableAzDecayAcceptanceToDet[[All,5]]//Mean,Select[TableAzDecayAcceptanceToDet,#[[2]]>40&][[All,5]]//Mean,Select[TableAzDecayAcceptanceToDet,#[[2]]>40&&#[[4]]!=0&][[All,5]]//Mean}*)
(*If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",TableAzDecayAcceptanceNotToDet[[All,5]]//Mean]*)
(*hist1=Histogram[Select[TableAzDecayAcceptanceToDet,#[[2]]>50*mtest&&#[[4]]!=0&][[All,5]],100]*)
(*hist2=If[DecayVolumeAsDetectorGivenExperiment\[Equal]"False",Histogram[Select[TableAzDecayAcceptanceNotToDet,#[[2]]>10*mtest&&#[[4]]!=0&][[All,5]],100]]*)*)
